{"meta":{"title":"xLee's blog","subtitle":"专注网站建设优化，做互联网的搬砖人","description":"Hexo/Hugo... + GitHub 免费仓库托管入门教程引导。用最简单的方案，办最实用的事，微软不倒，羊毛到老！","author":"李翔的博客","url":"https://iexlee.github.io","root":"/"},"pages":[{"title":"关于本站","date":"2023-08-19T15:53:01.904Z","updated":"2023-08-19T15:53:01.904Z","comments":false,"path":"about/index.html","permalink":"https://iexlee.github.io/about/index.html","excerpt":"","text":"感谢访问我的网站，本站是使用Hexo框架+Fluid主题搭建 本网站用于记录学习过程的笔记，以及技术方面的分享"},{"title":"archives","date":"2020-07-18T05:10:34.000Z","updated":"2023-08-19T15:53:01.904Z","comments":false,"path":"archives/index.html","permalink":"https://iexlee.github.io/archives/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-08-30T03:41:17.000Z","updated":"2023-08-19T15:53:01.904Z","comments":false,"path":"categories/index.html","permalink":"https://iexlee.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2020-08-30T14:45:09.000Z","updated":"2023-08-19T15:53:01.904Z","comments":false,"path":"contact/index.html","permalink":"https://iexlee.github.io/contact/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-08-30T14:40:51.000Z","updated":"2023-08-19T15:53:01.904Z","comments":false,"path":"friends/index.html","permalink":"https://iexlee.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2016-12-31T10:09:56.000Z","updated":"2016-12-31T10:09:56.000Z","comments":false,"path":"history/index.html","permalink":"https://iexlee.github.io/history/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-05-28T03:09:14.000Z","updated":"2023-08-19T15:53:01.904Z","comments":false,"path":"link/index.html","permalink":"https://iexlee.github.io/link/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-24T09:37:05.000Z","updated":"2017-02-24T09:37:05.000Z","comments":false,"path":"tags/index.html","permalink":"https://iexlee.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Git (3)","slug":"43、Git教程","date":"2022-09-02T01:00:00.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"43、Git教程.html","link":"","permalink":"https://iexlee.github.io/43%E3%80%81Git%E6%95%99%E7%A8%8B.html","excerpt":"","text":"# git 教程 9. 远程仓库我们的代码不能总是放在本地,因为总是放在本地,一旦电脑出现故障,数据将丢失,怎么共享呢,这里我们需要一个服务器, 我们可以把代码放到服务器上,然后让别人下载,这样我峨嵋你既可以备份代码,也可以进行团队协作开发 9.0 局域网仓库1实际上我们可以搭建一个单间的局域网服务器共享我们的代码 9.0.1本地相对路径,多个文件夹之间共享代码 9.0.2开启局域网共享代码 局域网这种共享是没有安全控制的,都可以访问,如果想要搭建一个可以控制权限的服务器需要借助第三方软件 gitblit,可以自行搜索搭建 9.1 常用远程仓库托管服务除了自己搭建服务器,其实我们可以使用一些免费的远程仓库,远程仓库有很多,常见的免费互联网远程仓库托管服务如下: 1234567891011121314151617www.github.comwww.gitee.comwww.gitlab.comgithub 是一个基于git实现在线代码托管的仓库，向互联网开放，企业版要收钱。gitee 即码云，是 oschina 免费给企业用的，不用自己搭建环境。gitlab 类似 github，一般用于在企业内搭建git私服，要自己搭环境。GitHub(gitee)、GitLab 不同点：1、GitHub如果使用私有仓库是需要付费的，(2019年开始私有仓库也是免费的但是只能3个人协同开发,想要更多需要收费)，GitLab可以在上面搭建私人的免费仓库。2、GitLab让开发团队对他们的代码仓库拥有更多的控制，相对于GitHub，它有不少的特色： (1)允许免费设置仓库权限 (2)允许用户选择分享一个project的部分代码 (3)允许用户设置project的获取权限，进一步提升安全性 (4)可以设置获取到团队整体的改进进度 (5)通过innersourcing让不在权限范围内的人访问不到该资源 鉴于国内用户可能网络不好,这里我们使用gitee(码云) 来讲解我们的课程,其他可自行找资料学习非常类似 9.2 码云账号注册 填写邮箱发送验证码,然后可以注册账号,主页如下 9.3 创建远程仓库 各个类型仓库之间的区别 9.4 把本地代码推送到远端 此时我们刷新仓库发现代码已经存在了 我们填写的用户信息,会被保存在本地,下次提交无需填写用户名和密码 9.5 从远程仓库克隆代码我们同样可以从库下载代码, 新建一个文件夹 repo2 ,进入然后进行如下操作 此时我们发现我们的代码已经被下载下来了 9.6 代码的修改与提交,查看历史1231)此时我们修改代码就不能仅仅是提交到本地了,提交完毕应该推送到远端服务器2)此时如果别人从远端仓库下载最新的代码其实是可以看到我们的代码修改记录的 git --&gt;显示日志 9.7 ssh 连接概述1实际上git 不仅仅支持用户名密码方式的配置,可以有另外一种相对更加安全的配置即ssh 方式配置 ssh 方式的底层原理 12345ssh连接地城是RAS加密算法,又称非对称加密,是一种现在公认的最安全的加密方式数学基础好的同学可以研究一下https://www.cnblogs.com/cjm123/p/8243424.html公钥私钥加密可以看作古代 的&quot;虎符&quot; , 我们本地电脑有一份,远程服务器有一份, 只要 &quot;虎符&quot; 核对通过 表示身份无误,可以执行提交等操作,无需输入用户名密码 9.8 ssh 密钥的生成1234#生成公钥私钥 ssh-keygen -t rsa 一直回车即可 会默认用户目录 .ssh 目录生成一个默认的id_rsa文件 和id_rsa.pub 9.9 ssh 密钥配置 9.10 ssh 方式克隆&#x2F;提交代码: 配置完成之后我们克隆我们之前的项目 修改后直接提交推送即可成功,,git 会自动去.ssh 目录找我们的私钥进行匹配 9.11. 远程仓库的其他操作概念 当我们从 gitee 上查看别人的项目的时候我们可能会看到上图中的按钮 12指数: 是gitee 网站根据当前项目的各项指标计算出来的一个值 1234567891011121314Star: 点赞, 注意这里的并不像朋友圈那样容易获得点赞,圈内人还是很克制的Watch: 如果你watch 了某个开源项目,那么这个项目后续所有的改动你将收到通知Fork : 将别人的代码克隆到你自己的仓库 作用一: 如果担心某个优秀的项目别人突然有一天不开源了,你可以fork到自己的仓库 作用二: 修改别人的代码 以linux 为例,你其实不是linux 社区的开发人员,但是你 又想为linux 开发做贡献(维护代码) 你并没有权限,怎们办? 你可以先把linux 开源的代码 fork 到你自己的仓库,此时你就可以操作自己的仓库进行修改代码了 如何让别人合并你修改好的代码呢? 我们注意项目的上方有一个 &quot; Pull Request&quot; 这个按钮的意思是 &quot;请求求别人合并你修改的代码&quot; 当我们发起一个 Pull Request 时 , 项目的拥有者将收到 Pull Request请求,然后将根据你提交代码的质量决定是否合并 项目操作 1)我们可以删除修改我们自己仓库的基本信息 我们可以邀请其他人成为项目的开发人员或者管理人员 我们可以删除修改我们自己仓库的基本信息 9.12 利用 gitee 搭建个人主页1234561)将静态资源上传至仓库2) 选择服务 pages 即可部署注意 1)必须有个index.html 文件注意 2) 只能搭建静态网站,动态网站请租赁服务器搭建提供服务注意 3) gitee 要求必须绑定手机号 点击开启后gitee 会自动生成一个域名 直接访问即可 此时我们已经在git 上部署了一个静态的网站 10.命令行– git基本操作10.1 介绍​ 上述我们的操作 使用的 是客户端TortoiseGit 操作的git ,实际上底层依旧是使用的命令行帮我们执行, 在早期 git 并没有窗口化工具,开发人员只能使用命令行模式 实际上,如果你掌握并熟练使用了命令行模式操作git 的话,你会发现某些操作命令行比窗口化操作要简单 所有你在工作中会发现高深的技术人员可能会喜欢命令行模式提交git ##10.2 环境配置 当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息 12345678#设置用户信息 git config --global user.name “itcast” git config --global user.email “itcast@itcast.cn”#查看配置信息 git config --list git config user.name#通过上面的命令设置的信息会保存在~/.gitconfig文件中 ##10.3 初始化本地仓库 init 1234# 初始化仓库带工作区git init# 初始化仓库不带工作区git init --bare ##10.4 克隆 clone 123# 从远程仓库克隆git clone 远程Git仓库地址 例如: git clone https://gitee.com/itcast/gittest.git ##10.5 查看状态 status 1234# 查看状态git status #查看状态 使输出信息更加简洁git status –s ##10.6 add 12345# 将未跟踪的文件加入暂存区git add &lt;文件名&gt; # 将暂存区的文件取消暂存 (取消 add )git reset &lt;文件名&gt; ##10.7 commit 123# git commit 将暂存区的文件修改提交到本地仓库git commit -m &quot;日志信息&quot; &lt;文件名&gt; ##10.8 删除 rm 1234# 从本地工作区 删除文件git rm &lt;文件名&gt; # 如果本工作区库误删, 想要回退git checkout head &lt;文件名&gt; 11. 命令行–git 远程仓库操作11.1 查看远程1234567# 查看远程 列出指定的每一个远程服务器的简写git remote # 查看远程 , 列出 简称和地址git remote -v # 查看远程仓库详细地址git remote show &lt;仓库简称&gt; 11.2 添加&#x2F;移除远测仓库1234# 添加远程仓库git remote add &lt;shortname&gt; &lt;url&gt;# 移除远程仓库和本地仓库的关系(只是从本地移除远程仓库的关联关系，并不会真正影响到远程仓库)git remote rm &lt;shortname&gt; 11.3 从远程仓库获取代码123456789# 从远程仓库克隆git clone &lt;url&gt; # 从远程仓库拉取 (拉取到.git 目录,不会合并到工作区,工作区发生变化)git fetch &lt;shortname&gt; &lt;分支名称&gt;# 手动合并 把某个版本的某个分支合并到当前工作区git merge &lt;shortname&gt;/&lt;分支名称&gt;# 从远程仓库拉取 (拉取到.git 目录,合并到工作区,工作区不发生变化) = fetch+mergegit pull &lt;shortname&gt; &lt;分支名称&gt;git pull &lt;shortname&gt; &lt;分支名称&gt; --allow-unrelated-histories # 强制拉取合并 注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在git pull命令后加入参数–allow-unrelated-histories (如上 命令) 12# 将本地仓库推送至远程仓库的某个分支git push [remote-name] [branch-name] 12. 命令行– 分支123456789101112131415# 默认 分支名称为 master# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 创建分支git branch &lt;分支名&gt;# 切换分支 git checkout &lt;分支名&gt;# 删除分支(如果分支已经修改过,则不允许删除)git branch -d &lt;分支名&gt;# 强制删除分支git branch -D &lt;分支名&gt; 123456# 提交分支至远程仓库git push &lt;仓库简称&gt; &lt;分支名称&gt; # 合并分支 将其他分支合并至当前工作区git merge &lt;分支名称&gt;# 删除远程仓库分支git push origin –d branchName 13 . 命令行 –tag1234567891011121314# 列出所有taggit tag# 查看tag详细信息 git show [tagName]# 新建一个taggit tag [tagName]# 提交指定tag$ git push [仓库简称] [tagName]# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]# 删除本地tag$ git tag -d [tag]# 删除远程tag (注意 空格)$ git push origin :refs/tags/[tag] 14. 案例12345678910111213141516171819202122232425企业中我们是如何开发的1) 入职第一天,管理人员分配/git账号密码 2) 开发人员下载代码即文档/ 根据文档将环境搭建成功3) 团队一般会给你讲讲项目相关的支持----4) 你接到第一个需求(或者某个功能,一般要经过沟通,分析,设计...等过程)5) 创建feature分支(一般一个需求对应一个feature,命名格式上标注该需求的id)6) 开发需求,本地测试,提交代码到当前需求对应的feature分支, 一般来讲为了避免将测试代码提交,需要提交前,检查如下步骤 6.1) 是否多提交了某个文件,比如测试文件 6.2) 是否漏提交文件 6.3) 打开每一个应该提交的文件,判断是否多提交了一行代码,是否少提交了一行代码,是否删除了本应该存在的代码 检查完毕提交代码7) 合并分支至test分支-- 测试人员会在test分支中测试8) 测试人员测试bug ,开发者在feature分支上继续修改,提交9) 测试人员测试通过 ,test分支会被测试人员合并到develop开发分支,再次测试10)develop分支最终会被合并到master主分支 &#96;","categories":[{"name":"git","slug":"git","permalink":"https://iexlee.github.io/categories/git/"}],"tags":[]},{"title":"Git (2)","slug":"42、Git教程","date":"2022-08-25T01:00:00.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"42、Git教程.html","link":"","permalink":"https://iexlee.github.io/42%E3%80%81Git%E6%95%99%E7%A8%8B.html","excerpt":"","text":"# git 教程 5. Git 工作流程5.1 Git 初始化我们先初始化一个本地仓 121) 新建测试文件夹2) 进入文件夹,然后右键创建版本库 此时 我们看到 121) 文件夹上多了一个绿色图标(如果没有请看本章节 5.3小节说明)2) 文件夹内部生成了一个.git 隐藏文件夹(需要设置隐藏文件夹可见) 5.2 git 流程5.2.1 流程图 5.2.2概念即详解12345678本地仓库：是在开发人员自己电脑上的Git仓库,存放我们的代码(.git 隐藏文件夹就是我们的本地仓库) 远程仓库：是在远程服务器上的Git仓库,存放代码(可以是github.com或者gitee.com 上的仓库,或者自己该公司的服务器)工作区: 我们自己写代码(文档)的地方暂存区: 在 本地仓库中的一个特殊的文件(index) 叫做暂存区,临时存储我们即将要提交的文件------------Clone：克隆，就是将远程仓库复制到本地仓库Push：推送，就是将本地仓库代码上传到远程仓库Pull：拉取，就是将远程仓库代码下载到本地仓库,并将代码 克隆到本地工作区 6.Git 的基本使用01-TortoiseGit 操作本地仓库6.1 初始化仓库123方法一: 新建一个文件夹,进入文件夹内部操作1)右键--&gt; 在这里创建Git 版本库 注意: 不要直接在桌面上操作,否则桌面就是一个仓库 12方法二:2) 右键--&gt;Git GUI here 12方法三: 命令行模式2) git init 创建完毕仓库,我们发现,此时我们创建的文件夹下有一个.git 文件已经生成了 并且仓库文件夹上多了一个 绿色图标 6.2 添加文件1231)在仓库中新建一个文件2)选中新建的文件--&gt;右键--&gt; TortoiseGit--&gt; 添加3)此时我们看到文件夹上多了一个 &quot;加号&quot; 6.3 提交文件至本地仓库121)选中文件2) 右键--git提交 6.4 修改文件,与再次提交文件12当我们修改文件以后,文件上多了一个红色感叹号,表示我们上次提交后该文件被修改过提交后文件图标又变成绿色 6.5 文件状态讲解123456Git工作目录下的文件存在两种状态：1 untracked 未跟踪（未被纳入版本控制） : 比如新建的文件(此时文件夹上没有图标或者有一个&quot;问号&quot;)2 tracked 已跟踪（被纳入版本控制） 2.1 Staged 已暂存状态 : 添加 但未提交状态(此时文件夹上有一个&quot;加号&quot;) 2.2 Unmodified 未修改状态 : 已提交(此时文件夹上有一个&quot;对号&quot;) 2.3 Modified 已修改状态 : 修改了,但是还没有提交 (此时文件夹上有一个&quot;红色感叹号&quot;) 这些文件的状态会随着我们执行Git的命令发生变化 6.6 修改文件,不提交和上一个版本比较差异(diff)12修改文件,此时不要提交选中文件--&gt;右键--&gt; TortoiseGit--&gt; 比较差异 6.7 查看提交历史记录123选中文件右键--&gt; TortoiseGit--&gt; 显示日志此时我们可以看到所有的历史提交记录 ##6.8 回退至历史版本 12右键--&gt; TortoiseGit--&gt; 显示日志选中某个版本--&gt; 进行如下操作 6.9 文件删除###6.9.1本地删除与恢复 123451) 直接选中文件删除的话,其实只是删除了本地工作区的文件,并没有删除 仓库中的文件 此时时可以回退的, 比如我们进行如下操作 1)文件删除 2)右键--&gt; TortoiseGit--&gt; 还原 此时我们发现文件又被恢复了 6.9.2从版本库删除1232) 我们如果真的想要将某个文件从服务器删除,需要进行如下操作 1) 删除文件,和上面的操作一样 2) 提交,此时服务文件已经删除了(历史版本还在,还是可以恢复) 6.9.3从版本库删除,但是不删除本地12我们可以如下操作,只删除服务器上的文件,但是本地文件并不删除备注: 删除之后需要提交,才会真正的从服务器删除 6.10 忽略提交12有时候我们一些文件是不需要提交的比如说idea/eclipse 开发的代码自动生成的配置文件如何配置不提交呢 此时我们的根目录下会生成一个.gitignore 文件 忽略文件如何阅读,常见格式 123456789101112# 所有以.a 结尾的文件讲被忽略(递归)*.a# 不管其他规则怎样,强制不忽略 lib.a!lib.a# 只忽略 文件 TODO (注意这里是文件)/TODO# 忽略 build文件夹下所有内容(递归) 这里是文件夹build/# 忽略 doc 目录下以 *.txt 结尾的文件 (不递归)doc/*.txt# 忽略 doc 目录下以 *.pdf 结尾的文件 (递归)doc/**/*.pdf 当然理解了上述规则,我们也可以手动编辑该文件,而不用通过窗口化操作(如果不嫌麻烦) 7. Git 的基本使用02-TortoiseGit 操作本地仓库(分支)7.1 分支的概念1几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，避免影响开发主线。多线程开发,可以同时开启多个任务的开发,多个任务之间互不影响. 7.2 为何要使用分支先看单线程开发 1234567思考如下现象 10.1 日 业务部门提出需求 : 明年 元旦3天做2个促销活动 1) 12.31 号上线活动1, 2) 1.4 号上线活动2 ,同时 要求撤销 活动1 你所在 部门领导 为了保证能顺利完成,要求 11.15 号完成 上述连个功能的开发工作此时作为开发人员:我要面临两个文件, 活动1 的代码,即要存在(12.31 要用)又要不存在(1.4 号要求删除) ,我们怎么做?显然比较棘手,如果使用分支(可以理解为将代码复制一份)将很好解决 7.3 创建分支12到现在为止,我们一直使用的时主分支(master)在主分支上操作创建分支 7.4 分支的查看切换7.4.1查看分支123查看版本分支图,此时我们看到有两个分支当然,我们可以创建多个分支可以看到多个分支的图形 7.4.2切换分支1右键--&gt; 检出 ##7.5 分支的合并与删除 7.5.1合并12345我们将代码切换到分支1,然后写属于需求1 的代码并提交当我们把需求1 开发完毕如何把需求1 的代码合并到主分支呢?--&gt;1 切换到 主版本--&gt;2 右键 合并即可将需求1 写的代码合并至主分支-----此时我们看到代码自动合并到了master分支 7.5.2删除分支 5,冲突的处理​ 5.1)冲突的概念 123456现象演示 开发人员A 开发需求1,开发了一个工具类 MathUtil,里面第一行写了一个方法 add(int [] args) 同时开发人员B 开发需求2,开发了一个工具类 MathUtil,里面第一行写了一个方法 add(int a int b)他们在互相不知道对方需求的情况下同时提交了代码到自己的分支 思考此时如果我们把需求1 和需求2 同时都合并到主分支上, 主分支的 工具类 MathUtil 的第一行应该使用谁的代码? 此时主分支是不能智能判断第一行使用谁的代码,合并时会报错,我们叫做冲突. ​ 5.2) 如何处理冲突 12345678910分析一下冲突的原因: 开发人员之间彼此没有沟通导致的同一个时间节点修改了同一个地方的代码,合并是冲突思考: 我们能直接把某个开发人员开发的代码删除吗?显然不能 所以在处理冲突时,第一步应该时找开发另一个需求的人员沟通,之后才是处理冲突-------&gt; 选中冲突的文件(带黄色感叹号的文件都是冲突的文件,如果有多个需要逐一处理)--&gt; 右键--&gt; 编辑冲突,--&gt;处理完毕后.标记已解决 8.tag 标签8.1 标签的概念123如果你的项目达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以给它打上标签(tag)比如说，我们想为我们的项目发布一个&quot;1.0&quot;版本。 我们给最新一次提交打上（HEAD）&quot;v1.0&quot;的标签。标签可以理解为项目里程碑的一个标记,一旦打上了这个标记则,表示当前的代码将不允许提交 8.2 标签的创建(tag)1标签的创建和分支的创建操作几乎一样 8.3 标签的切换与删除 `","categories":[{"name":"git","slug":"git","permalink":"https://iexlee.github.io/categories/git/"}],"tags":[]},{"title":"Git  (1)","slug":"41、Git教程","date":"2022-08-18T01:00:00.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"41、Git教程.html","link":"","permalink":"https://iexlee.github.io/41%E3%80%81Git%E6%95%99%E7%A8%8B.html","excerpt":"","text":"# git 教程 [TOC] 1.版本管理工具概念我在大学毕业写论文的时候的时候碰到过如下的现象 12345&lt;&lt;毕业论文第一版.doc&gt;&gt;&lt;&lt;毕业论文第二版.doc&gt;&gt;&lt;&lt;毕业论文第三版.doc&gt;&gt;&lt;&lt;毕业论文最终版.doc&gt;&gt;&lt;&lt;毕业论文最终版2.doc&gt;&gt; 类似的问题我曾经也碰到过很多,例如: 1领导让写文档,写好了,领导让修改,改好了,领导觉得第一版不错,改回来吧,此时内心一脸懵,第一版长啥样没存档啊 实际上,代码开发中也需要这样的软件来管理我们的代码. 例如我们经常会碰到如下的现象: 1改之前好好的,改完就报错了,也没怎么修改啊 在这种情况下如果不能查看修改之前的代码,查找问题是非常困难的. 如果有一个软件能记录我们对文档的所有修改,所有版本,那么上面的问题讲迎刃而解.而这类软件我们一般叫做版本控制工具 版本管理工具一般具有如下特性: 121) 能够记录历史版本,回退历史版本2) 团队开发,方便代码合并 2. 版本管理工具介绍现在比较流行的版本管理工具是git ,但是实际上git 是近几年才发展起来的,可能有一些老的项目,还在用一些老的软件,比如svn 2.1版本管理发展简史(维基百科) 2.1.1 SVN(SubVersion)工作流程 1234SVN是集中式版本控制系统，版本库是集中放在中央服务器的.工作流程如下: 1.从中央服务器远程仓库下载代码 2.修改后将代码提交到中央服务器远程仓库 优缺点: 1234优点: 简单,易操作缺点:所有代码必须放在中央服务器 1.服务器一旦宕机无法提交代码,即容错性较差 2.离线无法提交代码,无法及时记录我们的提交行为 svn流程图 2.1.2 Git工作流程 12345678Git是分布式版本控制系统（Distributed Version Control System，简称 DVCS），分为两种类型的仓库：本地仓库和远程仓库工作流程如下 1．从远程仓库中克隆或拉取代码到本地仓库(clone/pull) 2．从本地进行代码修改 3．在提交前先将代码提交到暂存区 4．提交到本地仓库。本地仓库中保存修改的各个历史版本 5．修改完成后，需要和团队成员共享代码时，将代码push到远程仓库 总结:git和svn的区别 121. svn 是集中式版本控制工具,git 是分布式版本控制工具2. svn 不支持离线提交,git 支持离线提交代码 3. Git 发展简史 林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds, 1969年~ ） 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？那个年代不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。而授权的前提是:Linux 社区的人不能开发具有相同功能的竞争产品! 另一方面,BitKeeper不是开源的. 显然与Linux 的开源精神不相符,所以linux 社区的很多人抱怨,不愿意使用. 典型的就是 Andrew Tridgell (Samba 开发服务的创造者) 非常不满.偷偷违反了和 BitKeeper 的协议,反编译 BitKeeper 的源代码,开发了个爬虫,然后爬取信息被人发现了. BitKeeper 公司的领导非常不满意,然后开始发布消息说,(下个版本)不再为Linux 提供免费的服务. Linus 本人就出面协调(几周或者几个月),但是不管用, 没办法. 估计谈判的过程感觉到了憋屈–”吃人嘴短,拿人手软” Linus 本人 花了10天的时间Git 出来了,一个月之内，Linux系统的源码已经由Git管理了！ Git 出来以后毕竟是一个人做的,开始并不好用(刚开始只能用勉强可以用来形容), 还是很多人抱怨,发展了很多年都没有干过其他软件. 直到 2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub,从此git 迎来了飞速发展,当下git 已经成为了最流行的版本控制工具 4. Git 的安装4.1 git 的下载下载地址： https://git-scm.com/download 附件 ## 4.2 安装 按照附件的 顺序直接下一步傻瓜式安装即可 其中安装的过程中需要填写一个邮箱和用户名(任意即可) $\\color{red}{注意: 安装完毕请重启资源管理器,或者重启电脑!!!}$ 更改语言","categories":[{"name":"git","slug":"git","permalink":"https://iexlee.github.io/categories/git/"}],"tags":[]},{"title":"MySQL 索引的数据结构","slug":"13、索引的创建与设计原则","date":"2022-08-06T01:00:00.000Z","updated":"2023-08-19T15:53:01.896Z","comments":true,"path":"13、索引的创建与设计原则.html","link":"","permalink":"https://iexlee.github.io/13%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.html","excerpt":"","text":"第 08 章_索引的创建与设计原则1. 索引的声明与使用1. 1 索引的分类MySQL的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。 从功能逻辑上说，索引主要有 4 种，分别是普通索引、唯一索引、主键索引、全文索引。 按照物理实现方式，索引可以分为 2 种：聚簇索引和非聚簇索引。 按照作用字段个数进行划分，分成单列索引和联合索引。 普通索引 唯一性索引 主键索引 单列索引 多列(组合、联合)索引 最左前缀 全文索引 补充：空间索引 使用参数SPATIAL可以设置索引为空间索引。空间索引只能建立在空间数据类型上，这样可以提高系统获取空间数据的效率。MySQL中的空间数据类型包括GEONETRY、POINT、LINESTRING和POLYGON等。目前只有MyISAM存储引擎支持空间检索，而且索引的字段不能为空值。对于初学者来说，这类索引很少会用到。 **小结：不同的存储引擎支持的索引类型也不一样 ** InnoDB ： 支持 B-tree、Full-text 等索引，不支持 Hash索引； MyISAM ： 支持 B-tree、Full-text 等索引，不支持 Hash 索引； Memory ： 支持 B-tree、Hash 等索引，不支持 Full-text 索引； NDB ： 支持 Hash 索引，不支持 B-tree、Full-text 等索引； Archive ： 不支持 B-tree、Hash、Full-text 等索引； 1. 2 创建索引MySQL支持多种方法在单个或多个列上创建索引:在创建表的定义语句CREATE TABLE中指定索引列，使用ALTER TABLE语句在存在的表上创建索引，或者使用CREATE INDEX语句在已存在的表上添加索引。 1. 创建表的时候创建索引使用CREATE TABLE创建表时，除了可以定义列的数据类型外，还可以定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。 举例： 1234CREATE TABLE dept(dept_id INT PRIMARY KEY AUTO_INCREMENT,dept_name VARCHAR( 20 )); 123456CREATE TABLE emp(emp_id INT PRIMARY KEY AUTO_INCREMENT,emp_name VARCHAR( 20 ) UNIQUE,dept_id INT,CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)); 但是，如果显式创建表时创建索引的话，基本语法格式如下： 123CREATE TABLE table_name [col_name data_type][UNIQUE | FULLTEXT | SPATIAL][INDEX |KEY][index_name] (col_name [length]) [ASC | DESC] UNIQUE、FULLTEXT和SPATIAL为可选参数，分别表示唯一索引、全文索引和空间索引； INDEX与KEY为同义词，两者的作用相同，用来指定创建索引； index_name指定索引的名称，为可选参数，如果不指定，那么MySQL默认col_name为索引名； col_name为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择； length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度； ASC或DESC指定升序或者降序的索引值存储。 1.创建普通索引 在book表中的year_publication字段上建立普通索引，SQL语句如下： 12345678910111213141516171819202122232425262728293031#显式的方式创建#1创建普通的索引CREATE TABLE book ( book_id INT , book_name VARCHAR (100) , AUTHORS VARCHAR (100) , info VARCHAR(100) , COMMENT VARCHAR (100) , year_publication YEAR, #声明索引 INDEX idx_bname (book_name));#通过命令查看索引#方式l:mysql&gt; show create table book \\G*************************** 1. row *************************** Table: bookCreate Table: CREATE TABLE `book` ( `book_id` int(11) DEFAULT NULL, `book_name` varchar(100) DEFAULT NULL, `AUTHORS` varchar(100) DEFAULT NULL, `info` varchar(100) DEFAULT NULL, `COMMENT` varchar(100) DEFAULT NULL, `year_publication` year(4) DEFAULT NULL, KEY `idx_bname` (`book_name`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec)# 方式2： show index from book; show index from book太好用了，必须要会 2.创建唯一索引 举例： 123456789# 创建唯一索引CREATE TABLE book ( book_id INT , book_name VARCHAR (100) , #声明索引 UNIQUE INDEX uk_idx_bname (book_name));show index from book; 该语句执行完毕之后，使用SHOW CREATE TABLE查看表结构： 3.主键索引 设定为主键后数据库会自动建立索引，innodb为聚簇索引，语法： 123456CREATE TABLE book ( # 创建主键索引 book_id INT primary key, book_name VARCHAR (100); 删除主键索引： 12ALTER TABLE studentdrop PRIMARY KEY ; 修改主键索引：必须先删除掉(drop)原索引，再新建(add)索引 4.创建组合索引 12345678910# 创建唯一索引CREATE TABLE book ( book_id INT , book_name VARCHAR (100) , author VARCHAR (100) , #声明索引 INDEX union_key_ba (book_name,author));show index from book; 5.创建全文索引 6.创建空间索引 空间索引创建中，要求空间类型的字段必须为非空。 举例：创建表test5，在空间类型为GEOMETRY的字段上创建空间索引，SQL语句如下： 2.在已经存在的表上创建索引在已经存在的表中创建索引可以使用ALTER TABLE语句或者CREATE INDEX语句。 使用ALTER TABLE语句创建索引 ALTER TABLE语句创建索引的基本语法如下： 123456ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY][index_name] (col_name[length],...) [ASC | DESC]ALTER TABLE book ADD INDEX index_name(book_name);ALTER TABLE book ADD UNIQUE uk_idx_bname(book_name);ALTER TABLE book ADD UNIQUE mul_bid_na(book_name,author); 使用CREATE INDEX创建索引 CREATE INDEX语句可以在已经存在的表上添加索引，在MySQL中，CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法结构为： 1234567CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_nameON table_name (col_name[length],...) [ASC | DESC]create 索引类型 索引名称 on 表名(字段);create index idx_cmt on book(comment);create unique index idx_cmt on book(comment);create index idx_cmt on book(comment,author); 3 删除索引 使用ALTER TABLE删除索引 ALTER TABLE删除索引的基本语法格式如下： 1ALTER TABLE table_name DROP INDEX index_name; 使用DROP INDEX语句删除索引 DROP INDEX删除索引的基本语法格式如下： 1DROP INDEX index_name ON table_name; 在需要大量删除表数据，修改表数据时，可以考虑先删除索引。等修改完数据之后再插入 AUTO_INCREMENT 约束字段的唯一索引不能被删除 提示 删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除。 2.MySQL 8. 0 索引新特性2. 1 支持降序索引降序索引以降序存储键值。虽然在语法上，从MySQL 4版本开始就已经支持降序索引的语法了，但实际上该DESC定义是被忽略的，直到MySQL 8.x版本才开始真正支持降序索引(仅限于InnoDB存储引擎)。 MySQL在8.0版本之前创建的仍然是升序索引，使用时进行反向扫描，这大大降低了数据库的效率。在某些场景下，降序索引意义重大。例如，如果一个查询，需要对多个列进行排序，且顺序要求不一致，那么使用降序索引将会避免数据库使用额外的文件排序操作，从而提高性能。 举例：分别在MySQL 5. 7 版本和MySQL 8. 0 版本中创建数据表ts 1 ，结果如下： 1CREATE TABLE ts1(a int, b int, index idx_a_b(a, b desc) ) ; 在MySQL 5. 7 版本中查看数据表ts 1 的结构，结果如下： 123456789mysql&gt; show create table ts1 \\G*************************** 1. row *************************** Table: ts1Create Table: CREATE TABLE `ts1` ( `a` int(11) DEFAULT NULL, `b` int(11) DEFAULT NULL, KEY `idx_a_b` (`a`,`b`)) ENGINE=InnoDB DEFAULT CHARSET=utf81 row in set (0.00 sec) 从结果可以看出，索引仍然是默认的升序。 在MySQL 8. 0 版本中查看数据表ts 1 的结构，结果如下： 123456789mysql&gt; show create table ts1 \\G*************************** 1. row *************************** Table: ts1Create Table: CREATE TABLE `ts1` ( `a` int DEFAULT NULL, `b` int DEFAULT NULL, KEY `idx_a_b` (`a`,`b` DESC)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb31 row in set (0.00 sec) 从结果可以看出，索引已经是降序了。下面继续测试降序索引在执行计划中的表现。 分别在MySQL 5. 7 版本和MySQL 8. 0 版本的数据表ts 1 中插入 800 条随机数据，执行语句如下： 1CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc)); 12345678910111213141516171819DELIMITER //CREATE PROCEDURE ts_insert () BEGIN DECLARE i INT DEFAULT 1; WHILE i &lt; 800 DO INSERT INTO ts1 SELECT rand()* 80000, rand()* 80000; SET i = i + 1; END WHILE; COMMIT; END // DELIMITER;#调用CALL ts_insert (); 在MySQL 5.7版本中查看数据表ts1的执行计划，结果如下： 1234567mysql&gt; explain select * from ts1 order by a, b desc limit 5;+----+------+----------+-----------------------------+| id | rows | filtered | Extra |+----+------+----------+-----------------------------+| 1 | 1598 | 100.00 | Using index; Using filesort |+----+------+----------+-----------------------------+1 row in set, 1 warning (0.01 sec) 从结果可以看出，执行计划中扫描数为 1598，而且使用了Using filesort。 提示 Using filesort是MySQL中一种速度比较慢的外部排序，能避免是最好的。多数情况下，管理员可以通过优化索引来尽量避免出现Using filesort，从而提高数据库执行速度。 在MySQL 8.0版本中查看数据表ts1的执行计划。 1234567mysql&gt; explain select * from ts1 order by a, b desc limit 5;+----+---------+-----+----------+-------------+| id | key |rows | filtered | Extra |+----+---------+-----+----------+-------------+| 1 | idx_a_b | 5 | 100.00 | Using index |+----+---------+-----+----------+-------------+1 row in set, 1 warning (0.03 sec) 从结果可以看出，执行计划中扫描数为 5 ，而且没有使用Using filesort。 注意 降序索引只对查询中特定的排序顺序有效，如果使用不当，反而查询效率更低。例如，上述查询排序条件改为order by a desc, b desc，MySQL 5.7的执行计划要明显好于MySQL 8.0。 2.2 隐藏索引在MySQL 5.7版本及之前，只能通过显式的方式删除索引。此时，如果发现删除索引后出现错误，又只能通过显式创建索引的方式将删除的索引创建回来。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。 从MySQL 8.x开始支持隐藏索引（invisible indexes），只需要将待删除的索引设置为隐藏索引，使查询优化器不再使用这个索引（即使使用force index（强制使用索引），优化器也不会使用该索引）确认将索引设置为隐藏索引后系统不受任何响应，就可以彻底删除索引。这种通过先将索引设置为隐藏索引，再删除索引的方式就是软删除。 同时，你想验证某个索引删除之后的查询性能影响，就可以暂时先隐藏该索引 注意: 主键不能被设置为隐藏索引。当表中没有显式主键时，表中第一个唯一非空索引会成为隐式主键，也不能设置为隐藏索引。 索引默认是可见的，在使用CREATE TABLE，CREATE INDEX或者ALTERTABLE等语句时可以通过VISIBLE或者INVISIBLE关键词设置索引的可见性。 创建表时直接创建 1.在MySQL中创建 隐藏索引通过SQL语句INVISIBLE来实现，其语法形式如下： 123456789101112CREATE TABLE tablename( propname1 type1 [ CONSTRAINT1],propname2 type2[ CONSTRAINT2], ... propnamen typen, INDEX [indexname ](propname1 [ ( length)]) INVISIBLE);create table book2( id int primary key, book_name varchar(32)); 上述语句比普通索引多了一个关键字INVISIBLE，用来标记索引为不可见索引。 2.在已经存在的表上创建 可以为已经存在的表设置隐藏索引，其语法形式如下： 1CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name ON table_name (col_name[length] [ASC | DESC] ,...) [INVISIBLE|VISIBLE] 3.通过ALTER TABLE语句创建 1ALTER TABLE book2 ADD index idx_name(book_name) INVISIBLE; 4.切换索引可见状态 已存在的索引可通过如下语句切换可见状态： 12ALTER TABLE book2 alter index idx_name visible; # 切换成非隐藏索引ALTER TABLE book2 alter index idx_name invisible; # 切换成非隐藏索引 如果将index_cname索引切换成可见状态，通过explain查看执行计划，发现优化器选择了idx_name索引。 注意 当索引被隐藏时，它的内容仍然是和正常索引一样实时更新的。如果一个索引需要长期被隐藏，那么可以将其删除，因为索引的存在会影响插入、更新和删除的性能。 通过设置隐藏索引的可见性可以查看索引对调优的帮助。 5.使隐藏索引对查询优化器可见 只是有个全局的地方设置可见性，没什么用 在MySQL 8.x版本中，为索引提供了一种新的测试方式，可以通过查询优化器的一个开关（use_invisible_indexes）来打开某个设置，使隐藏索引对查询优化器可见。如果 use_invisible_indexes设置为off(默认)，优化器会忽略隐藏索引。如果设置为on，即使隐藏索引不可见，优化器在生成执行计划时仍会考虑使用隐藏索引。 （ 1 ）在MySQL命令行执行如下命令查看查询优化器的开关设置。 1234mysql&gt; select @@optimizer_switch \\G*************************** 1. row ***************************@@optimizer_switch: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=off,skip_scan=on,hash_join=on,subquery_to_derived=off,prefer_ordering_index=on,hypergraph_optimizer=off,derived_condition_pushdown=on1 row in set (0.12 sec) 在输出的结果信息中找到如下属性配置。 1use_invisible_indexes=off 此属性配置值为off，说明隐藏索引默认对查询优化器不可见。 （ 2 ）使隐藏索引对查询优化器可见，需要在MySQL命令行执行如下命令： 12mysql&gt; set session optimizer_switch=&quot;use_invisible_indexes=on&quot; ;Query OK, 0 rows affected (0.06 sec) SQL语句执行成功，再次查看查询优化器的开关设置。 此时，在输出结果中可以看到如下属性配置。 1234mysql&gt; select @@optimizer_switch \\G*************************** 1. row ***************************@@optimizer_switch: index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,duplicateweedout=on,subquery_materialization_cost_based=on,use_index_extensions=on,condition_fanout_filter=on,derived_merge=on,use_invisible_indexes=on,skip_scan=on,hash_join=on,subquery_to_derived=off,prefer_ordering_index=on,hypergraph_optimizer=off,derived_condition_pushdown=on1 row in set (0.03 sec) use_invisible_indexes属性的值为on，说明此时隐藏索引对查询优化器可见。 3. 索引的设计原则3. 1 数据准备第 1 步：创建数据库、创建表 1234567891011121314151617181920CREATE DATABASE atguigudb1;USE atguigudb1;#1.创建学生表和课程表CREATE TABLE `student_info` (`id` INT( 11 ) NOT NULL AUTO_INCREMENT,`student_id` INT NOT NULL ,`name` VARCHAR( 20 ) DEFAULT NULL,`course_id` INT NOT NULL ,`class_id` INT( 11 ) DEFAULT NULL,`create_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT= 1 DEFAULT CHARSET=utf8;CREATE TABLE `course` (`id` INT( 11 ) NOT NULL AUTO_INCREMENT,`course_id` INT NOT NULL ,`course_name` VARCHAR( 40 ) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=INNODB AUTO_INCREMENT= 1 DEFAULT CHARSET=utf8; 第 2 步：创建模拟数据必需的存储函数 1234567891011121314151617#函数 1 ：创建随机产生字符串函数DELIMITER //CREATE FUNCTION rand_string(n INT) RETURNS VARCHAR( 255 ) #该函数会返回一个字符串BEGIN DECLARE chars_str VARCHAR( 100 ) DEFAULT&#x27;abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ&#x27;; DECLARE return_str VARCHAR( 255 ) DEFAULT &#x27;&#x27;; DECLARE i INT DEFAULT 0 ; WHILE i &lt; n DO SET return_str =CONCAT(return_str,SUBSTRING(chars_str,FLOOR( 1 +RAND()* 52 ), 1 )); SET i = i + 1 ; END WHILE; RETURN return_str;END //DELIMITER ; 123456789#函数 2 ：创建随机数函数DELIMITER //CREATE FUNCTION rand_num (from_num INT ,to_num INT) RETURNS INT( 11 )BEGINDECLARE i INT DEFAULT 0 ;SET i = FLOOR(from_num +RAND()*(to_num - from_num+ 1 )) ;RETURN i;END //DELIMITER ; 创建函数，假如报错： 1This function has none of DETERMINISTIC...... 由于开启过慢查询日志bin-log, 我们就必须为我们的function指定一个参数。 主从复制，主机会将写操作记录在bin-log日志中。从机读取bin-log日志，执行语句来同步数据。如果使用函数来操作数据，会导致从机和主键操作时间不一致。所以，默认情况下，mysql不开启创建函数设置。 查看mysql是否允许创建函数： 1show variables like &#x27;log_bin_trust_function_creators&#x27;; 命令开启：允许创建函数设置： 1set global log_bin_trust_function_creators= 1 ; # 不加global只是当前窗口有效。 mysqld重启，上述参数又会消失。永久方法： windows下：my.ini[mysqld]加上： 1log_bin_trust_function_creators= 1 linux下：&#x2F;etc&#x2F;my.cnf下my.cnf[mysqld]加上： 1log_bin_trust_function_creators= 1 第 3 步：创建插入模拟数据的存储过程 123456789101112131415#存储过程 1 ：创建插入课程表存储过程DELIMITER //CREATE PROCEDURE insert_course( max_num INT )BEGIN DECLARE i INT DEFAULT 0 ; SET autocommit = 0 ; #设置手动提交事务 REPEAT #循环 SET i = i + 1 ; #赋值 INSERT INTO course (course_id, course_name ) VALUES (rand_num( 10000 , 10100 ),rand_string( 6 )); UNTIL i = max_num END REPEAT; COMMIT; #提交事务END //DELIMITER ; 12345678910111213141516#存储过程 2 ：创建插入学生信息表存储过程DELIMITER //CREATE PROCEDURE insert_stu( max_num INT )BEGINDECLARE i INT DEFAULT 0 ; SET autocommit = 0 ; #设置手动提交事务 REPEAT #循环 SET i = i + 1 ; #赋值 INSERT INTO student_info (course_id, class_id ,student_id ,NAME ) VALUES (rand_num( 10000 , 10100 ),rand_num( 10000 , 10200 ),rand_num( 1 , 200000 ),rand_string( 6 )); UNTIL i = max_num END REPEAT; COMMIT; #提交事务END //DELIMITER ; 第 4 步：调用存储过程 12CALL insert_course( 100 );CALL insert_stu( 1000000 ); 3.2 哪些情况适合创建索引1.字段的数值有唯一性的限制 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。（来源：Alibaba） 说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。 2.频繁作为 WHERE 查询条件的字段某个字段在SELECT语句的 WHERE 条件中经常被使用到，那么就需要给这个字段创建索引了。尤其是在数据量大的情况下，创建普通索引就可以大幅提升数据查询的效率。 比如student_info数据表（含 100 万条数据），假设我们想要查询 student_id&#x3D;123110 的用户信息。 3.经常 GROUP BY 和 ORDER BY 的列索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 GROUP BY 对数据进行分组查询，或者使用 ORDER BY 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。如果待排序的列有多个，那么可以在这些列上建立组合索引。 4.UPDATE、DELETE 的 WHERE 条件列对数据按照某个条件进行查询后再进行 UPDATE 或 DELETE 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。 如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。 5.DISTINCT 字段需要创建索引有时候我们需要对某个字段进行去重，使用 DISTINCT，那么对这个字段创建索引，也会提升查询效率。 比如，我们想要查询课程表中不同的 student_id 都有哪些，如果我们没有对 student_id 创建索引，执行 SQL 语句： 1SELECT DISTINCT( student_id)FROM &#x27;student_info `; 运行结果（ 600637 条记录，运行时间 0.683s）： 12... 加索引语句SELECT DISTINCT( student_id)FROM &#x27;student_info `; 如果我们对 student_id 创建索引，再执行 SQL 语句： 运行结果（ 600637 条记录，运行时间 0.010s）： 你能看到 SQL 查询效率有了提升，同时显示出来的 student_id 还是按照递增的顺序进行展示的。这是因 为索引会对数据按照某种顺序进行排序，所以在去重的时候也会快很多。 因为紧挨着所以去重特别方便 6.多表 JOIN 连接操作时，创建索引注意事项首先，连接表的数量尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增 长会非常快，严重影响查询的效率。 其次，对 WHERE 条件创建索引，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下， 没有 WHERE 条件过滤是非常可怕的。 最后，对用于连接的字段创建索引，并且该字段在多张表中的类型必须一致。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。 举个例子，如果我们只对 student_id 创建索引，执行 SQL 语句： 1234SELECT course_id,name，student_info.student_id, course_nameFROM student_info JOIN courseON student_info .course_id = course.course_idWHERE name = &#x27;462eed7ac6e791292a79&#x27; ; 运行结果（ 1 条数据，运行时间 0.189s）： 这里我们对 name 创建索引，再执行上面的 SQL 语句，运行时间为 0.002s。 7.使用列的类型小的创建索引我们这里所说的类型大小指的就是该类型表示的数据范围的大小。 我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有TINYINT、MEDIUMINT、INT、BIGINT等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，尽量让索引列使用较小的类型，比如我们能使用INT就不要使用BIGINT，能使用MEDIUMINT 就不要使用INT。这是因为: 数据类型越小，在查询时进行的比较操作越快 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I&#x2F;0带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。 这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的I&#x2F;O。 8.使用字符串前缀创建索引假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的B+树中有这么两个问题: B+树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大。 如果B+树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。 我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了字符串的比较时间，还大体能解决排序的问题。 例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间，如果只检索字段前面的若干字符，这样可以提高检索速度。 创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引 123create table shop(address varchar( 120 ) not null);alter table shop add index(address( 12 )); 问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度(选择性)会降低。 怎么计算不同的长度的选择性呢？ 先看一下字段在全部数据中的选择度： 1select count(distinct address) / count(*) from shop; 通过不同长度去计算，与全表的选择性对比： 公式： 1count(distinct left(列名, 索引长度))/count(*) 例如： 12345select count(distinct left(address, 10 )) / count(*) as sub10, -- 截取前 10 个字符的选择度count(distinct left(address, 15 )) / count(*) as sub11, -- 截取前 15 个字符的选择度count(distinct left(address, 20 )) / count(*) as sub12, -- 截取前 20 个字符的选择度count(distinct left(address, 25 )) / count(*) as sub13 -- 截取前 25 个字符的选择度from shop; 引申另一个问题：索引列前缀对排序的影响 如果使用了索引列前缀，比方说前边只把address列的前12个字符放到了二级索引中，下边这个查询可能就有点儿尴尬了: 123SELECT * FROM shopORDER BY address # 这个地方order by 就不准了 如果用前12个建立索引的话LIMIT 12; 因为二级索引中不包含完整的address列信息，所以无法对前12个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只能使用文件排序。 拓展：Alibaba《Java开发手册》 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。 说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达90% 以上，可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。 9.区分度高(散列性高)的列适合作为索引列的基数指的是某一列中不重复数据的个数，比方说某个列包含值2，5，8，2，5，8，2，5，8，虽然有9条记录，但该列的基数却是3。也就是说，在记录行数一定的情况下，列的基数越大，该列中的值越分散;列的基数越小，该列中的值越集中。这个列的基数指标非常重要，直接影响我们是否能有效的利用索引。最好为列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。 可以使用公式 select count(distinct a)/count(*) from t1计算区分度，越接近1越好，一般超过33%就算是比较高效的索引了。 拓展:联合索引把区分度高(散列性高)的列放在前面。 10.使用最频繁的列放到联合索引的左侧这样也可以较少的建立一些索引。同时，由于”最左前缀原则”，可以增加联合索引的使用率。 11.在多个字段都要创建索引的情况下，联合索引优于单值索引3. 3 限制索引的数目在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过6个。原因: ① 每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。 ② 索引会影响INSERT、DELETE、UPDATE等语句的性能，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。 ③优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会增加MySQL优化器生成执行计划时间，降低查询性能。 3. 4 哪些情况不适合创建索引1. 在where中使用不到的字段，不要设置索引WHERE条件(包括GROUP BY、ORDER BY)里用不到的字段不需要创建索引，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的。举个例子: 123SELECT course_id,student_id, create_timeFROM student_infoWHERE student_id = 41251; 因为我们是按照student_id来进行检索的，所以不需要对其他字段创建索引，即使这些字段出现在SELECT 字段中。 2. 数据量小的表最好不要使用索引如果表记录太少，比如少于1000个，那么是不需要创建索引的。表记录太少，是否创建索引对查询效率的影响并不大。甚至说，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。 举例：创建表 1 ： 1234CREATE TABLE t_without_index(a INT PRIMARY KEY AUTO_INCREMENT,b INT); 提供存储过程 1 ： 1234567891011121314151617#创建存储过程DELIMITER //CREATE PROCEDURE t_wout_insert()BEGIN DECLARE i INT DEFAULT 1 ; WHILE i &lt;= 900 DO INSERT INTO t_without_index(b) SELECT RAND()* 10000 ; SET i = i + 1 ; END WHILE; COMMIT;END //DELIMITER ;#调用CALL t_wout_insert(); 创建表 2 ： 12345CREATE TABLE t_with_index(a INT PRIMARY KEY AUTO_INCREMENT,b INT,INDEX idx_b(b)); 创建存储过程 2 ： 12345678910111213141516#创建存储过程DELIMITER //CREATE PROCEDURE t_with_insert()BEGINDECLARE i INT DEFAULT 1 ;WHILE i &lt;= 900DOINSERT INTO t_with_index(b) SELECT RAND()* 10000 ;SET i = i + 1 ;END WHILE;COMMIT;END //DELIMITER ;#调用CALL t_with_insert(); 查询对比： 你能看到运行结果相同，但是在数据量不大的情况下，索引就发挥不出作用了。 123456789101112131415mysql&gt; select * from t_without_index where b = 9879 ;+------+------+| a | b |+------+------+| 1242 | 9879 |+------+------+1 row in set (0.00 sec)mysql&gt; select * from t_with_index where b = 9879 ;+-----+------+| a | b |+-----+------+| 112 | 9879 |+-----+------+1 row in set (0.00 sec) 结论：在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。 3. 有大量重复数据的列上不要建立索引在条件表达式中经常用到的不同值较多的列上建立索引，但字段中如果有大量重复数据，也不用创建索引。比如在学生表的”性别“字段上只有“男”与“·女”两个不同值，因此无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度。 举例 1 ：要在 100 万行数据中查找其中的 50 万行（比如性别为男的数据），一旦创建了索引，你需要先访问 50 万次索引，然后再访问 50 万次数据表，这样加起来的开销比不使用索引可能还要大。 举例 2 ：假设有一个学生表，学生总数为 100 万人，男性只有 10 个人，也就是占总人口的 10 万分之 1 。 学生表 student_gender 结构如下。其中数据表中的 student_gender 字段取值为 0 或 1 ， 0 代表女性， 1 代表男性。 123456CREATE TABLE student_gender(student_id INT( 11 ) NOT NULL,student_name VARCHAR( 50 ) NOT NULL,student_gender TINYINT( 1 ) NOT NULL,PRIMARY KEY(student_id))ENGINE = INNODB; 如果我们要筛选出这个学生表中的男性，可以使用： 1SELECT * FROM student_gender WHERE student_gender = 1 运行结果（ 10 条数据，运行时间 0.696s）： 你能看到在未创建索引的情况下，运行的效率并不高。如果针对 student_gender字段创建索引呢? 1SELECT * FROM student gender WHERE student_gender = 1 同样是10条数据，运行结果相同，时间却缩短到了0.052s，大幅提升了查询的效率。 其实通过这两个实验你也能看出来，索引的价值是帮你快速定位。如果想要定位的数据有很多，那么索引就失去了它的使用价值，比如通常情况下的性别字段。 在这个例子中，索引可以快速定位出男生是有用的。 4.避免对经常更新的表创建过多的索引第一层含义: 频繁更新的字段不一定要创建索引。因为更新数据的时候，也需要更新索引，如果索引太多，在更新索引的时候也会造成负担，从而影响效率。 第二层含义: 避免对经常更新的表创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会降低更新表的速度。 5.不建议用无序的值作为索引例如身份证、UUID(在索引比较时需要转为ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。 6.删除不再使用或者很少使用的索引表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。 7.不要定义冗余或重复的索引① 冗余索引 举例：建表语句如下 12345678910CREATE TABLE person_info( id INT UNSIGNED NOT NULL AUTO_INCREMENT, name VARCHAR( 100 ) NOT NULL, birthday DATE NOT NULL, phone_number CHAR( 11 ) NOT NULL, country varchar( 100 ) NOT NULL, PRIMARY KEY (id), KEY idx_name_birthday_phone_number (name( 10 ), birthday, phone_number), KEY idx_name (name( 10 ))); 我们知道，通过idx_name_birthday_phone_number索引就可以对name列进行快速搜索，再创建一个专门针对name列的索引就算是一个冗余索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。 ② 重复索引 另一种情况，我们可能会对某个列重复建立索引，比方说这样： 123456CREATE TABLE repeat_index_demo (col1 INT PRIMARY KEY,col2 INT,UNIQUE uk_idx_c1 (col1),INDEX idx_c1 (col1)); 我们看到，col 1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。 3.5小结索引是一把双刃剑，可提高查询效率，但也会降低插入和更新的速度并占用磁盘空间。 选择索引的最终目的是为了使查询的速度变快，上面给出的原则是最基本的准则，但不能拘泥于上面的准则，在以后的学习和工作中进行不断的实践，根据应用的实际情况进行分析和判断，选择最合适的索引方式。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://iexlee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"MySQL 索引的数据结构","slug":"12、InnoDB数据存储结构","date":"2022-08-02T01:00:00.000Z","updated":"2023-08-19T15:53:01.896Z","comments":true,"path":"12、InnoDB数据存储结构.html","link":"","permalink":"https://iexlee.github.io/12%E3%80%81InnoDB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.html","excerpt":"","text":"第07章_InnoDB数据存储结构1.数据库的存储结构:页 ​ 1.1磁盘与内存交互基本单位:页 ​ 1.2页结构概述 ​ 1.3页的大小 ​ 1.4页的上层结构 2.页的内部结构​ 第1部分:File Header(文件头部）和File Trailer (文件尾部) 1.数据库的存储结构:页索引结构给我们提供了高效的索引方式，不过索引信息以及数据记录都是保存在文件上的，确切说是存储在页结构中。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读取和写入工作。不同存储引擎中存放的格式一般是不同的，甚至有的存储引擎比如Memory都不用磁盘来存储数据。 由于InnoDB是MySQL的默认存储引擎，所以本章剖析InnoDB存储引擎的数据存储结构。 1.1磁盘与内存交互基本单位:页InnoDB将数据划分为若干个页，InnoDB中页的大小默认为 16KB 以页作为磁盘和内存之间交互的基本单位，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页(Page)，数据库I&#x2F;O操作的最小单位是页。一个页中可以存储多个行记录 记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I&#x2F;O操作)只能处理一行数据，效率会非常低。 1.2页结构概述页a、页b、页c …页n这些页可以不在物理结构上相连，只要通过双向链表相关联即可。每个数据页中的记录会按照主键值从小到大的顺序组成一个单向链表，每个数据页都会为存储在它里边的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。 1.3页的大小不同的数据库管理系统（简称DBMS）的页大小不同。比如在MySQL的InnoDB存储引擎中，默认页的大小是16KB，可以通过下面的命令来进行查看: 12345678show variables like &#x27;%innodb_page_size%&#x27;;/*+------------------+-------+| Variable_name | Value |+------------------+-------+| innodb_page_size | 16384 |+------------------+-------+*/ SQL Server中页的大小为 8KB，而在oracle中用术语’’块’’(Block)来代表”页”，Oralce支持的块大小为2KB，4KB，8KB，16K8，32KB和64KB。 1.4页的上层结构另外在数据库中，还存在区（Extent)、段(Segment)和表空间（Tablespace)的概念。行、页、区、段、表空间的关系如下图所示: 区(Extent)是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配64个连续的页。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB&#x3D; 1MB。 段(Segment)由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页)，不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。 当创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。 表空间（Tablespace)是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间，用户表空间、撤销表空间、临时表空间等。 2.页的内部结构页如果按类型划分的话，常见的有数据页（保存B+树节点）、系统页、Undo页和事务数据页等。数据页是我们最常使用的页。数据页的16KB大小的存储空间被划分为七个部分，分别是文件头(File Header)、页头(Page Header)、最大最小记录(Infimum+supremum)、用户记录(User Records)、空闲空间(Free Space)、页目录(Page Directory)和文件尾(File Tailer) 。 页结构的示意图如下所示: 这7个部分作用分别如下，简单梳理如下表所示: 名称 占用大小 说明 File Header 38字节 文件头，描述页的信息 Page Header 56字节 页头,页的状态信息 lnfimum-Supremum 26字节 最大和最小记录，这是两个虚拟的行记录 User Records 不确定 用户记录，存储行记录内容 Free Space 不确定 空闲记录，页中还没有被使用的空间 Page Directory 不确定 页目录，存储用户记录的相对位置 File Trailer 8字节 文件尾,校验页是否完整 我们可以把这7个结构分成3个部分 第1部分: File Header(文件头部）和File Trailer (文件尾部)首先是文件通用部分，也就是文件头和文件尾。 ① 文件头部信息 2.3 从数据页角度看B + 树如何查询一棵B+树按照节点类型可以分成两部分:1．叶子节点，B+树最底层的节点，节点的高度为o，存储行记录。2．非叶子节点，节点的高度大于0，存储索引键和页面指针，并不存储行记录本身。 当我们从页结构来理解B+树的结构的时候，可以帮我们理解一些通过索引进行检索的原理: 1.B+树是如何进行记录检索的? 如果通过B+树的索引查询行记录，首先是从B+树的根开始，逐层检索，直到找到叶子节点，也就是找到对应的数据页为止，将数据页加载到内存中，页目录中的槽(slot)采用二分查找的方式先找到一个粗略的记录分组然后再在分组中通过链表遍历的方式查找记录。 2.普通索引和唯一索引在查询效率上有什么不同? 我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢? 唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB存储引擎的页大小为16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次“判断下一条记录”的操作，对于CPU来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。 3.InnoDB行格式(或记录格式)我们平时的数据以行为单位来向表中插入数据，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。 InnoDB存储引擎设计了4种不同类型的行格式，分别是Compact（紧密）、Redundant（冗余）、Dynamic（动态）和Compressed（压缩）行格式。查看 MySQL8 与 MySQL5.7的默认行格式: 123456789101112131415161718192021222324252627282930mysql&gt; select @@innodb_default_row_format;+-----------------------------+| @@innodb_default_row_format |+-----------------------------+| dynamic |+-----------------------------+1 row in set (0.00 sec)# 查询单张表行格式mysql&gt; show table status like &#x27;departments&#x27; \\G*************************** 1. row *************************** Name: departments Engine: InnoDB Version: 10 #行格式 Row_format: Dynamic Rows: 27 Avg_row_length: 606 Data_length: 16384Max_data_length: 0 Index_length: 49152 Data_free: 0 Auto_increment: NULL Create_time: 2022-03-23 14:56:38 Update_time: 2022-03-23 14:56:38 Check_time: NULL Collation: utf8_general_ci Checksum: NULL Create_options: Comment:1 row in set (0.01 sec) 4.区、段与碎片区4.1为什么要有区?B+树的每一层中的页都会形成一个双向链表，如果是以页为单位来分配存储空间的话，双向链表相邻的两个页之间的物理位置可能离得非常远。我们介绍B+树索引的适用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录,然后沿着双向链表一直扫描就可以了，而如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机I/0。再一次强调，磁盘的速度和内存的速度差了好几个数量级，随机I/0是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序I/0。 这样利用了磁盘的预读特性 [查看4.n 扩展 理解mysql如何利用预读特性](#4.n 扩展) 引入区的概念，一个区就是在物理位置上连续的64个页。因为InnoDB 中的页大小默认是16KB，所以一个区的大小是64*16KB&#x3D;1MB。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区。虽然可能造成一点点空间的浪费（数据不足以填充满整个区)，但是从性能角度看，可以消除很多的随机I&#x2F;O，功大于过! 这里是连续的64个页， 但是具体的两个页之间还是用指针相连的。保证一大块区域连续。 4.2为什么要有段?对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区。存放叶子节点的区的集合就算是一个段( segment)，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段。 除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有数据段、索引段、回滚段。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。 在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。 段其实不对应表空间中某一个连续的物理区域，而是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。 零散的页面，看碎片区 4.3为什么要有碎片区?默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用1M (64*16Kb&#x3D;1024Kb）存储空间，所以默认情况下一个只存了几条记录的小表也需要2M的存储空间么?以后每次添加一个索引都要多申请2M的存储空间么?这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。 为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，InnoDB提出了一个碎片(fragment)区的概念。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页用于段A，有些页用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。 所以此后为某个段分配存储空间的策略是这样的: 在刚开始向表中插入数据的时候，段是从某个碎片区以单个页面为单位来分配存储空间的 当某个段已经占用了32个碎片区页面之后，就会申请以完整的区为单位来分配存储空间。 所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面以及一些完整的区的集合。 4.4区的分类区大体上可以分为4种类型: 空闲的区(FREE): 现在还没有用到这个区中的任何页面。 有剩余空间的碎片区(FREE_FRAG): 表示碎片区中还有可用的页面。 没有剩余空间的碎片区(FULL_FRAG)︰表示碎片区中的所有页面都被使用，没有空闲页面。 附属于某个段的区(FSEG):每一个索引都可以分为叶子节点段和非叶子节点段。 处于FREE、FREE_FRAG以及FULL_FRAG这三种状态的区都是独立的，直属于表空间。而处于FSEG状态的区是附属于某个段的。 如果把表空间比作是一个集团军，段就相当于师，区就相当于团。一般的团都是隶属于某个师的，就像是处于FSEG的区全都隶属于某个段，而处于FREE、FREE_FRAG以及FULL_FRAG这三种状态的区却直接隶属于表空间，就像独立团直接听命于军部一样。 4.n 扩展那么，计算机怎样才能判断一个数据接下来可能被用到？ 时间局部性（Temporal Locality） 时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。 &#x2F;&#x2F; 这是可以理解的，用过的数据当然可能再次被用到。 空间局部性（Spatial Locality） 空间局部性：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。 &#x2F;&#x2F; 正在使用的某个数据地址旁边的数据，当然也是很可能被用到的，比如某个数组、集合等等。 顺序局部性（Order Locality） 顺序局部性：在典型程序中，除转移类指令外，大部分指令是顺序进行的。顺序执行和非顺序执行的比例大致是5:1。此外，对大型数组访问也是顺序的。 指令的顺序执行、数组的连续存放等是产生顺序局部性的原因。 &#x2F;&#x2F; 正在执行的某个指令以及还在排队等候处理的指令，大部分是按照顺序来执行的。 磁盘预读原理 内存比磁盘的读写速度要快很多，但内存容量要远小于磁盘，而数据、程序的执行要调入内存后才能执行，所以内存和磁盘要经常进行I&#x2F;O操作，I&#x2F;O操作是个费事的过程，虽然现代系统已经有了通道（I&#x2F;O处理机）技术的支持，但这远远不够（CPU的处理速度远远大于磁盘I&#x2F;O的速度）。 所以磁盘读取的时候会顺带加载附近的数据到缓存 磁盘读取（详细） 磁盘存取，磁盘I&#x2F;O涉及机械操作。磁盘是由大小相同且同轴的圆形盘片组成，磁盘可以转动(各个磁盘须同时转动)。磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不动，磁盘转动，但磁臂可以前后动，用于读取不同磁道上的数据。磁道就是以盘片为中心划分出来的一系列同心环。磁道又划分为一个个小段，叫扇区，是磁盘的最小存储单元。 磁盘读取时，系统将数据逻辑地址传给磁盘，磁盘的控制电路会解析出物理地址（哪个磁道，哪个扇区），于是磁头需要前后移动到相应的磁道——寻道，消耗的时间叫——寻道时间，磁盘旋转将对应的扇区转到磁头下（磁头找到对应磁道的对应扇区），消耗的时间叫——旋转时间，这一系列操作是非常耗时。 重点为了尽量减少I&#x2F;O操作，计算机系统一般采取预读的方式，预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。 计算机系统是分页读取和存储的，一般一页为4KB（8个扇区，每个扇区125B，8125B&#x3D;4KB），每次读取和存取的最小单元为一页，而*磁盘预读时通常会读取页的整倍数**。根据文章上述的【局部性原理】①当一个数据被用到时，其附近的数据也通常会马上被使用。②程序运行期间所需要的数据通常比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），所以即使只需要读取一个字节，磁盘也会读取一页的数据。 至于磁盘分页，参考计算机操作系统的分页，分段存储管理——逻辑地址和物理地址被分为大小相同的页面，逻辑地址中叫页，物理地址中叫块。 为什么使用B-Tree&#x2F;B+Tree二叉查找树进化品种的红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-Tree&#x2F;B+Tree作为索引结构。 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I&#x2F;O消耗，相对于内存存取，I&#x2F;O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I&#x2F;O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O的存取次数。 分析B-Tree&#x2F;B+Tree检索一次最多需要访问节点： h&#x3D; 数据库系统巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧： 每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。 B-Tree中一次检索最多需要h-1次I&#x2F;O（根节点常驻内存），渐进复杂度为O（h）&#x3D;O（logmN）。一般实际应用中，m是非常大的数字，通常超过100，因此h非常小（通常不超过3）。 综上所述，用B-Tree作为索引结构效率是非常高的。 而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I&#x2F;O渐进复杂度也为O（h），效率明显比B-Tree差很多。 B树与B+Tree B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I&#x2F;O操作，完成这次检索操作，最多需要3次I&#x2F;O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I&#x2F;O操作就少了，检索效率也就上去了。 B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I&#x2F;O操作更少了。所以B+Tree拥有更好的性能。 5.表空间表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。 表空间是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。表空间数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间 (Systemtablespace)、独立表空间(File-per-table tablespace)、撤销表空间(Undo Tablespace)和临时表空间(Temporary Tablespace）等。 5.1独立表空间独立表空间，即每张表有一个独立的表空间，也就是数据和索引信息都会保存在自己的表空间中。独立的表空间(即:单表)可以在不同的数据库之间进行迁移。 空间可以回收(DROPTABLE操作可自动回收表空间;其他情况，表空间不能自己回收)。如果对于统计分析或是日志表，删除大量数据后可以通过: alter table TableName engine=innodb;回收不用的空间。对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。 独立表空间结构 独立表空间由段、区、页组成。前面已经讲解过了。 真实表空间对应的文件大小我们到数据目录里看，会发现一个新建的表对应的.ibd文件只占用了96K，才6个页面大小(MySQL5.7中)，这是因为一开始表空间占用的空间很小，因为表里边都没有数据。不过别忘了这些.ibd文件是自扩展的，随着表中数据的增多，表空间对应的文件也逐渐增大。 查看InnoDB的表空间类型: 12345678# 查看是否独立表空间mysql&gt; show variables like &#x27;innodb_file_per_table&#x27;;+-----------------------+-------+| Variable_name | Value |+-----------------------+-------+| innodb_file_per_table | ON |+-----------------------+-------+1 row in set, 1 warning (0.00 sec) MySQL8.0中 7个页面大小。原因.idb 还存了 表结构。。。表结构.frm取消了 5.2系统表空间系统表空间的结构和独立表空间基本类似，只不过由于整个MySQL进程只有一个系统表空间，在系统表空间中会额外记录一些有关整个系统信息的页面，这部分是独立表空间中没有的。 lnnoDB数据字典 每当我们向一个表中插入一条记录的时候，MySQL校验过程如下: 先要校验一下插入语句对应的表存不存在，插入的列和表中的列是否符合，如果语法没有问题的话，还需要知道该表的聚簇索引和所有二级索引对应的根页面是哪个表空间的哪个页面，然后把记录插入对应索引的B+树中。所以说，MySQL除了保存着我们插入的用户数据之外，还需要保存许多额外的信息，比方说: 123456-某个表属于哪个表空间，表里边有多少列-表对应的每一个列的类型是什么-该表有多少索引，每个索引对应哪几个字段，该索引对应的根页面在哪个表空间的哪个页面-该表有哪些外键，外键对应哪个表的哪些列-某个表空间对应文件系统上文件路径是什么- ... 上述这些数据并不是我们使用INSERT语句插入的用户数据，实际上是为了更好的管理我们这些用户数据而不得已引入的一些额外数据，这些数据也称为元数据。InnoDB存储引擎特意定义了一些列的内部系统表(internalsystem table)来记录这些这些元数据: 表名 描述 SYS_TABLES 整个InnoDB存储引擎中所有的表的信息 SYS_COLUMNS 整个InnoDB存储引擎中所有的列的信息 SYS_INDEXES 整个InnoDB存储引擎中所有的索引的信息 SYS_FIELDS 整个InnoDB存储引擎中所有的索引对应的列的信息 SYS_FOREIGN 整个InnoDB存储引擎中所有的外键的信息 SYS_FOREIGN_COLS 整个InnoDB存储引擎中所有的外键对应列的信息 SYS_TABLESPACES 整个InnoDB存储引擎中所有的表空间信息 SYS_DATAFILES 整个InnoDB存储引擎中所有的表空间对应文件系统的文件路 SYS_VIRTUAL 整个InnoDB存储引擎中所有的虚拟生成列的信息 这些系统表也被称为数据字典，它们都是以B+树的形式保存在系统表空间的某些页面中，其中SYS_TABLES.SYS_COLUNNS、SYS_INDEXES、SYS_FIELDS这四个表尤其重要，称之为基本系统表(basic system tables) 注意:用户是不能直接访问InnoDB的这些内部系统表，除非你直接去解析系统表空间对应文件系统上的文件。不过考虑到查看这些表的内容可能有助于大家分析问题，所以在系统数据库information_schema中提供了一些以innodb_sys开头的表: 123456789101112131415161718mysql&gt; USE information_schema ;Database changedmysql&gt; SHOW TABLES LIKE &#x27;innodb_sys%&#x27;;+--------------------------------------------+| Tables_in_information_schema (innodb_sys%) |+--------------------------------------------+| INNODB_SYS_DATAFILES || INNODB_SYS_VIRTUAL || INNODB_SYS_INDEXES || INNODB_SYS_TABLES || INNODB_SYS_FIELDS || INNODB_SYS_TABLESPACES || INNODB_SYS_FOREIGN_COLS || INNODB_SYS_COLUMNS || INNODB_SYS_FOREIGN || INNODB_SYS_TABLESTATS |+--------------------------------------------+10 rows in set (0.00 sec) 在information_schema数据库中的这些以INNODB_SYS开头的表并不是真正的内部系统表(内部系统表就是我们上边以SYS开头的那些表)，而是在存储引擎启动时读取这些以SYS开头的系统表，然后填充到这些以INNODB_SYS开头的表中。以INNODB_SYS开头的表和以SYS开头的表中的字段并不完全一样，但供大家参考已经足矣。 附录:数据页加载的三种方式InnoDB从磁盘中读取数据的最小单位是数据页。而你想得到的id &#x3D; xoxx的数据，就是这个数据页众多行中的一行。 对于MySQL存放的数据，逻辑概念上我们称之为表，在磁盘等物理层面而言是按数据页形式进行存放的，当其加载到MysQL中我们称之为缓存页。 如果缓冲池中没有该页数据，那么缓冲池有以下三种读取数据的方式,每种方式的读取效率都是不同的: 1.内存读取如果该数据存在于内存中，基本上执行时间在1ms左右，效率还是很高的。 2.随机读取如果数据没有在内存中，就需要在磁盘上对该页进行查找，整体时间预估在10ms左右，这10ms 中有6ms是磁盘的实际繁忙时间(包括了寻道和半圈旋转时间），有3ms是对可能发生的排队时间的估计值，另外还有1ms的传输时间，将页从磁盘服务器缓冲区传输到数据库缓冲区中。这10ms 看起来很快，但实际上对于数据库来说消耗的时间已经非常长了，因为这还只是一个页的读取时间。 3.顺序读取顺序读取其实是一种批量读取的方式，因为我们请求的数据在磁盘上往往都是相邻存储的，顺序读取可以帮我们批量读取页面，这样的话，一次性加载到缓冲池中就不需要再对其他页面单独进行磁盘I&#x2F;O操作了。如果一个磁盘的吞吐量是40MB&#x2F;S，那么对于一个16KB大小的页来说，一次可以顺序读取2560 (40MB&#x2F;16KB)个页，相当于一个页的读取时间为0.4ms。采用批量读取的方式，即使是从磁盘上进行读取，效率也比从内存中只单独读取一个页的效率要高。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://iexlee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"MySQL 索引的数据结构","slug":"11、MySQL索引及调优篇","date":"2022-07-26T01:00:00.000Z","updated":"2023-08-19T15:53:01.896Z","comments":true,"path":"11、MySQL索引及调优篇.html","link":"","permalink":"https://iexlee.github.io/11%E3%80%81MySQL%E7%B4%A2%E5%BC%95%E5%8F%8A%E8%B0%83%E4%BC%98%E7%AF%87.html","excerpt":"","text":"第06章_索引的数据结构1. 为什么使用索引索引是存储引擎用于快速找到数据记录的一种数据结构，就好比一本教科书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，符合则通过索引查找相关数据，如果不符合则需要全表扫描，即需要一条一条地查找记录，直到找到与条件符合的记录。 如上图所示，数据库没有索引的情况下，数据分布在硬盘不同的位置上面，读取数据时，摆臂需要前后摆动查询数据，这样操作非常消耗时间。如果数据顺序摆放，那么也需要从1到6行按顺序读取，这样就相当于进行了6次IO操作，依旧非常耗时。如果我们不借助任何索引结构帮助我们快速定位数据的话，我们查找 Col 2 &#x3D; 89 这条记录，就要逐行去查找、去比较。从Col 2 &#x3D; 34 开始，进行比较，发现不是，继续下一行。我们当前的表只有不到10行数据，但如果表很大的话，有上千万条数据，就意味着要做很多很多次硬盘I/0才能找到。现在要查找 Col 2 &#x3D; 89 这条记录。CPU必须先去磁盘查找这条记录，找到之后加载到内存，再对数据进行处理。这个过程最耗时间就是磁盘I&#x2F;O（涉及到磁盘的旋转时间（速度较快），磁头的寻道时间(速度慢、费时)） 假如给数据使用 二叉树 这样的数据结构进行存储，如下图所示 对字段 Col 2 添加了索引，就相当于在硬盘上为 Col 2 维护了一个索引的数据结构，即这个 二叉搜索树。二叉搜索树的每个结点存储的是 (K, V) 结构，key 是 Col 2，value 是该 key 所在行的文件指针（地址）。比如：该二叉搜索树的根节点就是：(34, 0x07)。现在对 Col 2 添加了索引，这时再去查找 Col 2 &#x3D; 89 这条记录的时候会先去查找该二叉搜索树（二叉树的遍历查找）。读 34 到内存，89 &gt; 34; 继续右侧数据，读 89 到内存，89&#x3D;&#x3D;89；找到数据返回。找到之后就根据当前结点的 value 快速定位到要查找的记录对应的地址。我们可以发现，只需要 查找两次 就可以定位到记录的地址，查询速度就提高了。 这就是我们为什么要建索引，目的就是为了 减少磁盘I/O的次数，加快查询速率。 2. 索引及其优缺点2.1 索引概述MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。 索引的本质：索引是数据结构。你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现 高级查找算法 。 索引是在存储引擎中实现的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。同时，存储引擎可以定义每个表的 最大索引数和 最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。 2.2 优点（1）类似大学图书馆建书目索引，提高数据检索的效率，降低 数据库的IO成本 ，这也是创建索引最主 要的原因。 （2）通过创建唯一索引，可以保证数据库表中每一行 数据的唯一性 。 （3）在实现数据的 参考完整性方面，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。 （4）在使用分组和排序子句进行数据查询时，可以显著 减少查询中分组和排序的时间 ，降低了CPU的消耗。 2.3 缺点增加索引也有许多不利的方面，主要表现在如下几个方面： （1）创建索引和维护索引要 耗费时间 ，并 且随着数据量的增加，所耗费的时间也会增加。 （2）索引需要占 磁盘空间 ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。 （3）虽然索引大大提高了查询速度，同时却会 降低更新表的速度 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。 因此，选择使用索引时，需要综合考虑索引的优点和缺点。 提示： 索引可以提高查询的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引。 3. InnoDB中索引的推演3.1 索引之前的查找先来看一个精确匹配的例子： 1SELECT [列名列表] FROM 表名 WHERE 列名 = xxx; 1. 在一个页中的查找假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况： 以主键为搜索条件 可以在页目录中使用 二分法 快速定位到对应的槽，然后再遍历该槽对用分组中的记录即可快速找到指定记录。 以其他列作为搜索条件 因为在数据页中并没有对非主键列简历所谓的页目录，所以我们无法通过二分法快速定位相应的槽。这种情况下只能从 最小记录 开始 依次遍历单链表中的每条记录， 然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。 2. 在很多页中查找在很多页中查找记录的活动可以分为两个步骤： 定位到记录所在的页。 从所在的页内中查找相应的记录。 在没有索引的情况下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以只能 从第一个页沿着双向链表 一直往下找，在每一个页中根据我们上面的查找方式去查 找指定的记录。因为要遍历所有的数据页，所以这种方式显然是 超级耗时 的。如果一个表有一亿条记录呢？此时 索引 应运而生。 3.2 设计索引建一个表： 123456mysql&gt; CREATE TABLE index_demo(-&gt; c1 INT,-&gt; c2 INT,-&gt; c3 CHAR(1),-&gt; PRIMARY KEY(c1)-&gt; ) ROW_FORMAT = Compact; 这个新建的 index_demo 表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们规定了c1列为主键， 这个表使用 Compact 行格式来实际存储记录的。这里我们简化了index_demo表的行格式示意图： 我们只在示意图里展示记录的这几个部分： record_type ：记录头信息的一项属性，表示记录的类型， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 1 暂时还没用过，下面讲。 mysql&gt; CREATE TABLE index_demo( -&gt; c1 INT, -&gt; c2 INT, -&gt; c3 CHAR(1), -&gt; PRIMARY KEY(c1) -&gt; ) ROW_FORMAT &#x3D; Compact; next_record ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来表明下一条记录是谁。 各个列的值 ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3 。 其他信息 ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息。 将记录格式示意图的其他信息项暂时去掉并把它竖起来的效果就是这样： 把一些记录放到页里的示意图就是： 1. 一个简单的索引设计方案我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。所以如果我们 想快速的定位到需要查找的记录在哪些数据页 中该咋办？我们可以为快速定位记录所在的数据页而建立一个目录 ，建这个目录必须完成下边这些事： 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。 假设：每个数据结构最多能存放3条记录（实际上一个数据页非常大，可以存放下好多记录）。 1INSERT INTO index_demo VALUES(1, 4, &#x27;u&#x27;), (3, 9, &#x27;d&#x27;), (5, 3, &#x27;y&#x27;); ​ 那么这些记录以及按照主键值的大小串联成一个单向链表了，如图所示： ​ 从图中可以看出来， index_demo 表中的3条记录都被插入到了编号为10的数据页中了。此时我们再来插入一条记录 1INSERT INTO index_demo VALUES(4, 4, &#x27;a&#x27;); 因为 页10 最多只能放3条记录，所以我们不得不再分配一个新页： 注意：新分配的 数据页编号可能并不是连续的。它们只是通过维护者上一个页和下一个页的编号而建立了 链表 关系。另外，页10中用户记录最大的主键值是5，而页28中有一条记录的主键值是4，因为5&gt;4，所以这就不符合下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求，所以在插入主键值为4的记录的时候需要伴随着一次 记录移动，也就是把主键值为5的记录移动到页28中，然后再把主键值为4的记录插入到页10中，这个过程的示意图如下： 这个过程表明了在对页中的记录进行增删改查操作的过程中，我们必须通过一些诸如 记录移动 的操作来始终保证这个状态一直成立：下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程称为 页分裂。 给所有的页建立一个目录项。 由于数据页的 编号可能是不连续 的，所以在向 index_demo 表中插入许多条记录后，可能是这样的效果： 我们需要给它们做个 目录，每个页对应一个目录项，每个目录项包括下边两个部分： 1）页的用户记录中最小的主键值，我们用 key 来表示。 2）页号，我们用 page_on 表示。 以 页28 为例，它对应 目录项2 ，这个目录项中包含着该页的页号 28 以及该页中用户记录的最小主 键值 5 。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了。比如：查找主键值为 20 的记录，具体查找过程分两步： 先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 &lt; 20 &lt; 209 ），它对应的页是 页9 。 再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录。 至此，针对数据页做的简易目录就搞定了。这个目录有一个别名，称为 索引 。 2. InnoDB中的索引方案① 迭代1次：目录项纪录的页InnoDB怎么区分一条记录是普通的 用户记录 还是 目录项记录 呢？使用记录头信息里的 record_type 属性，它的各自取值代表的意思如下： 0：普通的用户记录 1：目录项记录 2：最小记录 3：最大记录 我们把前边使用到的目录项放到数据页中的样子就是这样： 从图中可以看出来，我们新分配了一个编号为30的页来专门存储目录项记录。这里再次强调 目录项记录 和普通的 用户记录 的不同点： 目录项记录 的 record_type 值是1，而 普通用户记录 的 record_type 值是0。 目录项记录只有 主键值和页的编号 两个列，而普通的用户记录的列是用户自己定义的，可能包含 很多列 ，另外还有InnoDB自己添加的隐藏列。 了解：记录头信息里还有一个叫 min_rec_mask 的属性，只有在存储 目录项记录 的页中的主键值最小的 目录项记录 的 min_rec_mask 值为 1 ，其他别的记录的 min_rec_mask 值都是 0 。 相同点：两者用的是一样的数据页，都会为主键值生成 Page Directory （页目录），从而在按照主键值进行查找时可以使用 二分法 来加快查询速度。 现在以查找主键为 20 的记录为例，根据某个主键值去查找记录的步骤就可以大致拆分成下边两步： 先到存储 目录项记录 的页，也就是页30中通过 二分法 快速定位到对应目录项，因为 12 &lt; 20 &lt; 209 ，所以定位到对应的记录所在的页就是页9。 再到存储用户记录的页9中根据 二分法 快速定位到主键值为 20 的用户记录。 ② 迭代2次：多个目录项纪录的页 从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页： 为存储该用户记录而新生成了 页31 。 因为原先存储目录项记录的 页30的容量已满 （我们前边假设只能存储4条目录项记录），所以不得 不需要一个新的 页32 来存放 页31 对应的目录项。 现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步骤，以查找主键值为 20 的记录为例： 确定 目录项记录页 我们现在的存储目录项记录的页有两个，即 页30 和 页32 ，又因为页30表示的目录项的主键值的 范围是 [1, 320) ，页32表示的目录项的主键值不小于 320 ，所以主键值为 20 的记录对应的目 录项记录在 页30 中。 通过目录项记录页 确定用户记录真实所在的页 。 在一个存储 目录项记录 的页中通过主键值定位一条目录项记录的方式说过了。 在真实存储用户记录的页中定位到具体的记录。 ③ 迭代3次：目录项记录页的目录页如果我们表中的数据非常多则会产生很多存储目录项记录的页，那我们怎么根据主键值快速定位一个存储目录项记录的页呢？那就为这些存储目录项记录的页再生成一个更高级的目录，就像是一个多级目录一样，大目录里嵌套小目录，小目录里才是实际的数据，所以现在各个页的示意图就是这样子： 如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 [1, 320) 之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。 我们可以用下边这个图来描述它： 这个数据结构，它的名称是 B+树 。 ④ B+Tree一个B+树的节点其实可以分成好多层，规定最下边的那层，也就是存放我们用户记录的那层为第 0 层， 之后依次往上加。之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。其实真实环境中一个页存放的记录数量是非常大的，假设所有存放用户记录 的叶子节点代表的数据页可以存放 100条用户记录 ，所有存放目录项记录的内节点代表的数据页可以存 放 1000条目录项记录 ，那么： 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 100 条记录。 如果B+树有2层，最多能存放 1000×100&#x3D;10,0000 条记录。 如果B+树有3层，最多能存放 1000×1000×100&#x3D;1,0000,0000 条记录。 如果B+树有4层，最多能存放 1000×1000×1000×100&#x3D;1000,0000,0000 条记录。相当多的记录！ 你的表里能存放 100000000000 条记录吗？所以一般情况下，我们用到的 B+树都不会超过4层 ，那我们通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页），又因为在每个页面内有所谓的 Page Directory （页目录），所以在页面内也可以通过 二分法 实现快速 定位记录。 3.3 常见索引概念索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。 1. 聚簇索引聚簇索引并不是一种单独的索引类型，而是一种数据存储方式（所有的用户记录都存储在了叶子结点），也就是所谓的 索引即数据，数据即索引。 术语”聚簇”表示当前数据行和相邻的键值聚簇的存储在一起 特点： 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义： 页内 的记录是按照主键的大小顺序排成一个 单向链表 。 各个存放 用户记录的页 也是根据页中用户记录的主键大小顺序排成一个 双向链表 。 存放 目录项记录的页 分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个 双向链表 。 B+树的 叶子节点 存储的是完整的用户记录。 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。 我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要我们在MySQL语句中显式的使用INDEX 语句去创建， InnDB 存储引擎会 自动 的为我们创建聚簇索引。 优点： 数据访问更快 ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快 聚簇索引对于主键的 排序查找 和 范围查找 速度非常快 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 节省了大量的io操作 。 缺点： 插入速度严重依赖于插入顺序 ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键 更新主键的代价很高 ，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新 二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据 2. 二级索引（辅助索引、非聚簇索引）如果我们想以别的列作为搜索条件该怎么办？肯定不能是从头到尾沿着链表依次遍历记录一遍。 答案：我们可以多建几颗B+树，不同的B+树中的数据采用不同的排列规则。比方说我们用c2列的大小作为数据页、页中记录的排序规则，再建一课B+树，效果如下图所示： 这个B+树与上边介绍的聚簇索引有几处不同： **概念：回表 ** 我们根据这个以c2列大小排序的B+树只能确定我们要查找记录的主键值，所以如果我们想根 据c2列的值查找到完整的用户记录的话，仍然需要到 聚簇索引 中再查一遍，这个过程称为 回表 。也就 是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！ 问题：为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？ 回答： 如果把完整的用户记录放到叶子结点是可以不用回表。但是太占地方了，相当于每建立一课B+树都需要把所有的用户记录再都拷贝一遍，这就有点太浪费存储空间了。 因为这种按照非主键列建立的B+树需要一次回表操作才可以定位到完整的用户记录，所以这种B+树也被称为二级索引，或者辅助索引。由于使用的是c2列的大小作为B+树的排序规则，所以我们也称这个B+树为c2列简历的索引。 非聚簇索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个非聚簇索引。 小结：聚簇索引与非聚簇索引的原理不同，在使用上也有一些区别： 聚簇索引的叶子节点存储的就是我们的数据记录, 非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。 一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索引目录提供数据检索。 使用聚簇索引的时候，数据的查询效率高，但如果对数据进行插入，删除，更新等操作，效率会比非聚簇索引低。 3.联合索引我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按 照 c2和c3列 的大小进行排序，这个包含两层含义： 先把各个记录和页按照c2列进行排序。 在记录的c2列相同的情况下，采用c3列进行排序 为c2和c3建立的索引的示意图如下： 如图所示，我们需要注意以下几点： 每条目录项都有c2、c3、页号这三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序 B+树叶子节点处的用户记录由c2、c3和主键c1列组成 注意一点，以c2和c3列的大小为排序规则建立的B+树称为 联合索引 ，本质上也是一个二级索引。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下： 建立 联合索引 只会建立如上图一样的1棵B+树。 为c2和c3列分别建立索引会分别以c2和c3列的大小为排序规则建立2棵B+树。 3.4 InnoDB的B+树索引的注意事项1. 根页面位置万年不动实际上B+树的形成过程是这样的： 每当为某个表创建一个B+树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个 根结点 页面。最开始表中没有数据的时候，每个B+树索引对应的 根结点 中即没有用户记录，也没有目录项记录。 随后向表中插入用户记录时，先把用户记录存储到这个根节点 中。 当根节点中的可用 空间用完时 继续插入记录，此时会将根节点中的所有记录复制到一个新分配的页，比如 页a 中，然后对这个新页进行 页分裂 的操作，得到另一个新页，比如页b 。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到 页a 或者 页b 中，而 根节点 便升级为存储目录项记录的页。 这个过程特别注意的是：一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建议一个索引，那么它的根节点的页号便会被记录到某个地方。然后凡是 InnoDB 存储引擎需要用到这个索引的时候，都会从哪个固定的地方取出根节点的页号，从而来访问这个索引。 2. 内节点中目录项记录的唯一性我们知道B+树索引的内节点中目录项记录的内容是 索引列 + 页号 的搭配，但是这个搭配对于二级索引来说有点不严谨。还拿 index_demo 表为例，假设这个表中的数据是这样的： 如果二级索引中目录项记录的内容只是 索引列 + 页号 的搭配的话，那么为 c2 列简历索引后的B+树应该长这样： 如果我们想新插入一行记录，其中 c1 、c2 、c3 的值分别是: 9、1、c, 那么在修改这个为 c2 列建立的二级索引对应的 B+ 树时便碰到了个大问题：由于 页3 中存储的目录项记录是由 c2列 + 页号 的值构成的，页3 中的两条目录项记录对应的 c2 列的值都是1，而我们 新插入的这条记录 的 c2 列的值也是 1，那我们这条新插入的记录到底应该放在 页4 中，还是应该放在 页5 中？答案：对不起，懵了 为了让新插入记录找到自己在那个页面，我们需要保证在B+树的同一层页节点的目录项记录除页号这个字段以外是唯一的。所以对于二级索引的内节点的目录项记录的内容实际上是由三个部分构成的： 索引列的值 主键值 页号 也就是我们把主键值也添加到二级索引内节点中的目录项记录，这样就能保住 B+ 树每一层节点中各条目录项记录除页号这个字段外是唯一的，所以我们为c2建立二级索引后的示意图实际上应该是这样子的： 这样我们再插入记录(9, 1, &#39;c&#39;) 时，由于 页3 中存储的目录项记录是由 c2列 + 主键 + 页号 的值构成的，可以先把新纪录的 c2 列的值和 页3 中各目录项记录的 c2 列的值作比较，如果 c2 列的值相同的话，可以接着比较主键值，因为B+树同一层中不同目录项记录的 c2列 + 主键的值肯定是不一样的，所以最后肯定能定位唯一的一条目录项记录，在本例中最后确定新纪录应该被插入到 页5 中。 3. 一个页面最少存储 2 条记录一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。那如果一个大的目录中只存放一个子目录是个啥效果呢？那就是目录层级非常非常多，而且最后的那个存放真实数据的目录中只存放一条数据。所以 InnoDB 的一个数据页至少可以存放两条记录。 4. MyISAM中的索引方案B树索引使用存储引擎如表所示： 索引 &#x2F; 存储引擎 MyISAM InnoDB Memory B-Tree索引 支持 支持 支持 即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。Innodb和MyISAM默认的索 引是Btree索引；而Memory默认的索引是Hash索引。 MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址 。 4.1 MyISAM索引的原理 4.2 MyISAM 与 InnoDB对比MyISAM的索引方式都是“非聚簇”的，与InnoDB包含1个聚簇索引是不同的。小结两种引擎中索引的区别： ① 在InnoDB存储引擎中，我们只需要根据主键值对 聚簇索引 进行一次查找就能找到对应的记录，而在 MyISAM 中却需要进行一次 回表 操作，意味着MyISAM中建立的索引相当于全部都是 二级索引 。 ② InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 分离的 ，索引文件仅保存数 据记录的地址。 ③ InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域。 ④ MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。 ⑤ InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型。 小结： 5. 索引的代价索引是个好东西，可不能乱建，它在空间和时间上都会有消耗： 空间上的代价 每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间。 时间上的代价 每次对表中的数据进行 增、删、改 操作时，都需要去修改各个B+树索引。而且我们讲过，B+树每 层节点都是按照索引列的值 从小到大的顺序排序 而组成了 双向链表 。不论是叶子节点中的记录，还 是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序 而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需 要额外的时间进行一些 记录移位 ， 页面分裂 、 页面回收 等操作来维护好节点和记录的排序。如果 我们建了许多索引，每个索引对应的B+树都要进行相关的维护操作，会给性能拖后腿。 一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们得学学这些索引在哪些条件下起作用的。 6. MySQL数据结构选择的合理性 6.1 全表查询这里都懒得说了。 6.2 Hash查询 加快查找速度的数据结构，常见的有两类： (1) 树，例如平衡二叉搜索树，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 O(log2N); (2)哈希，例如HashMap，查询&#x2F;插入&#x2F;修改&#x2F;删除的平均时间复杂度都是 O(1); (key, value) 上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链 接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示： 实验：体会数组和hash表的查找方面的效率区别 12345678910111213141516171819// 算法复杂度为 O(n)@Testpublic void test1()&#123; int[] arr = new int[100000]; for(int i = 0;i &lt; arr.length;i++)&#123; arr[i] = i + 1; &#125; long start = System.currentTimeMillis(); for(int j = 1; j&lt;=100000;j++)&#123; int temp = j; for(int i = 0;i &lt; arr.length;i++)&#123; if(temp == arr[i])&#123; break; &#125; &#125; &#125; long end = System.currentTimeMillis(); System.out.println(&quot;time： &quot; + (end - start)); //time： 823&#125; 123456789101112131415// 算法复杂度为 O(1)@Testpublic void test2()&#123; HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(100000); for(int i = 0;i &lt; 100000;i++)&#123; set.add(i + 1); &#125; long start = System.currentTimeMillis(); for(int j = 1; j&lt;=100000;j++) &#123; int temp = j; boolean contains = set.contains(temp); &#125; long end = System.currentTimeMillis(); System.out.println(&quot;time： &quot; + (end - start)); //time： 5&#125; Hash结构效率高，那为什么索引结构要设计成树型呢？ Hash索引适用存储引擎如表所示： 索引 &#x2F; 存储引擎 MyISAM InnoDB Memory HASH索引 不支持 不支持 支持 Hash索引的适用性： 采用自适应 Hash 索引目的是方便根据 SQL 的查询条件加速定位到叶子节点，特别是当 B+ 树比较深的时 候，通过自适应 Hash 索引可以明显提高数据的检索效率。 我们可以通过 innodb_adaptive_hash_index 变量来查看是否开启了自适应 Hash，比如： 1mysql&gt; show variables like &#x27;%adaptive_hash_index&#x27;; 6.3 二叉搜索树如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的。 1. 二叉搜索树的特点 一个节点只能有两个子节点，也就是一个节点度不能超过2 左子节点 &lt; 本节点; 右子节点 &gt;&#x3D; 本节点，比我大的向右，比我小的向左 2. 查找规则 但是特殊情况，就是有时候二叉树的深度非常大，比如： 为了提高查询效率，就需要 减少磁盘IO数 。为了减少磁盘IO的次数，就需要尽量 降低树的高度 ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。 6.4 AVL树 &#96;每访问一次节点就需要进行一次磁盘 I&#x2F;O 操作，对于上面的树来说，我们需要进行 5次 I&#x2F;O 操作。虽然平衡二叉树的效率高，但是树的深度也同样高，这就意味着磁盘 I&#x2F;O 操作次数多，会影响整体数据查询的效率。 针对同样的数据，如果我们把二叉树改成 M 叉树 （M&gt;2）呢？当 M&#x3D;3 时，同样的 31 个节点可以由下面 的三叉树来进行存储： 你能看到此时树的高度降低了，当数据量 N 大的时候，以及树的分叉树 M 大的时候，M叉树的高度会远小于二叉树的高度 (M &gt; 2)。所以，我们需要把 &#96;树从“瘦高” 变 “矮胖”。 6.5 B-TreeB 树的英文是 Balance Tree，也就是 多路平衡查找树。简写为 B-Tree。它的高度远小于平衡二叉树的高度。 B 树的结构如下图所示： 一个 M 阶的 B 树（M&gt;2）有以下的特性： 根节点的儿子数的范围是 [2,M]。 每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 &#x3D; 关键字的数量 +1，k 的取值范围为 [ceil(M&#x2F;2), M]。 叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为 [ceil(M&#x2F;2), M]。 假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i]&lt;Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树。 所有叶子节点位于同一层。 上面那张图所表示的 B 树就是一棵 3 阶的 B 树。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。 然后我们来看下如何用 B 树进行查找。假设我们想要 查找的关键字是 9 ，那么步骤可以分为以下几步： 我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； 按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； 按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。 你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I&#x2F;O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。 B 树相比于平衡二叉树来说磁盘 I&#x2F;O 操作要少 ， 在数据查询中比平衡二叉树效率要高。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能 。 再举例1： 6.6 B+Tree MySQL官网说明： B+ 树和 B 树的差异在于以下几点： 有 k 个孩子的节点就有 k 个关键字。也就是孩子数量 &#x3D; 关键字数，而 B 树中，孩子数量 &#x3D; 关键字数 +1。 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最 小）。 非叶子节点仅用于索引，不保存数据记录，跟记录有关的信息都放在叶子节点中。而 B 树中， 非 叶子节点既保存索引，也保存数据记录 。 所有关键字都在叶子节点出现，叶子节点构成一个有序链表，而且叶子节点本身按照关键字的大 小从小到大顺序链接。 B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然。 思考题：为了减少IO，索引树会一次性加载吗？ 思考题：B+树的存储能力如何？为何说一般查找行记录，最多只需1~3次磁盘IO 思考题：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？ 思考题：Hash 索引与 B+ 树索引的区别 思考题：Hash 索引与 B+ 树索引是在建索引的时候手动指定的吗？ 6.7 R树R-Tree在MySQL很少使用，仅支持 geometry数据类型 ，支持该类型的存储引擎只有myisam、bdb、 innodb、ndb、archive几种。举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果 没有R树你会怎么解决？一般情况下我们会把餐厅的坐标(x,y)分为两个字段存放在数据库中，一个字段记 录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满 足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度 地图这种超大数据库中，这种方法便必定不可行了。R树就很好的 解决了这种高维空间搜索问题 。它把B 树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解 结点的方法，保证树的平衡性。因此，R树就是一棵用来 存储高维数据的平衡树 。相对于B-Tree，R-Tree 的优势在于范围查找。 索引 &#x2F; 存储引擎 MyISAM InnoDB Memory R-Tree索引 支持 支持 不支持 6.8 小结 附录：算法的时间复杂度同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://iexlee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[]},{"title":"类加载器","slug":"36-2、类加载器","date":"2022-07-17T01:00:00.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"36-2、类加载器.html","link":"","permalink":"https://iexlee.github.io/36-2%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html","excerpt":"","text":"写在前面的话： 基础加强包含了： 反射，动态代理，类加载器，xml，注解，日志，单元测试等知识点 其中最难的是反射和动态代理，其他知识点都非常简单 由于B站P数限制，xml，注解等知识点，阿玮写了详细文档供大家学习 1.类加载器1.1类加载器 作用 负责将.class文件（存储的物理文件）加载在到内存中 1.2类加载的完整过程 类加载时机 简单理解：字节码文件什么时候会被加载到内存中？ 有以下的几种情况： 创建类的实例（对象） 调用类的类方法 访问类或者接口的类变量，或者为该类变量赋值 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java.exe命令来运行某个主类 总结而言：用到了就加载，不用不加载 类加载过程 加载 通过包名 + 类名，获取这个类，准备用流进行传输 在这个类加载到内存中 加载完毕创建一个class对象 链接 验证 确保Class文件字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全 (文件中的信息是否符合虚拟机规范有没有安全隐患) 准备 负责为类的类变量（被static修饰的变量）分配内存，并设置默认初始化值 (初始化静态变量) 解析 将类的二进制数据流中的符号引用替换为直接引用 (本类中如果用到了其他类，此时就需要找到对应的类) 初始化 根据程序员通过程序制定的主观计划去初始化类变量和其他资源 (静态变量赋值以及初始化其他资源) 小结 当一个类被使用的时候，才会加载到内存 类加载的过程: 加载、验证、准备、解析、初始化 1.3类加载的分类【理解】 分类 Bootstrap class loader：虚拟机的内置类加载器，通常表示为null ，并且没有父null Platform class loader：平台类加载器,负责加载JDK中一些特殊的模块 System class loader：系统类加载器,负责加载用户类路径上所指定的类库 类加载器的继承关系 System的父加载器为Platform Platform的父加载器为Bootstrap 代码演示 1234567891011121314151617public class ClassLoaderDemo1 &#123; public static void main(String[] args) &#123; //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); //获取系统类加载器的父加载器 --- 平台类加载器 ClassLoader classLoader1 = systemClassLoader.getParent(); //获取平台类加载器的父加载器 --- 启动类加载器 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(&quot;系统类加载器&quot; + systemClassLoader); System.out.println(&quot;平台类加载器&quot; + classLoader1); System.out.println(&quot;启动类加载器&quot; + classLoader2); &#125;&#125; 1.4双亲委派模型【理解】 介绍 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式 1.5ClassLoader 中的两个方法【应用】 方法介绍 方法名 说明 public static ClassLoader getSystemClassLoader() 获取系统类加载器 public InputStream getResourceAsStream(String name) 加载某一个资源文件 示例代码 123456789101112131415161718192021public class ClassLoaderDemo2 &#123; public static void main(String[] args) throws IOException &#123; //static ClassLoader getSystemClassLoader() 获取系统类加载器 //InputStream getResourceAsStream(String name) 加载某一个资源文件 //获取系统类加载器 ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader(); //利用加载器去加载一个指定的文件 //参数：文件的路径（放在src的根目录下，默认去那里加载） //返回值：字节流。 InputStream is = systemClassLoader.getResourceAsStream(&quot;prop.properties&quot;); Properties prop = new Properties(); prop.load(is); System.out.println(prop); is.close(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"log日志","slug":"36-1、log日志","date":"2022-07-10T01:00:00.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"36-1、log日志.html","link":"","permalink":"https://iexlee.github.io/36-1%E3%80%81log%E6%97%A5%E5%BF%97.html","excerpt":"","text":"日志1.1 作用：​ 跟输出语句一样，可以把程序在运行过程中的详细信息都打印在控制台上。 ​ 利用log日志还可以把这些详细信息保存到文件和数据库中。 1.2 使用步骤：​ 不是java的，也不是自己写的，是第三方提供的代码，所以我们要导入jar包。 把第三方的代码导入到当前的项目当中 新建lib文件夹，把jar粘贴到lib文件夹当中，全选后右键点击选择add as a …. 检测导入成功：导入成功后jar包可以展开。在项目重构界面可以看到导入的内容 把配置文件粘贴到src文件夹下 在代码中获取日志对象 调用方法打印日志 1.3 日志级别1TRACE, DEBUG, INFO, WARN, ERROR 还有两个特殊的： ​ ALL：输出所有日志 ​ OFF：关闭所有日志 日志级别从小到大的关系： ​ TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR 1.4 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration&gt; &lt;!-- CONSOLE ：表示当前的日志信息是可以输出到控制台的。 --&gt; &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;!--输出流对象 默认 System.out 改为 System.err--&gt; &lt;target&gt;System.out&lt;/target&gt; &lt;encoder&gt; &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%-5level] %c [%thread] : %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- File是输出的方向通向文件的 --&gt; &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;charset&gt;utf-8&lt;/charset&gt; &lt;/encoder&gt; &lt;!--日志输出路径--&gt; &lt;file&gt;C:/code/itheima-data.log&lt;/file&gt; &lt;!--指定日志文件拆分和压缩规则--&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;&gt; &lt;!--通过指定压缩文件名称，来确定分割文件方式--&gt; &lt;fileNamePattern&gt;C:/code/itheima-data2-%d&#123;yyyy-MMdd&#125;.log%i.gz&lt;/fileNamePattern&gt; &lt;!--文件拆分大小--&gt; &lt;maxFileSize&gt;1MB&lt;/maxFileSize&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!-- level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF ， 默认debug &lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个输出位置将会被本日志级别控制。 --&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;CONSOLE&quot;/&gt; &lt;appender-ref ref=&quot;FILE&quot; /&gt; &lt;/root&gt;&lt;/configuration&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"反射&动态代理","slug":"35、反射-动态代理","date":"2022-07-01T01:00:00.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"35、反射-动态代理.html","link":"","permalink":"https://iexlee.github.io/35%E3%80%81%E5%8F%8D%E5%B0%84-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.html","excerpt":"","text":"1. 反射1.1 反射的概述：​ 专业的解释（了解一下）： ​ 是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法； ​ 对于任意一个对象，都能够调用它的任意属性和方法； ​ 这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。 ​ 通俗的理解：（掌握） 利用反射创建的对象可以无视修饰符调用类里面的内容 可以跟配置文件结合起来使用，把要创建的对象信息和方法写在配置文件中。 读取到什么类，就创建什么类的对象 读取到什么方法，就调用什么方法 此时当需求变更的时候不需要修改代码，只要修改配置文件即可。 1.2 学习反射到底学什么？反射都是从class字节码文件中获取的内容。 如何获取class字节码文件的对象 利用反射如何获取构造方法（创建对象） 利用反射如何获取成员变量（赋值，获取值） 利用反射如何获取成员方法（运行） 1.3 获取字节码文件对象的三种方式 Class这个类里面的静态方法forName（“全类名”）（最常用） 通过class属性获取 通过对象获取字节码文件对象 代码示例： 123456789101112131415161718192021//1.Class这个类里面的静态方法forName//Class.forName(&quot;类的全类名&quot;)： 全类名 = 包名 + 类名Class clazz1 = Class.forName(&quot;com.itheima.reflectdemo.Student&quot;);//源代码阶段获取 --- 先把Student加载到内存中，再获取字节码文件的对象//clazz 就表示Student这个类的字节码文件对象。//就是当Student.class这个文件加载到内存之后，产生的字节码文件对象//2.通过class属性获取//类名.classClass clazz2 = Student.class;//因为class文件在硬盘中是唯一的，所以，当这个文件加载到内存之后产生的对象也是唯一的System.out.println(clazz1 == clazz2);//true//3.通过Student对象获取字节码文件对象Student s = new Student();Class clazz3 = s.getClass();System.out.println(clazz1 == clazz2);//trueSystem.out.println(clazz2 == clazz3);//true 1.4 字节码文件和字节码文件对象java文件：就是我们自己编写的java代码。 字节码文件：就是通过java文件编译之后的class文件（是在硬盘上真实存在的，用眼睛能看到的） 字节码文件对象：当class文件加载到内存之后，虚拟机自动创建出来的对象。 ​ 这个对象里面至少包含了：构造方法，成员变量，成员方法。 而我们的反射获取的是什么？字节码文件对象，这个对象在内存中是唯一的。 1.5 获取构造方法规则： ​ get表示获取 ​ Declared表示私有 ​ 最后的s表示所有，复数形式 ​ 如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用 方法名 说明 Constructor&lt;?&gt;[] getConstructors() 获得所有的构造（只能public修饰） Constructor&lt;?&gt;[] getDeclaredConstructors() 获得所有的构造（包含private修饰） Constructor getConstructor(Class&lt;?&gt;… parameterTypes) 获取指定构造（只能public修饰） Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 获取指定构造（包含private修饰） 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041public class ReflectDemo2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; //1.获得整体（class字节码文件对象） Class clazz = Class.forName(&quot;com.itheima.reflectdemo.Student&quot;); //2.获取构造方法对象 //获取所有构造方法（public） Constructor[] constructors1 = clazz.getConstructors(); for (Constructor constructor : constructors1) &#123; System.out.println(constructor); &#125; System.out.println(&quot;=======================&quot;); //获取所有构造（带私有的） Constructor[] constructors2 = clazz.getDeclaredConstructors(); for (Constructor constructor : constructors2) &#123; System.out.println(constructor); &#125; System.out.println(&quot;=======================&quot;); //获取指定的空参构造 Constructor con1 = clazz.getConstructor(); System.out.println(con1); Constructor con2 = clazz.getConstructor(String.class,int.class); System.out.println(con2); System.out.println(&quot;=======================&quot;); //获取指定的构造(所有构造都可以获取到，包括public包括private) Constructor con3 = clazz.getDeclaredConstructor(); System.out.println(con3); //了解 System.out.println(con3 == con1); //每一次获取构造方法对象的时候，都会新new一个。 Constructor con4 = clazz.getDeclaredConstructor(String.class); System.out.println(con4); &#125;&#125; 1.6 获取构造方法并创建对象涉及到的方法：newInstance 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//首先要有一个javabean类public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name) &#123; this.name = name; &#125; private Student(String name, int age) &#123; this.name = name; this.age = age; &#125; /** * 获取 * @return name */ public String getName() &#123; return name; &#125; /** * 设置 * @param name */ public void setName(String name) &#123; this.name = name; &#125; /** * 获取 * @return age */ public int getAge() &#123; return age; &#125; /** * 设置 * @param age */ public void setAge(int age) &#123; this.age = age; &#125; public String toString() &#123; return &quot;Student&#123;name = &quot; + name + &quot;, age = &quot; + age + &quot;&#125;&quot;; &#125;&#125;//测试类中的代码：//需求1：//获取空参，并创建对象//1.获取整体的字节码文件对象Class clazz = Class.forName(&quot;com.itheima.a02reflectdemo1.Student&quot;);//2.获取空参的构造方法Constructor con = clazz.getConstructor();//3.利用空参构造方法创建对象Student stu = (Student) con.newInstance();System.out.println(stu);System.out.println(&quot;=============================================&quot;);//测试类中的代码：//需求2：//获取带参构造，并创建对象//1.获取整体的字节码文件对象Class clazz = Class.forName(&quot;com.itheima.a02reflectdemo1.Student&quot;);//2.获取有参构造方法Constructor con = clazz.getDeclaredConstructor(String.class, int.class);//3.临时修改构造方法的访问权限（暴力反射）con.setAccessible(true);//4.直接创建对象Student stu = (Student) con.newInstance(&quot;zhangsan&quot;, 23);System.out.println(stu); 1.7 获取成员变量规则： ​ get表示获取 ​ Declared表示私有 ​ 最后的s表示所有，复数形式 ​ 如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用 方法名： 方法名 说明 Field[] getFields() 返回所有成员变量对象的数组（只能拿public的） Field[] getDeclaredFields() 返回所有成员变量对象的数组，存在就能拿到 Field getField(String name) 返回单个成员变量对象（只能拿public的） Field getDeclaredField(String name) 返回单个成员变量对象，存在就能拿到 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class ReflectDemo4 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException &#123; //获取成员变量对象 //1.获取class对象 Class clazz = Class.forName(&quot;com.itheima.reflectdemo.Student&quot;); //2.获取成员变量的对象（Field对象)只能获取public修饰的 Field[] fields1 = clazz.getFields(); for (Field field : fields1) &#123; System.out.println(field); &#125; System.out.println(&quot;===============================&quot;); //获取成员变量的对象（public + private） Field[] fields2 = clazz.getDeclaredFields(); for (Field field : fields2) &#123; System.out.println(field); &#125; System.out.println(&quot;===============================&quot;); //获得单个成员变量对象 //如果获取的属性是不存在的，那么会报异常 //Field field3 = clazz.getField(&quot;aaa&quot;); //System.out.println(field3);//NoSuchFieldException Field field4 = clazz.getField(&quot;gender&quot;); System.out.println(field4); System.out.println(&quot;===============================&quot;); //获取单个成员变量（私有） Field field5 = clazz.getDeclaredField(&quot;name&quot;); System.out.println(field5); &#125;&#125;public class Student &#123; private String name; private int age; public String gender; public String address; public Student() &#123; &#125; public Student(String name, int age, String address) &#123; this.name = name; this.age = age; this.address = address; &#125; public Student(String name, int age, String gender, String address) &#123; this.name = name; this.age = age; this.gender = gender; this.address = address; &#125; /** * 获取 * @return name */ public String getName() &#123; return name; &#125; /** * 设置 * @param name */ public void setName(String name) &#123; this.name = name; &#125; /** * 获取 * @return age */ public int getAge() &#123; return age; &#125; /** * 设置 * @param age */ public void setAge(int age) &#123; this.age = age; &#125; /** * 获取 * @return gender */ public String getGender() &#123; return gender; &#125; /** * 设置 * @param gender */ public void setGender(String gender) &#123; this.gender = gender; &#125; /** * 获取 * @return address */ public String getAddress() &#123; return address; &#125; /** * 设置 * @param address */ public void setAddress(String address) &#123; this.address = address; &#125; public String toString() &#123; return &quot;Student&#123;name = &quot; + name + &quot;, age = &quot; + age + &quot;, gender = &quot; + gender + &quot;, address = &quot; + address + &quot;&#125;&quot;; &#125;&#125; 1.8 获取成员变量并获取值和修改值 方法 说明 void set(Object obj, Object value） 赋值 Object get(Object obj) 获取值 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class ReflectDemo5 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; Student s = new Student(&quot;zhangsan&quot;,23,&quot;广州&quot;); Student ss = new Student(&quot;lisi&quot;,24,&quot;北京&quot;); //需求： //利用反射获取成员变量并获取值和修改值 //1.获取class对象 Class clazz = Class.forName(&quot;com.itheima.reflectdemo.Student&quot;); //2.获取name成员变量 //field就表示name这个属性的对象 Field field = clazz.getDeclaredField(&quot;name&quot;); //临时修饰他的访问权限 field.setAccessible(true); //3.设置(修改)name的值 //参数一：表示要修改哪个对象的name？ //参数二：表示要修改为多少？ field.set(s,&quot;wangwu&quot;); //3.获取name的值 //表示我要获取这个对象的name的值 String result = (String)field.get(s); //4.打印结果 System.out.println(result); System.out.println(s); System.out.println(ss); &#125;&#125;public class Student &#123; private String name; private int age; public String gender; public String address; public Student() &#123; &#125; public Student(String name, int age, String address) &#123; this.name = name; this.age = age; this.address = address; &#125; public Student(String name, int age, String gender, String address) &#123; this.name = name; this.age = age; this.gender = gender; this.address = address; &#125; /** * 获取 * @return name */ public String getName() &#123; return name; &#125; /** * 设置 * @param name */ public void setName(String name) &#123; this.name = name; &#125; /** * 获取 * @return age */ public int getAge() &#123; return age; &#125; /** * 设置 * @param age */ public void setAge(int age) &#123; this.age = age; &#125; /** * 获取 * @return gender */ public String getGender() &#123; return gender; &#125; /** * 设置 * @param gender */ public void setGender(String gender) &#123; this.gender = gender; &#125; /** * 获取 * @return address */ public String getAddress() &#123; return address; &#125; /** * 设置 * @param address */ public void setAddress(String address) &#123; this.address = address; &#125; public String toString() &#123; return &quot;Student&#123;name = &quot; + name + &quot;, age = &quot; + age + &quot;, gender = &quot; + gender + &quot;, address = &quot; + address + &quot;&#125;&quot;; &#125;&#125; 1.9 获取成员方法规则： ​ get表示获取 ​ Declared表示私有 ​ 最后的s表示所有，复数形式 ​ 如果当前获取到的是私有的，必须要临时修改访问权限，否则无法使用 方法名 说明 Method[] getMethods() 返回所有成员方法对象的数组（只能拿public的） Method[] getDeclaredMethods() 返回所有成员方法对象的数组，存在就能拿到 Method getMethod(String name, Class&lt;?&gt;… parameterTypes) 返回单个成员方法对象（只能拿public的） Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes) 返回单个成员方法对象，存在就能拿到 代码示例： 1234567891011121314151617181920212223242526272829303132333435public class ReflectDemo6 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException &#123; //1.获取class对象 Class&lt;?&gt; clazz = Class.forName(&quot;com.itheima.reflectdemo.Student&quot;); //2.获取方法 //getMethods可以获取父类中public修饰的方法 Method[] methods1 = clazz.getMethods(); for (Method method : methods1) &#123; System.out.println(method); &#125; System.out.println(&quot;===========================&quot;); //获取所有的方法（包含私有） //但是只能获取自己类中的方法 Method[] methods2 = clazz.getDeclaredMethods(); for (Method method : methods2) &#123; System.out.println(method); &#125; System.out.println(&quot;===========================&quot;); //获取指定的方法（空参） Method method3 = clazz.getMethod(&quot;sleep&quot;); System.out.println(method3); Method method4 = clazz.getMethod(&quot;eat&quot;,String.class); System.out.println(method4); //获取指定的私有方法 Method method5 = clazz.getDeclaredMethod(&quot;playGame&quot;); System.out.println(method5); &#125;&#125; 1.10 获取成员方法并运行方法 Object invoke(Object obj, Object… args) ：运行方法 参数一：用obj对象调用该方法 参数二：调用方法的传递的参数（如果没有就不写） 返回值：方法的返回值（如果没有就不写） 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.itheima.a02reflectdemo1;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;public class ReflectDemo6 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; //1.获取字节码文件对象 Class clazz = Class.forName(&quot;com.itheima.a02reflectdemo1.Student&quot;); //2.获取一个对象 //需要用这个对象去调用方法 Student s = new Student(); //3.获取一个指定的方法 //参数一：方法名 //参数二：参数列表，如果没有可以不写 Method eatMethod = clazz.getMethod(&quot;eat&quot;,String.class); //运行 //参数一：表示方法的调用对象 //参数二：方法在运行时需要的实际参数 //注意点：如果方法有返回值，那么需要接收invoke的结果 //如果方法没有返回值，则不需要接收 String result = (String) eatMethod.invoke(s, &quot;重庆小面&quot;); System.out.println(result); &#125;&#125;public class Student &#123; private String name; private int age; public String gender; public String address; public Student() &#123; &#125; public Student(String name) &#123; this.name = name; &#125; private Student(String name, int age) &#123; this.name = name; this.age = age; &#125; /** * 获取 * @return name */ public String getName() &#123; return name; &#125; /** * 设置 * @param name */ public void setName(String name) &#123; this.name = name; &#125; /** * 获取 * @return age */ public int getAge() &#123; return age; &#125; /** * 设置 * @param age */ public void setAge(int age) &#123; this.age = age; &#125; public String toString() &#123; return &quot;Student&#123;name = &quot; + name + &quot;, age = &quot; + age + &quot;&#125;&quot;; &#125; private void study()&#123; System.out.println(&quot;学生在学习&quot;); &#125; private void sleep()&#123; System.out.println(&quot;学生在睡觉&quot;); &#125; public String eat(String something)&#123; System.out.println(&quot;学生在吃&quot; + something); return &quot;学生已经吃完了，非常happy&quot;; &#125;&#125; 面试题：​ 你觉得反射好不好？好，有两个方向 ​ 第一个方向：无视修饰符访问类中的内容。但是这种操作在开发中一般不用，都是框架底层来用的。 ​ 第二个方向：反射可以跟配置文件结合起来使用，动态的创建对象，动态的调用方法。 1.11 练习泛型擦除（掌握概念，了解代码）理解：（掌握） ​ 集合中的泛型只在java文件中存在，当编译成class文件之后，就没有泛型了。 代码示例：（了解） 123456789101112131415161718192021222324252627282930package com.itheima.reflectdemo;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.ArrayList;public class ReflectDemo8 &#123; public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123; //1.创建集合对象 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(123);// list.add(&quot;aaa&quot;); //2.利用反射运行add方法去添加字符串 //因为反射使用的是class字节码文件 //获取class对象 Class clazz = list.getClass(); //获取add方法对象 Method method = clazz.getMethod(&quot;add&quot;, Object.class); //运行方法 method.invoke(list,&quot;aaa&quot;); //打印集合 System.out.println(list); &#125;&#125; 1.12 练习：修改字符串的内容（掌握概念，了解代码）在这个练习中，我需要你掌握的是字符串不能修改的真正原因。 字符串，在底层是一个byte类型的字节数组，名字叫做value 1private final byte[] value; 真正不能被修改的原因：final和private final修饰value表示value记录的地址值不能修改。 private修饰value而且没有对外提供getvalue和setvalue的方法。所以，在外界不能获取或修改value记录的地址值。 如果要强行修改可以用反射： 代码示例：（了解） 123456789101112131415161718192021222324String s = &quot;abc&quot;;String ss = &quot;abc&quot;;// private final byte[] value= &#123;97,98,99&#125;;// 没有对外提供getvalue和setvalue的方法，不能修改value记录的地址值// 如果我们利用反射获取了value的地址值。// 也是可以修改的，final修饰的value// 真正不可变的value数组的地址值，里面的内容利用反射还是可以修改的，比较危险//1.获取class对象Class clazz = s.getClass();//2.获取value成员变量（private）Field field = clazz.getDeclaredField(&quot;value&quot;);//但是这种操作非常危险//JDK高版本已经屏蔽了这种操作，低版本还是可以的//临时修改权限field.setAccessible(true);//3.获取value记录的地址值byte[] bytes = (byte[]) field.get(s);bytes[0] = 100;System.out.println(s);//dbcSystem.out.println(ss);//dbc 1.13 练习，反射和配置文件结合动态获取的练习（重点）需求: 利用反射根据文件中的不同类名和方法名，创建不同的对象并调用方法。 分析: ①通过Properties加载配置文件 ②得到类名和方法名 ③通过类名反射得到Class对象 ④通过Class对象创建一个对象 ⑤通过Class对象得到方法 ⑥调用方法 代码示例： 1234567891011121314151617181920212223242526272829303132333435public class ReflectDemo9 &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; //1.读取配置文件的信息 Properties prop = new Properties(); FileInputStream fis = new FileInputStream(&quot;day14-code\\\\prop.properties&quot;); prop.load(fis); fis.close(); System.out.println(prop); String classname = prop.get(&quot;classname&quot;) + &quot;&quot;; String methodname = prop.get(&quot;methodname&quot;) + &quot;&quot;; //2.获取字节码文件对象 Class clazz = Class.forName(classname); //3.要先创建这个类的对象 Constructor con = clazz.getDeclaredConstructor(); con.setAccessible(true); Object o = con.newInstance(); System.out.println(o); //4.获取方法的对象 Method method = clazz.getDeclaredMethod(methodname); method.setAccessible(true); //5.运行方法 method.invoke(o); &#125;&#125;配置文件中的信息：classname=com.itheima.a02reflectdemo1.Studentmethodname=sleep 1.14 利用发射保存对象中的信息（重点）123456789101112131415161718192021222324252627282930313233public class MyReflectDemo &#123; public static void main(String[] args) throws IllegalAccessException, IOException &#123; /* 对于任意一个对象，都可以把对象所有的字段名和值，保存到文件中去 */ Student s = new Student(&quot;小A&quot;,23,&#x27;女&#x27;,167.5,&quot;睡觉&quot;); Teacher t = new Teacher(&quot;播妞&quot;,10000); saveObject(s); &#125; //把对象里面所有的成员变量名和值保存到本地文件中 public static void saveObject(Object obj) throws IllegalAccessException, IOException &#123; //1.获取字节码文件的对象 Class clazz = obj.getClass(); //2. 创建IO流 BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;myreflect\\\\a.txt&quot;)); //3. 获取所有的成员变量 Field[] fields = clazz.getDeclaredFields(); for (Field field : fields) &#123; field.setAccessible(true); //获取成员变量的名字 String name = field.getName(); //获取成员变量的值 Object value = field.get(obj); //写出数据 bw.write(name + &quot;=&quot; + value); bw.newLine(); &#125; bw.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class Student &#123; private String name; private int age; private char gender; private double height; private String hobby; public Student() &#123; &#125; public Student(String name, int age, char gender, double height, String hobby) &#123; this.name = name; this.age = age; this.gender = gender; this.height = height; this.hobby = hobby; &#125; /** * 获取 * @return name */ public String getName() &#123; return name; &#125; /** * 设置 * @param name */ public void setName(String name) &#123; this.name = name; &#125; /** * 获取 * @return age */ public int getAge() &#123; return age; &#125; /** * 设置 * @param age */ public void setAge(int age) &#123; this.age = age; &#125; /** * 获取 * @return gender */ public char getGender() &#123; return gender; &#125; /** * 设置 * @param gender */ public void setGender(char gender) &#123; this.gender = gender; &#125; /** * 获取 * @return height */ public double getHeight() &#123; return height; &#125; /** * 设置 * @param height */ public void setHeight(double height) &#123; this.height = height; &#125; /** * 获取 * @return hobby */ public String getHobby() &#123; return hobby; &#125; /** * 设置 * @param hobby */ public void setHobby(String hobby) &#123; this.hobby = hobby; &#125; public String toString() &#123; return &quot;Student&#123;name = &quot; + name + &quot;, age = &quot; + age + &quot;, gender = &quot; + gender + &quot;, height = &quot; + height + &quot;, hobby = &quot; + hobby + &quot;&#125;&quot;; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Teacher &#123; private String name; private double salary; public Teacher() &#123; &#125; public Teacher(String name, double salary) &#123; this.name = name; this.salary = salary; &#125; /** * 获取 * @return name */ public String getName() &#123; return name; &#125; /** * 设置 * @param name */ public void setName(String name) &#123; this.name = name; &#125; /** * 获取 * @return salary */ public double getSalary() &#123; return salary; &#125; /** * 设置 * @param salary */ public void setSalary(double salary) &#123; this.salary = salary; &#125; public String toString() &#123; return &quot;Teacher&#123;name = &quot; + name + &quot;, salary = &quot; + salary + &quot;&#125;&quot;; &#125;&#125; 2. 动态代理2.1 好处：​ 无侵入式的给方法增强功能 2.2 动态代理三要素：1，真正干活的对象 2，代理对象 3，利用代理调用方法 切记一点：代理可以增强或者拦截的方法都在接口中，接口需要写在newProxyInstance的第二个参数里。 2.3 代码实现：12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; /* 需求： 外面的人想要大明星唱一首歌 1. 获取代理的对象 代理对象 = ProxyUtil.createProxy(大明星的对象); 2. 再调用代理的唱歌方法 代理对象.唱歌的方法(&quot;只因你太美&quot;); */ //1. 获取代理的对象 BigStar bigStar = new BigStar(&quot;鸡哥&quot;); Star proxy = ProxyUtil.createProxy(bigStar); //2. 调用唱歌的方法 String result = proxy.sing(&quot;只因你太美&quot;); System.out.println(result); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*** 类的作用：* 创建一个代理** */public class ProxyUtil &#123; /* * * 方法的作用： * 给一个明星的对象，创建一个代理 * * 形参： * 被代理的明星对象 * * 返回值： * 给明星创建的代理 * * * * 需求： * 外面的人想要大明星唱一首歌 * 1. 获取代理的对象 * 代理对象 = ProxyUtil.createProxy(大明星的对象); * 2. 再调用代理的唱歌方法 * 代理对象.唱歌的方法(&quot;只因你太美&quot;); * */ public static Star createProxy(BigStar bigStar)&#123; /* java.lang.reflect.Proxy类：提供了为对象产生代理对象的方法： public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 参数一：用于指定用哪个类加载器，去加载生成的代理类 参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法 参数三：用来指定生成的代理对象要干什么事情*/ Star star = (Star) Proxy.newProxyInstance( ProxyUtil.class.getClassLoader(),//参数一：用于指定用哪个类加载器，去加载生成的代理类 new Class[]&#123;Star.class&#125;,//参数二：指定接口，这些接口用于指定生成的代理长什么，也就是有哪些方法 //参数三：用来指定生成的代理对象要干什么事情 new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /* * 参数一：代理的对象 * 参数二：要运行的方法 sing * 参数三：调用sing方法时，传递的实参 * */ if(&quot;sing&quot;.equals(method.getName()))&#123; System.out.println(&quot;准备话筒，收钱&quot;); &#125;else if(&quot;dance&quot;.equals(method.getName()))&#123; System.out.println(&quot;准备场地，收钱&quot;); &#125; //去找大明星开始唱歌或者跳舞 //代码的表现形式：调用大明星里面唱歌或者跳舞的方法 return method.invoke(bigStar,args); &#125; &#125; ); return star; &#125;&#125; 1234567public interface Star &#123; //我们可以把所有想要被代理的方法定义在接口当中 //唱歌 public abstract String sing(String name); //跳舞 public abstract void dance();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class BigStar implements Star &#123; private String name; public BigStar() &#123; &#125; public BigStar(String name) &#123; this.name = name; &#125; //唱歌 @Override public String sing(String name)&#123; System.out.println(this.name + &quot;正在唱&quot; + name); return &quot;谢谢&quot;; &#125; //跳舞 @Override public void dance()&#123; System.out.println(this.name + &quot;正在跳舞&quot;); &#125; /** * 获取 * @return name */ public String getName() &#123; return name; &#125; /** * 设置 * @param name */ public void setName(String name) &#123; this.name = name; &#125; public String toString() &#123; return &quot;BigStar&#123;name = &quot; + name + &quot;&#125;&quot;; &#125;&#125; 2.4 额外扩展动态代理，还可以拦截方法 比如： ​ 在这个故事中，经济人作为代理，如果别人让邀请大明星去唱歌，打篮球，经纪人就增强功能。 ​ 但是如果别人让大明星去扫厕所，经纪人就要拦截，不会去调用大明星的方法。 12345678910111213141516171819202122232425/** 类的作用：* 创建一个代理* */public class ProxyUtil &#123; public static Star createProxy(BigStar bigStar)&#123; public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) Star star = (Star) Proxy.newProxyInstance( ProxyUtil.class.getClassLoader(), new Class[]&#123;Star.class&#125;, new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(&quot;cleanWC&quot;.equals(method.getName()))&#123; System.out.println(&quot;拦截，不调用大明星的方法&quot;); return null; &#125; //如果是其他方法，正常执行 return method.invoke(bigStar,args); &#125; &#125; ); return star; &#125;&#125; 2.5 动态代理的练习​ 对add方法进行增强，对remove方法进行拦截，对其他方法不拦截也不增强 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MyProxyDemo1 &#123; public static void main(String[] args) &#123; //动态代码可以增强也可以拦截 //1.创建真正干活的人 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); //2.创建代理对象 //参数一：类加载器。当前类名.class.getClassLoader() // 找到是谁，把当前的类，加载到内存中了，我再麻烦他帮我干一件事情，把后面的代理类，也加载到内存 //参数二：是一个数组，在数组里面写接口的字节码文件对象。 // 如果写了List，那么表示代理，可以代理List接口里面所有的方法，对这些方法可以增强或者拦截 // 但是，一定要写ArrayList真实实现的接口 // 假设在第二个参数中，写了MyInter接口，那么是错误的。 // 因为ArrayList并没有实现这个接口，那么就无法对这个接口里面的方法，进行增强或拦截 //参数三：用来创建代理对象的匿名内部类 List proxyList = (List) Proxy.newProxyInstance( //参数一：类加载器 MyProxyDemo1.class.getClassLoader(), //参数二：是一个数组，表示代理对象能代理的方法范围 new Class[]&#123;List.class&#125;, //参数三：本质就是代理对象 new InvocationHandler() &#123; @Override //invoke方法参数的意义 //参数一：表示代理对象，一般不用（了解） //参数二：就是方法名，我们可以对方法名进行判断，是增强还是拦截 //参数三：就是下面第三步调用方法时，传递的参数。 //举例1： //list.add(&quot;阿玮好帅&quot;); //此时参数二就是add这个方法名 //此时参数三 args[0] 就是 阿玮好帅 //举例2： //list.set(1, &quot;aaa&quot;); //此时参数二就是set这个方法名 //此时参数三 args[0] 就是 1 args[1]&quot;aaa&quot; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //对add方法做一个增强，统计耗时时间 if (method.getName().equals(&quot;add&quot;)) &#123; long start = System.currentTimeMillis(); //调用集合的方法，真正的添加数据 method.invoke(list, args); long end = System.currentTimeMillis(); System.out.println(&quot;耗时时间：&quot; + (end - start)); //需要进行返回，返回值要跟真正增强或者拦截的方法保持一致 return true; &#125;else if(method.getName().equals(&quot;remove&quot;) &amp;&amp; args[0] instanceof Integer)&#123; System.out.println(&quot;拦截了按照索引删除的方法&quot;); return null; &#125;else if(method.getName().equals(&quot;remove&quot;))&#123; System.out.println(&quot;拦截了按照对象删除的方法&quot;); return false; &#125;else&#123; //如果当前调用的是其他方法,我们既不增强，也不拦截 method.invoke(list,args); return null; &#125; &#125; &#125; ); //3.调用方法 //如果调用者是list，就好比绕过了第二步的代码，直接添加元素 //如果调用者是代理对象，此时代理才能帮我们增强或者拦截 //每次调用方法的时候，都不会直接操作集合 //而是先调用代理里面的invoke，在invoke方法中进行判断，可以增强或者拦截 proxyList.add(&quot;aaa&quot;); proxyList.add(&quot;bbb&quot;); proxyList.add(&quot;ccc&quot;); proxyList.add(&quot;ddd&quot;); proxyList.remove(0); proxyList.remove(&quot;aaa&quot;); //打印集合 System.out.println(list); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"网络编程","slug":"33、网络编程","date":"2022-06-27T01:00:00.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"33、网络编程.html","link":"","permalink":"https://iexlee.github.io/33%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.html","excerpt":"","text":"1. 网络编程入门1.1 网络编程概述 计算机网络 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统 网络编程 在网络通信协议下，不同计算机上运行的程序，可以进行数据传输 1.2 网络编程三要素 IP地址 要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识 端口 网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识 协议 通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议 1.3 IP地址IP地址：是网络中设备的唯一标识 IP地址分为两大类 IPv4：是给每个连接在网络上的主机分配一个32bit地址。按照TCP&#x2F;IP规定，IP地址用二进制来表示，每个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000 00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多 IPv6：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8组十六进制数，这样就解决了网络地址资源数量不够的问题 DOS常用命令： ipconfig：查看本机IP地址 ping IP地址：检查网络是否连通 特殊IP地址： 127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用 1.4 InetAddressInetAddress：此类表示Internet协议（IP）地址 相关方法 方法名 说明 static InetAddress getByName(String host) 确定主机名称的IP地址。主机名称可以是机器名称，也可以是IP地址 String getHostName() 获取此IP地址的主机名 String getHostAddress() 返回文本显示中的IP地址字符串 代码演示 1234567891011121314public class InetAddressDemo &#123; public static void main(String[] args) throws UnknownHostException &#123; //InetAddress address = InetAddress.getByName(&quot;itheima&quot;); InetAddress address = InetAddress.getByName(&quot;192.168.1.66&quot;); //public String getHostName()：获取此IP地址的主机名 String name = address.getHostName(); //public String getHostAddress()：返回文本显示中的IP地址字符串 String ip = address.getHostAddress(); System.out.println(&quot;主机名：&quot; + name); System.out.println(&quot;IP地址：&quot; + ip); &#125;&#125; 1.5 端口和协议 端口 设备上应用程序的唯一标识 端口号 用两个字节表示的整数，它的取值范围是065535。其中，01023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会导致当前程序启动失败 协议 计算机网络中，连接和通信的规则被称为网络通信协议 UDP协议 用户数据报协议(User Datagram Protocol) UDP是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。 由于使用UDP协议消耗系统资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输 例如视频会议通常采用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在传输重要数据时不建议使用UDP协议 TCP协议 传输控制协议 (Transmission Control Protocol) TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手” 三次握手：TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠 第一次握手，客户端向服务器端发出连接请求，等待服务器确认 第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求 第三次握手，客户端再次向服务器端发送确认信息，确认连接 完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等 2.UDP通信程序2.1 UDP发送数据 Java中的UDP通信 UDP协议是一种不可靠的网络协议，它在通信的两端各建立一个Socket对象，但是这两个Socket只是发送，接收数据的对象，因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念 Java提供了DatagramSocket类作为基于UDP协议的Socket 构造方法 方法名 说明 DatagramSocket() 创建数据报套接字并将其绑定到本机地址上的任何可用端口 DatagramPacket(byte[] buf,int len,InetAddress add,int port) 创建数据包,发送长度为len的数据包到指定主机的指定端口 相关方法 方法名 说明 void send(DatagramPacket p) 发送数据报包 void close() 关闭数据报套接字 void receive(DatagramPacket p) 从此套接字接受数据报包 发送数据的步骤 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包 调用DatagramSocket对象的方法发送数据 关闭发送端 代码演示 12345678910111213141516171819202122public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口 DatagramSocket ds = new DatagramSocket(); //创建数据，并把数据打包 //DatagramPacket(byte[] buf, int length, InetAddress address, int port) //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。 byte[] bys = &quot;hello,udp,我来了&quot;.getBytes(); DatagramPacket dp = new DatagramPacket(bys,bys.length,InetAddress.getByName(&quot;127.0.0.1&quot;),10086); //调用DatagramSocket对象的方法发送数据 //void send(DatagramPacket p) 从此套接字发送数据报包 ds.send(dp); //关闭发送端 //void close() 关闭此数据报套接字 ds.close(); &#125;&#125; 2.2UDP接收数据 接收数据的步骤 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 构造方法 方法名 说明 DatagramPacket(byte[] buf, int len) 创建一个DatagramPacket用于接收长度为len的数据包 相关方法 方法名 说明 byte[] getData() 返回数据缓冲区 int getLength() 返回要发送的数据的长度或接收的数据的长度 示例代码 1234567891011121314151617public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println(&quot;数据是：&quot; + new String(dp.getData(), 0, dp.getLength())); &#125; &#125;&#125; 2.3UDP通信程序练习 案例需求 UDP发送数据：数据来自于键盘录入，直到输入的数据是886，发送数据结束 UDP接收数据：因为接收端不知道发送端什么时候停止发送，故采用死循环接收 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* UDP发送数据： 数据来自于键盘录入，直到输入的数据是886，发送数据结束 */public class SendDemo &#123; public static void main(String[] args) throws IOException &#123; //创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); //键盘录入数据 Scanner sc = new Scanner(System.in); while (true) &#123; String s = sc.nextLine(); //输入的数据是886，发送数据结束 if (&quot;886&quot;.equals(s)) &#123; break; &#125; //创建数据，并把数据打包 byte[] bys = s.getBytes(); DatagramPacket dp = new DatagramPacket(bys, bys.length, InetAddress.getByName(&quot;192.168.1.66&quot;), 12345); //调用DatagramSocket对象的方法发送数据 ds.send(dp); &#125; //关闭发送端 ds.close(); &#125;&#125;/* UDP接收数据： 因为接收端不知道发送端什么时候停止发送，故采用死循环接收 */public class ReceiveDemo &#123; public static void main(String[] args) throws IOException &#123; //创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(12345); while (true) &#123; //创建一个数据包，用于接收数据 byte[] bys = new byte[1024]; DatagramPacket dp = new DatagramPacket(bys, bys.length); //调用DatagramSocket对象的方法接收数据 ds.receive(dp); //解析数据包，并把数据在控制台显示 System.out.println(&quot;数据是：&quot; + new String(dp.getData(), 0, dp.getLength())); &#125; //关闭接收端// ds.close(); &#125;&#125; 2.4UDP三种通讯方式 单播 单播用于两个主机之间的端对端通信 组播 组播用于对一组特定的主机进行通信 广播 广播用于一个主机对整个局域网上所有主机上的数据通信 2.5UDP组播实现 实现步骤 发送端 创建发送端的Socket对象(DatagramSocket) 创建数据，并把数据打包(DatagramPacket) 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) 释放资源 接收端 创建接收端Socket对象(MulticastSocket) 创建一个箱子,用于接收数据 把当前计算机绑定一个组播地址 将数据接收到箱子中 解析数据包,并打印数据 释放资源 代码实现 123456789101112131415161718192021222324252627282930313233343536// 发送端public class ClinetDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建发送端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); String s = &quot;hello 组播&quot;; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName(&quot;224.0.1.0&quot;); int port = 10000; // 2. 创建数据，并把数据打包(DatagramPacket) DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 调用DatagramSocket对象的方法发送数据(在单播中,这里是发给指定IP的电脑但是在组播当中,这里是发给组播地址) ds.send(dp); // 4. 释放资源 ds.close(); &#125;&#125;// 接收端public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建接收端Socket对象(MulticastSocket) MulticastSocket ms = new MulticastSocket(10000); // 2. 创建一个箱子,用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 把当前计算机绑定一个组播地址,表示添加到这一组中. ms.joinGroup(InetAddress.getByName(&quot;224.0.1.0&quot;)); // 4. 将数据接收到箱子中 ms.receive(dp); // 5. 解析数据包,并打印数据 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 6. 释放资源 ms.close(); &#125;&#125; 2.6UDP广播实现 实现步骤 发送端 创建发送端Socket对象(DatagramSocket) 创建存储数据的箱子,将广播地址封装进去 发送数据 释放资源 接收端 创建接收端的Socket对象(DatagramSocket) 创建一个数据包，用于接收数据 调用DatagramSocket对象的方法接收数据 解析数据包，并把数据在控制台显示 关闭接收端 代码实现 1234567891011121314151617181920212223242526272829303132333435// 发送端public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建发送端Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(); // 2. 创建存储数据的箱子,将广播地址封装进去 String s = &quot;广播 hello&quot;; byte[] bytes = s.getBytes(); InetAddress address = InetAddress.getByName(&quot;255.255.255.255&quot;); int port = 10000; DatagramPacket dp = new DatagramPacket(bytes,bytes.length,address,port); // 3. 发送数据 ds.send(dp); // 4. 释放资源 ds.close(); &#125;&#125;// 接收端public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; // 1. 创建接收端的Socket对象(DatagramSocket) DatagramSocket ds = new DatagramSocket(10000); // 2. 创建一个数据包，用于接收数据 DatagramPacket dp = new DatagramPacket(new byte[1024],1024); // 3. 调用DatagramSocket对象的方法接收数据 ds.receive(dp); // 4. 解析数据包，并把数据在控制台显示 byte[] data = dp.getData(); int length = dp.getLength(); System.out.println(new String(data,0,length)); // 5. 关闭接收端 ds.close(); &#125;&#125; ##3. TCP通信程序 3.1TCP发送数据 Java中的TCP通信 Java对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过Socket产生IO流来进行网络通信。 Java为客户端提供了Socket类，为服务器端提供了ServerSocket类 构造方法 方法名 说明 Socket(InetAddress address,int port) 创建流套接字并将其连接到指定IP指定端口号 Socket(String host, int port) 创建流套接字并将其连接到指定主机上的指定端口号 相关方法 方法名 说明 InputStream getInputStream() 返回此套接字的输入流 OutputStream getOutputStream() 返回此套接字的输出流 示例代码 12345678910111213141516171819public class Client &#123; public static void main(String[] args) throws IOException &#123; //TCP协议，发送数据 //1.创建Socket对象 //细节：在创建对象的同时会连接服务端 // 如果连接不上，代码会报错 Socket socket = new Socket(&quot;127.0.0.1&quot;,10000); //2.可以从连接通道中获取输出流 OutputStream os = socket.getOutputStream(); //写出数据 os.write(&quot;aaa&quot;.getBytes()); //3.释放资源 os.close(); socket.close(); &#125;&#125; 3.2TCP接收数据 构造方法 方法名 说明 ServletSocket(int port) 创建绑定到指定端口的服务器套接字 相关方法 方法名 说明 Socket accept() 监听要连接到此的套接字并接受它 注意事项 accept方法是阻塞的,作用就是等待客户端连接 客户端创建对象并连接服务器,此时是通过三次握手协议,保证跟服务器之间的连接 针对客户端来讲,是往外写的,所以是输出流针对服务器来讲,是往里读的,所以是输入流 read方法也是阻塞的 客户端在关流的时候,还多了一个往服务器写结束标记的动作 最后一步断开连接,通过四次挥手协议保证连接终止 三次握手和四次挥手 三次握手 四次挥手 示例代码 12345678910111213141516171819202122public class Server &#123; public static void main(String[] args) throws IOException &#123; //TCP协议，接收数据 //1.创建对象ServerSocker ServerSocket ss = new ServerSocket(10000); //2.监听客户端的链接 Socket socket = ss.accept(); //3.从连接通道中获取输入流读取数据 InputStream is = socket.getInputStream(); int b; while ((b = is.read()) != -1)&#123; System.out.println((char) b); &#125; //4.释放资源 socket.close(); ss.close(); &#125;&#125; 3.3TCP程序练习（传输中文）发送端： 12345678910111213141516171819202122public class Client &#123; public static void main(String[] args) throws IOException &#123; //TCP协议，发送数据 //1.创建Socket对象 //细节：在创建对象的同时会连接服务端 // 如果连接不上，代码会报错 Socket socket = new Socket(&quot;127.0.0.1&quot;,10000); //2.可以从连接通道中获取输出流 OutputStream os = socket.getOutputStream(); //写出数据 os.write(&quot;你好你好&quot;.getBytes());//12字节 //3.释放资源 os.close(); socket.close(); &#125;&#125; 接收端： 12345678910111213141516171819202122232425262728public class Server &#123; public static void main(String[] args) throws IOException &#123; //TCP协议，接收数据 //1.创建对象ServerSocker ServerSocket ss = new ServerSocket(10000); //2.监听客户端的链接 Socket socket = ss.accept(); //3.从连接通道中获取输入流读取数据 InputStream is = socket.getInputStream(); InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); // BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); int b; while ((b = br.read()) != -1)&#123; System.out.print((char) b); &#125; //4.释放资源 socket.close(); ss.close(); &#125;&#125; 4. 综合练习练习一：多发多收需求： ​ 客户端：多次发送数据 ​ 服务器：接收多次接收数据，并打印 代码示例： 123456789101112131415161718192021222324public class Client &#123; public static void main(String[] args) throws IOException &#123; //客户端：多次发送数据 //服务器：接收多次接收数据，并打印 //1. 创建Socket对象并连接服务端 Socket socket = new Socket(&quot;127.0.0.1&quot;,10000); //2.写出数据 Scanner sc = new Scanner(System.in); OutputStream os = socket.getOutputStream(); while (true) &#123; System.out.println(&quot;请输入您要发送的信息&quot;); String str = sc.nextLine(); if(&quot;886&quot;.equals(str))&#123; break; &#125; os.write(str.getBytes()); &#125; //3.释放资源 socket.close(); &#125;&#125; 1234567891011121314151617181920212223public class Server &#123; public static void main(String[] args) throws IOException &#123; //客户端：多次发送数据 //服务器：接收多次接收数据，并打印 //1.创建对象绑定10000端口 ServerSocket ss = new ServerSocket(10000); //2.等待客户端来连接 Socket socket = ss.accept(); //3.读取数据 InputStreamReader isr = new InputStreamReader(socket.getInputStream()); int b; while ((b = isr.read()) != -1)&#123; System.out.print((char)b); &#125; //4.释放资源 socket.close(); ss.close(); &#125;&#125; 练习二：接收并反馈 案例需求 客户端：发送数据，接受服务器反馈 服务器：收到消息后给出反馈 案例分析 客户端创建对象，使用输出流输出数据 服务端创建对象，使用输入流接受数据 服务端使用输出流给出反馈数据 客户端使用输入流接受反馈数据 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 客户端public class ClientDemo &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(&quot;127.0.0.1&quot;,10000); OutputStream os = socket.getOutputStream(); os.write(&quot;hello&quot;.getBytes()); // os.close();如果在这里关流,会导致整个socket都无法使用 socket.shutdownOutput();//仅仅关闭输出流.并写一个结束标记,对socket没有任何影响 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line; while((line = br.readLine())!=null)&#123; System.out.println(line); &#125; br.close(); os.close(); socket.close(); &#125;&#125;// 服务器public class ServerDemo &#123; public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(10000); Socket accept = ss.accept(); InputStream is = accept.getInputStream(); int b; while((b = is.read())!=-1)&#123; System.out.println((char) b); &#125; System.out.println(&quot;看看我执行了吗?&quot;); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(accept.getOutputStream())); bw.write(&quot;你谁啊?&quot;); bw.newLine(); bw.flush(); bw.close(); is.close(); accept.close(); ss.close(); &#125;&#125; 练习三：上传练习（TCP协议） 案例需求 客户端：数据来自于本地文件，接收服务器反馈 服务器：接收到的数据写入本地文件，给出反馈 案例分析 创建客户端对象，创建输入流对象指向文件，每读一次数据就给服务器输出一次数据，输出结束后使用shutdownOutput()方法告知服务端传输结束 创建服务器对象，创建输出流对象指向文件，每接受一次数据就使用输出流输出到文件中，传输结束后。使用输出流给客户端反馈信息 客户端接受服务端的回馈信息 相关方法 方法名 说明 void shutdownInput() 将此套接字的输入流放置在“流的末尾” void shutdownOutput() 禁止用此套接字的输出流 代码实现 123456789101112131415161718192021222324252627282930313233public class Client &#123; public static void main(String[] args) throws IOException &#123; //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1. 创建Socket对象，并连接服务器 Socket socket = new Socket(&quot;127.0.0.1&quot;,10000); //2.读取本地文件中的数据，并写到服务器当中 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;mysocketnet\\\\clientdir\\\\a.jpg&quot;)); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); byte[] bytes = new byte[1024]; int len; while ((len = bis.read(bytes)) != -1)&#123; bos.write(bytes,0,len); &#125; //往服务器写出结束标记 socket.shutdownOutput(); //3.接收服务器的回写数据 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = br.readLine(); System.out.println(line); //4.释放资源 socket.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132public class Server &#123; public static void main(String[] args) throws IOException &#123; //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1.创建对象并绑定端口 ServerSocket ss = new ServerSocket(10000); //2.等待客户端来连接 Socket socket = ss.accept(); //3.读取数据并保存到本地文件中 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;mysocketnet\\\\serverdir\\\\a.jpg&quot;)); int len; byte[] bytes = new byte[1024]; while ((len = bis.read(bytes)) != -1)&#123; bos.write(bytes,0,len); &#125; bos.close(); //4.回写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(&quot;上传成功&quot;); bw.newLine(); bw.flush(); //5.释放资源 socket.close(); ss.close(); &#125;&#125; 练习四：文件名重复 123456public class UUIDTest &#123; public static void main(String[] args) &#123; String str = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); System.out.println(str);//9f15b8c356c54f55bfcb0ee3023fce8a &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class Client &#123; public static void main(String[] args) throws IOException &#123; //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1. 创建Socket对象，并连接服务器 Socket socket = new Socket(&quot;127.0.0.1&quot;,10000); //2.读取本地文件中的数据，并写到服务器当中 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;mysocketnet\\\\clientdir\\\\a.jpg&quot;)); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); byte[] bytes = new byte[1024]; int len; while ((len = bis.read(bytes)) != -1)&#123; bos.write(bytes,0,len); &#125; //往服务器写出结束标记 socket.shutdownOutput(); //3.接收服务器的回写数据 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = br.readLine(); System.out.println(line); //4.释放资源 socket.close(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class Server &#123; public static void main(String[] args) throws IOException &#123; //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1.创建对象并绑定端口 ServerSocket ss = new ServerSocket(10000); //2.等待客户端来连接 Socket socket = ss.accept(); //3.读取数据并保存到本地文件中 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); String name = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;mysocketnet\\\\serverdir\\\\&quot; + name + &quot;.jpg&quot;)); int len; byte[] bytes = new byte[1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0, len); &#125; bos.close(); //4.回写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(&quot;上传成功&quot;); bw.newLine(); bw.flush(); //5.释放资源 socket.close(); ss.close(); &#125;&#125; 练习五：服务器改写为多线程服务器只能处理一个客户端请求，接收完一个图片之后，服务器就关闭了。 优化方案一： ​ 使用循环 弊端： ​ 第一个用户正在上传数据，第二个用户就来访问了，此时第二个用户是无法成功上传的。 ​ 所以，使用多线程改进 优化方案二： ​ 每来一个用户，就开启多线程处理 123456789101112131415161718192021222324252627282930313233public class Client &#123; public static void main(String[] args) throws IOException &#123; //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1. 创建Socket对象，并连接服务器 Socket socket = new Socket(&quot;127.0.0.1&quot;,10000); //2.读取本地文件中的数据，并写到服务器当中 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;mysocketnet\\\\clientdir\\\\a.jpg&quot;)); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); byte[] bytes = new byte[1024]; int len; while ((len = bis.read(bytes)) != -1)&#123; bos.write(bytes,0,len); &#125; //往服务器写出结束标记 socket.shutdownOutput(); //3.接收服务器的回写数据 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = br.readLine(); System.out.println(line); //4.释放资源 socket.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Server &#123; public static void main(String[] args) throws IOException &#123; //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1.创建对象并绑定端口 ServerSocket ss = new ServerSocket(10000); while (true) &#123; //2.等待客户端来连接 Socket socket = ss.accept(); //开启一条线程 //一个用户就对应服务端的一条线程 new Thread(new MyRunnable(socket)).start(); &#125; &#125;&#125;public class MyRunnable implements Runnable&#123; Socket socket; public MyRunnable(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; //3.读取数据并保存到本地文件中 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); String name = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;mysocketnet\\\\serverdir\\\\&quot; + name + &quot;.jpg&quot;)); int len; byte[] bytes = new byte[1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0, len); &#125; bos.close(); //4.回写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(&quot;上传成功&quot;); bw.newLine(); bw.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //5.释放资源 if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 练习六：线程池改进123456789101112131415161718192021222324252627282930313233public class Client &#123; public static void main(String[] args) throws IOException &#123; //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //1. 创建Socket对象，并连接服务器 Socket socket = new Socket(&quot;127.0.0.1&quot;,10000); //2.读取本地文件中的数据，并写到服务器当中 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;mysocketnet\\\\clientdir\\\\a.jpg&quot;)); BufferedOutputStream bos = new BufferedOutputStream(socket.getOutputStream()); byte[] bytes = new byte[1024]; int len; while ((len = bis.read(bytes)) != -1)&#123; bos.write(bytes,0,len); &#125; //往服务器写出结束标记 socket.shutdownOutput(); //3.接收服务器的回写数据 BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream())); String line = br.readLine(); System.out.println(line); //4.释放资源 socket.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334public class Server &#123; public static void main(String[] args) throws IOException &#123; //客户端：将本地文件上传到服务器。接收服务器的反馈。 //服务器：接收客户端上传的文件，上传完毕之后给出反馈。 //创建线程池对象 ThreadPoolExecutor pool = new ThreadPoolExecutor( 3,//核心线程数量 16,//线程池总大小 60,//空闲时间 TimeUnit.SECONDS,//空闲时间（单位） new ArrayBlockingQueue&lt;&gt;(2),//队列 Executors.defaultThreadFactory(),//线程工厂，让线程池如何创建线程对象 new ThreadPoolExecutor.AbortPolicy()//阻塞队列 ); //1.创建对象并绑定端口 ServerSocket ss = new ServerSocket(10000); while (true) &#123; //2.等待客户端来连接 Socket socket = ss.accept(); //开启一条线程 //一个用户就对应服务端的一条线程 //new Thread(new MyRunnable(socket)).start(); pool.submit(new MyRunnable(socket)); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class MyRunnable implements Runnable&#123; Socket socket; public MyRunnable(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; //3.读取数据并保存到本地文件中 BufferedInputStream bis = new BufferedInputStream(socket.getInputStream()); String name = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;mysocketnet\\\\serverdir\\\\&quot; + name + &quot;.jpg&quot;)); int len; byte[] bytes = new byte[1024]; while ((len = bis.read(bytes)) != -1) &#123; bos.write(bytes, 0, len); &#125; bos.close(); //4.回写数据 BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream())); bw.write(&quot;上传成功&quot;); bw.newLine(); bw.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //5.释放资源 if(socket != null)&#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"多线程02","slug":"32、多线程02","date":"2022-06-21T01:00:00.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"32、多线程02.html","link":"","permalink":"https://iexlee.github.io/32%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B02.html","excerpt":"","text":"1. 线程池1.1 线程状态介绍当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。线程对象在不同的时期有不同的状态。那么Java中的线程存在哪几种状态呢？Java中的线程 状态被定义在了java.lang.Thread.State枚举类中，State枚举类的源码如下： 123456789101112131415161718192021222324252627282930public class Thread &#123; public enum State &#123; /* 新建 */ NEW , /* 可运行状态 */ RUNNABLE , /* 阻塞状态 */ BLOCKED , /* 无限等待状态 */ WAITING , /* 计时等待 */ TIMED_WAITING , /* 终止 */ TERMINATED; &#125; // 获取当前线程的状态 public State getState() &#123; return jdk.internal.misc.VM.toThreadState(threadStatus); &#125; &#125; 通过源码我们可以看到Java中的线程存在6种状态，每种线程状态的含义如下 线程状态 具体含义 NEW 一个尚未启动的线程的状态。也称之为初始状态、开始状态。线程刚被创建，但是并未启动。还没调用start方法。MyThread t &#x3D; new MyThread()只有线程象，没有线程特征。 RUNNABLE 当我们调用线程对象的start方法，那么此时线程对象进入了RUNNABLE状态。那么此时才是真正的在JVM进程中创建了一个线程，线程一经启动并不是立即得到执行，线程的运行与否要听令与CPU的调度，那么我们把这个中间状态称之为可执行状态(RUNNABLE)也就是说它具备执行的资格，但是并没有真正的执行起来而是在等待CPU的度。 BLOCKED 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。 WAITING 一个正在等待的线程的状态。也称之为等待状态。造成线程等待的原因有两种，分别是调用Object.wait()、join()方法。处于等待状态的线程，正在等待其他线程去执行一个特定的操作。例如：因为wait()而等待的线程正在等待另一个线程去调用notify()或notifyAll()；一个因为join()而等待的线程正在等待另一个线程结束。 TIMED_WAITING 一个在限定时间内等待的线程的状态。也称之为限时等待状态。造成线程限时等待状态的原因有三种，分别是：Thread.sleep(long)，Object.wait(long)、join(long)。 TERMINATED 一个完全运行完成的线程的状态。也称之为终止状态、结束状态 各个状态的转换，如下图所示： 1.2 线程池-基本原理概述 : ​ 提到池，大家应该能想到的就是水池。水池就是一个容器，在该容器中存储了很多的水。那么什么是线程池呢？线程池也是可以看做成一个池子，在该池子中存储很多个线程。 线程池存在的意义： ​ 系统创建一个线程的成本是比较高的，因为它涉及到与操作系统交互，当程序中需要创建大量生存期很短暂的线程时，频繁的创建和销毁线程对系统的资源消耗有可能大于业务处理是对系 ​ 统资源的消耗，这样就有点”舍本逐末”了。针对这一种情况，为了提高性能，我们就可以采用线程池。线程池在启动的时，会创建大量空闲线程，当我们向线程池提交任务的时，线程池就 ​ 会启动一个线程来执行该任务。等待任务执行完毕以后，线程并不会死亡，而是再次返回到线程池中称为空闲状态。等待下一次任务的执行。 线程池的设计思路 : 准备一个任务容器 一次性启动多个(2个)消费者线程 刚开始任务容器是空的，所以线程都在wait 直到一个外部线程向这个任务容器中扔了一个”任务”，就会有一个消费者线程被唤醒 这个消费者线程取出”任务”，并且执行这个任务，执行完毕后，继续等待下一次任务的到来 1.3 线程池-Executors默认线程池概述 : JDK对线程池也进行了相关的实现，在真实企业开发中我们也很少去自定义线程池，而是使用JDK中自带的线程池。 我们可以使用Executors中所提供的静态方法来创建线程池 ​ static ExecutorService newCachedThreadPool() 创建一个默认的线程池​ static newFixedThreadPool(int nThreads) 创建一个指定最多线程数量的线程池 代码实现 : 12345678910111213141516171819202122232425262728293031package com.itheima.mythreadpool;//static ExecutorService newCachedThreadPool() 创建一个默认的线程池//static newFixedThreadPool(int nThreads) 创建一个指定最多线程数量的线程池import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class MyThreadPoolDemo &#123; public static void main(String[] args) throws InterruptedException &#123; //1,创建一个默认的线程池对象.池子中默认是空的.默认最多可以容纳int类型的最大值. ExecutorService executorService = Executors.newCachedThreadPool(); //Executors --- 可以帮助我们创建线程池对象 //ExecutorService --- 可以帮助我们控制线程池 executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;在执行了&quot;); &#125;); //Thread.sleep(2000); executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;在执行了&quot;); &#125;); executorService.shutdown(); &#125;&#125; 1.4 线程池-Executors创建指定上限的线程池使用Executors中所提供的静态方法来创建线程池 ​ static ExecutorService newFixedThreadPool(int nThreads) : 创建一个指定最多线程数量的线程池 代码实现 : 123456789101112131415161718192021222324252627282930package com.itheima.mythreadpool;//static ExecutorService newFixedThreadPool(int nThreads)//创建一个指定最多线程数量的线程池import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;public class MyThreadPoolDemo2 &#123; public static void main(String[] args) &#123; //参数不是初始值而是最大值 ExecutorService executorService = Executors.newFixedThreadPool(10); ThreadPoolExecutor pool = (ThreadPoolExecutor) executorService; System.out.println(pool.getPoolSize());//0 executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;在执行了&quot;); &#125;); executorService.submit(()-&gt;&#123; System.out.println(Thread.currentThread().getName() + &quot;在执行了&quot;); &#125;); System.out.println(pool.getPoolSize());//2// executorService.shutdown(); &#125;&#125; 1.5 线程池-ThreadPoolExecutor创建线程池对象 : ThreadPoolExecutor threadPoolExecutor &#x3D; new ThreadPoolExecutor(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略); 代码实现 : 1234567891011121314151617181920212223package com.itheima.mythreadpool;import java.util.concurrent.ArrayBlockingQueue;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;public class MyThreadPoolDemo3 &#123;// 参数一：核心线程数量// 参数二：最大线程数// 参数三：空闲线程最大存活时间// 参数四：时间单位// 参数五：任务队列// 参数六：创建线程工厂// 参数七：任务的拒绝策略 public static void main(String[] args) &#123; ThreadPoolExecutor pool = new ThreadPoolExecutor(2,5,2,TimeUnit.SECONDS,new ArrayBlockingQueue&lt;&gt;(10), Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy()); pool.submit(new MyRunnable()); pool.submit(new MyRunnable()); pool.shutdown(); &#125;&#125; 1.6 线程池-参数详解 123456789101112131415public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize： 核心线程的最大值，不能小于0maximumPoolSize：最大线程数，不能小于等于0，maximumPoolSize &gt;= corePoolSizekeepAliveTime： 空闲线程最大存活时间,不能小于0unit： 时间单位workQueue： 任务队列，不能为nullthreadFactory： 创建线程工厂,不能为null handler： 任务的拒绝策略,不能为null 1.7 线程池-非默认任务拒绝策略RejectedExecutionHandler是jdk提供的一个任务拒绝策略接口，它下面存在4个子类。 1234ThreadPoolExecutor.AbortPolicy: 丢弃任务并抛出RejectedExecutionException异常。是默认的策略。ThreadPoolExecutor.DiscardPolicy： 丢弃任务，但是不抛出异常 这是不推荐的做法。ThreadPoolExecutor.DiscardOldestPolicy： 抛弃队列中等待最久的任务 然后把当前任务加入队列中。ThreadPoolExecutor.CallerRunsPolicy: 调用任务的run()方法绕过线程池直接执行。 注：明确线程池对多可执行的任务数 &#x3D; 队列容量 + 最大线程数 案例演示1：演示ThreadPoolExecutor.AbortPolicy任务处理策略 123456789101112131415161718public class ThreadPoolExecutorDemo01 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.AbortPolicy()) ; // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用AbortPolicy这个任务处理策略的时候，就会抛出异常 for(int x = 0 ; x &lt; 5 ; x++) &#123; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;----&gt;&gt; 执行了任务&quot;); &#125;); &#125; &#125;&#125; 控制台输出结果 1234pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务 控制台报错，仅仅执行了4个任务，有一个任务被丢弃了 案例演示2：演示ThreadPoolExecutor.DiscardPolicy任务处理策略 12345678910111213141516public class ThreadPoolExecutorDemo02 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardPolicy()) ; // 提交5个任务，而该线程池最多可以处理4个任务，当我们使用DiscardPolicy这个任务处理策略的时候，控制台不会报错 for(int x = 0 ; x &lt; 5 ; x++) &#123; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;----&gt;&gt; 执行了任务&quot;); &#125;); &#125; &#125;&#125; 控制台输出结果 1234pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务 控制台没有报错，仅仅执行了4个任务，有一个任务被丢弃了 案例演示3：演示ThreadPoolExecutor.DiscardOldestPolicy任务处理策略 123456789101112131415161718public class ThreadPoolExecutorDemo02 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor; threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.DiscardOldestPolicy()); // 提交5个任务 for(int x = 0 ; x &lt; 5 ; x++) &#123; // 定义一个变量，来指定指定当前执行的任务;这个变量需要被final修饰 final int y = x ; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;----&gt;&gt; 执行了任务&quot; + y); &#125;); &#125; &#125;&#125; 控制台输出结果 1234pool-1-thread-2----&gt;&gt; 执行了任务2pool-1-thread-1----&gt;&gt; 执行了任务0pool-1-thread-3----&gt;&gt; 执行了任务3pool-1-thread-1----&gt;&gt; 执行了任务4 由于任务1在线程池中等待时间最长，因此任务1被丢弃。 案例演示4：演示ThreadPoolExecutor.CallerRunsPolicy任务处理策略 123456789101112131415161718public class ThreadPoolExecutorDemo04 &#123; public static void main(String[] args) &#123; /** * 核心线程数量为1 ， 最大线程池数量为3, 任务容器的容量为1 ,空闲线程的最大存在时间为20s */ ThreadPoolExecutor threadPoolExecutor; threadPoolExecutor = new ThreadPoolExecutor(1 , 3 , 20 , TimeUnit.SECONDS , new ArrayBlockingQueue&lt;&gt;(1) , Executors.defaultThreadFactory() , new ThreadPoolExecutor.CallerRunsPolicy()); // 提交5个任务 for(int x = 0 ; x &lt; 5 ; x++) &#123; threadPoolExecutor.submit(() -&gt; &#123; System.out.println(Thread.currentThread().getName() + &quot;----&gt;&gt; 执行了任务&quot;); &#125;); &#125; &#125;&#125; 控制台输出结果 12345pool-1-thread-1----&gt;&gt; 执行了任务pool-1-thread-3----&gt;&gt; 执行了任务pool-1-thread-2----&gt;&gt; 执行了任务pool-1-thread-1----&gt;&gt; 执行了任务main----&gt;&gt; 执行了任务 通过控制台的输出，我们可以看到次策略没有通过线程池中的线程执行任务，而是直接调用任务的run()方法绕过线程池直接执行。 2. 多线程综合练习练习一：售票需求： ​ 一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒, ​ 请用多线程模拟卖票过程并打印剩余电影票的数量 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyThread extends Thread &#123; //第一种方式实现多线程，测试类中MyThread会创建多次，所以需要加static static int ticket = 1000; @Override public void run() &#123; //1.循环 while (true) &#123; //2.同步代码块 synchronized (MyThread.class) &#123; //3.判断共享数据（已经到末尾） if (ticket == 0) &#123; break; &#125; else &#123; //4.判断共享数据（没有到末尾） try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ticket--; System.out.println(getName() + &quot;在卖票，还剩下&quot; + ticket + &quot;张票!!!&quot;); &#125; &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; /* 一共有1000张电影票,可以在两个窗口领取,假设每次领取的时间为3000毫秒, 要求:请用多线程模拟卖票过程并打印剩余电影票的数量 */ //创建线程对象 MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); //给线程设置名字 t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); //开启线程 t1.start(); t2.start(); &#125;&#125; 练习二：赠送礼物需求： ​ 有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出。 ​ 利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyRunable implements Runnable &#123; //第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static int count = 100; @Override public void run() &#123; //1.循环 while (true) &#123; //2.同步代码块 synchronized (MyThread.class) &#123; //3.判断共享数据（已经到末尾） if (count &lt; 10) &#123; System.out.println(&quot;礼物还剩下&quot; + count + &quot;不再赠送&quot;); break; &#125; else &#123; //4.判断共享数据（没有到末尾） count--; System.out.println(Thread.currentThread().getName() + &quot;在赠送礼物，还剩下&quot; + count + &quot;个礼物!!!&quot;); &#125; &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; /* 有100份礼品,两人同时发送，当剩下的礼品小于10份的时候则不再送出， 利用多线程模拟该过程并将线程的名字和礼物的剩余数量打印出来. */ //创建参数对象 MyRunable mr = new MyRunable(); //创建线程对象 Thread t1 = new Thread(mr,&quot;窗口1&quot;); Thread t2 = new Thread(mr,&quot;窗口2&quot;); //启动线程 t1.start(); t2.start(); &#125;&#125; 练习三：打印数字需求： ​ 同时开启两个线程，共同获取1-100之间的所有数字。 ​ 将输出所有的奇数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MyRunable implements Runnable &#123; //第二种方式实现多线程，测试类中MyRunable只创建一次，所以不需要加static int number = 1; @Override public void run() &#123; //1.循环 while (true) &#123; //2.同步代码块 synchronized (MyThread.class) &#123; //3.判断共享数据（已经到末尾） if (number &gt; 100) &#123; break; &#125; else &#123; //4.判断共享数据（没有到末尾） if(number % 2 == 1)&#123; System.out.println(Thread.currentThread().getName() + &quot;打印数字&quot; + number); &#125; number++; &#125; &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; /* 同时开启两个线程，共同获取1-100之间的所有数字。 要求：将输出所有的奇数。 */ //创建参数对象 MyRunable mr = new MyRunable(); //创建线程对象 Thread t1 = new Thread(mr,&quot;线程A&quot;); Thread t2 = new Thread(mr,&quot;线程B&quot;); //启动线程 t1.start(); t2.start(); &#125;&#125; 练习四：抢红包需求： ​ 抢红包也用到了多线程。 ​ 假设：100块，分成了3个包，现在有5个人去抢。 ​ 其中，红包是共享数据。 ​ 5个人是5条线程。 ​ 打印结果如下： ​ XXX抢到了XXX元 ​ XXX抢到了XXX元 XXX抢到了XXX元 XXX没抢到 XXX没抢到 解决方案一： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class MyThread extends Thread&#123; //共享数据 //100块，分成了3个包 static double money = 100; static int count = 3; //最小的中奖金额 static final double MIN = 0.01; @Override public void run() &#123; //同步代码块 synchronized (MyThread.class)&#123; if(count == 0)&#123; //判断，共享数据是否到了末尾（已经到末尾） System.out.println(getName() + &quot;没有抢到红包！&quot;); &#125;else&#123; //判断，共享数据是否到了末尾（没有到末尾） //定义一个变量，表示中奖的金额 double prize = 0; if(count == 1)&#123; //表示此时是最后一个红包 //就无需随机，剩余所有的钱都是中奖金额 prize = money; &#125;else&#123; //表示第一次，第二次（随机） Random r = new Random(); //100 元 3个包 //第一个红包：99.98 //100 - (3-1) * 0.01 double bounds = money - (count - 1) * MIN; prize = r.nextDouble(bounds); if(prize &lt; MIN)&#123; prize = MIN; &#125; &#125; //从money当中，去掉当前中奖的金额 money = money - prize; //红包的个数-1 count--; //本次红包的信息进行打印 System.out.println(getName() + &quot;抢到了&quot; + prize + &quot;元&quot;); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; /* 微信中的抢红包也用到了多线程。 假设：100块，分成了3个包，现在有5个人去抢。 其中，红包是共享数据。 5个人是5条线程。 打印结果如下： XXX抢到了XXX元 XXX抢到了XXX元 XXX抢到了XXX元 XXX没抢到 XXX没抢到 */ //创建线程的对象 MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); MyThread t3 = new MyThread(); MyThread t4 = new MyThread(); MyThread t5 = new MyThread(); //给线程设置名字 t1.setName(&quot;小A&quot;); t2.setName(&quot;小QQ&quot;); t3.setName(&quot;小哈哈&quot;); t4.setName(&quot;小诗诗&quot;); t5.setName(&quot;小丹丹&quot;); //启动线程 t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); &#125;&#125; 解决方案二： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class MyThread extends Thread&#123; //总金额 static BigDecimal money = BigDecimal.valueOf(100.0); //个数 static int count = 3; //最小抽奖金额 static final BigDecimal MIN = BigDecimal.valueOf(0.01); @Override public void run() &#123; synchronized (MyThread.class)&#123; if(count == 0)&#123; System.out.println(getName() + &quot;没有抢到红包！&quot;); &#125;else&#123; //中奖金额 BigDecimal prize; if(count == 1)&#123; prize = money; &#125;else&#123; //获取抽奖范围 double bounds = money.subtract(BigDecimal.valueOf(count-1).multiply(MIN)).doubleValue(); Random r = new Random(); //抽奖金额 prize = BigDecimal.valueOf(r.nextDouble(bounds)); &#125; //设置抽中红包，小数点保留两位，四舍五入 prize = prize.setScale(2,RoundingMode.HALF_UP); //在总金额中去掉对应的钱 money = money.subtract(prize); //红包少了一个 count--; //输出红包信息 System.out.println(getName() + &quot;抽中了&quot; + prize + &quot;元&quot;); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; /* 微信中的抢红包也用到了多线程。 假设：100块，分成了3个包，现在有5个人去抢。 其中，红包是共享数据。 5个人是5条线程。 打印结果如下： XXX抢到了XXX元 XXX抢到了XXX元 XXX抢到了XXX元 XXX没抢到 XXX没抢到 */ MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); MyThread t3 = new MyThread(); MyThread t4 = new MyThread(); MyThread t5 = new MyThread(); t1.setName(&quot;小A&quot;); t2.setName(&quot;小QQ&quot;); t3.setName(&quot;小哈哈&quot;); t4.setName(&quot;小诗诗&quot;); t5.setName(&quot;小丹丹&quot;); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); &#125;&#125; 练习五：抽奖箱需求： ​ 有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 {10,5,20,50,100,200,500,800,2,80,300,700}; 创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2” 随机从抽奖池中获取奖项元素并打印在控制台上,格式如下: ​ 每次抽出一个奖项就打印一个(随机) ​ 抽奖箱1 又产生了一个 10 元大奖 抽奖箱1 又产生了一个 100 元大奖 抽奖箱1 又产生了一个 200 元大奖 抽奖箱1 又产生了一个 800 元大奖 ​ 抽奖箱2 又产生了一个 700 元大奖 ..... 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class MyThread extends Thread &#123; ArrayList&lt;Integer&gt; list; public MyThread(ArrayList&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; //1.循环 //2.同步代码块 //3.判断 //4.判断 while (true) &#123; synchronized (MyThread.class) &#123; if (list.size() == 0) &#123; break; &#125; else &#123; //继续抽奖 Collections.shuffle(list); int prize = list.remove(0); System.out.println(getName() + &quot;又产生了一个&quot; + prize + &quot;元大奖&quot;); &#125; &#125; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; /* 有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;; 创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2” 随机从抽奖池中获取奖项元素并打印在控制台上,格式如下: 每次抽出一个奖项就打印一个(随机) 抽奖箱1 又产生了一个 10 元大奖 抽奖箱1 又产生了一个 100 元大奖 抽奖箱1 又产生了一个 200 元大奖 抽奖箱1 又产生了一个 800 元大奖 抽奖箱2 又产生了一个 700 元大奖 ..... */ //创建奖池 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700); //创建线程 MyThread t1 = new MyThread(list); MyThread t2 = new MyThread(list); //设置名字 t1.setName(&quot;抽奖箱1&quot;); t2.setName(&quot;抽奖箱2&quot;); //启动线程 t1.start(); t2.start(); &#125;&#125; 练习六：多线程统计并求最大值需求： ​ 在上一题基础上继续完成如下需求： ​ 每次抽的过程中，不打印，抽完时一次性打印(随机) ​ 在此次抽奖过程中，抽奖箱1总共产生了6个奖项。 ​ 分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元 ​ 在此次抽奖过程中，抽奖箱2总共产生了6个奖项。 ​ 分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元 解决方案一： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MyThread extends Thread &#123; ArrayList&lt;Integer&gt; list; public MyThread(ArrayList&lt;Integer&gt; list) &#123; this.list = list; &#125; //线程一 static ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); //线程二 static ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(); @Override public void run() &#123; while (true) &#123; synchronized (MyThread.class) &#123; if (list.size() == 0) &#123; if(&quot;抽奖箱1&quot;.equals(getName()))&#123; System.out.println(&quot;抽奖箱1&quot; + list1); &#125;else &#123; System.out.println(&quot;抽奖箱2&quot; + list2); &#125; break; &#125; else &#123; //继续抽奖 Collections.shuffle(list); int prize = list.remove(0); if(&quot;抽奖箱1&quot;.equals(getName()))&#123; list1.add(prize); &#125;else &#123; list2.add(prize); &#125; &#125; &#125; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; /* 有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;; 创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2” 随机从抽奖池中获取奖项元素并打印在控制台上,格式如下: 每次抽的过程中，不打印，抽完时一次性打印(随机) 在此次抽奖过程中，抽奖箱1总共产生了6个奖项。 分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元 在此次抽奖过程中，抽奖箱2总共产生了6个奖项。 分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元 */ //创建奖池 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700); //创建线程 MyThread t1 = new MyThread(list); MyThread t2 = new MyThread(list); //设置名字 t1.setName(&quot;抽奖箱1&quot;); t2.setName(&quot;抽奖箱2&quot;); //启动线程 t1.start(); t2.start(); &#125;&#125; 解决方案二： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MyThread extends Thread &#123; ArrayList&lt;Integer&gt; list; public MyThread(ArrayList&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override public void run() &#123; ArrayList&lt;Integer&gt; boxList = new ArrayList&lt;&gt;();//1 //2 while (true) &#123; synchronized (MyThread.class) &#123; if (list.size() == 0) &#123; System.out.println(getName() + boxList); break; &#125; else &#123; //继续抽奖 Collections.shuffle(list); int prize = list.remove(0); boxList.add(prize); &#125; &#125; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; /* 有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;; 创建两个抽奖箱(线程)设置线程名称分别为“抽奖箱1”，“抽奖箱2” 随机从抽奖池中获取奖项元素并打印在控制台上,格式如下: 每次抽的过程中，不打印，抽完时一次性打印(随机) 在此次抽奖过程中，抽奖箱1总共产生了6个奖项。 分别为：10,20,100,500,2,300最高奖项为300元，总计额为932元 在此次抽奖过程中，抽奖箱2总共产生了6个奖项。 分别为：5,50,200,800,80,700最高奖项为800元，总计额为1835元 */ //创建奖池 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700); //创建线程 MyThread t1 = new MyThread(list); MyThread t2 = new MyThread(list); //设置名字 t1.setName(&quot;抽奖箱1&quot;); t2.setName(&quot;抽奖箱2&quot;); //启动线程 t1.start(); t2.start(); &#125;&#125; 练习七：多线程之间的比较需求： ​ 在上一题基础上继续完成如下需求： ​ 在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300 最高奖项为300元，总计额为932元 ​ 在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700 最高奖项为800元，总计额为1835元 ​ 在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元 ​ 以上打印效果只是数据模拟,实际代码运行的效果会有差异 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107public class MyCallable implements Callable&lt;Integer&gt; &#123; ArrayList&lt;Integer&gt; list; public MyCallable(ArrayList&lt;Integer&gt; list) &#123; this.list = list; &#125; @Override public Integer call() throws Exception &#123; ArrayList&lt;Integer&gt; boxList = new ArrayList&lt;&gt;();//1 //2 while (true) &#123; synchronized (MyCallable.class) &#123; if (list.size() == 0) &#123; System.out.println(Thread.currentThread().getName() + boxList); break; &#125; else &#123; //继续抽奖 Collections.shuffle(list); int prize = list.remove(0); boxList.add(prize); &#125; &#125; Thread.sleep(10); &#125; //把集合中的最大值返回 if(boxList.size() == 0)&#123; return null; &#125;else&#123; return Collections.max(boxList); &#125; &#125;&#125;package com.itheima.test7;import java.util.ArrayList;import java.util.Collections;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; /* 有一个抽奖池,该抽奖池中存放了奖励的金额,该抽奖池中的奖项为 &#123;10,5,20,50,100,200,500,800,2,80,300,700&#125;; 创建两个抽奖箱(线程)设置线程名称分别为 &quot;抽奖箱1&quot;, &quot;抽奖箱2&quot; 随机从抽奖池中获取奖项元素并打印在控制台上,格式如下: 在此次抽奖过程中，抽奖箱1总共产生了6个奖项，分别为：10,20,100,500,2,300 最高奖项为300元，总计额为932元 在此次抽奖过程中，抽奖箱2总共产生了6个奖项，分别为：5,50,200,800,80,700 最高奖项为800元，总计额为1835元 在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元 核心逻辑：获取线程抽奖的最大值（看成是线程运行的结果） 以上打印效果只是数据模拟,实际代码运行的效果会有差异 */ //创建奖池 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Collections.addAll(list,10,5,20,50,100,200,500,800,2,80,300,700); //创建多线程要运行的参数对象 MyCallable mc = new MyCallable(list); //创建多线程运行结果的管理者对象 //线程一 FutureTask&lt;Integer&gt; ft1 = new FutureTask&lt;&gt;(mc); //线程二 FutureTask&lt;Integer&gt; ft2 = new FutureTask&lt;&gt;(mc); //创建线程对象 Thread t1 = new Thread(ft1); Thread t2 = new Thread(ft2); //设置名字 t1.setName(&quot;抽奖箱1&quot;); t2.setName(&quot;抽奖箱2&quot;); //开启线程 t1.start(); t2.start(); Integer max1 = ft1.get(); Integer max2 = ft2.get(); System.out.println(max1); System.out.println(max2); //在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为800元 if(max1 == null)&#123; System.out.println(&quot;在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为&quot;+max2+&quot;元&quot;); &#125;else if(max2 == null)&#123; System.out.println(&quot;在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为&quot;+max1+&quot;元&quot;); &#125;else if(max1 &gt; max2)&#123; System.out.println(&quot;在此次抽奖过程中,抽奖箱1中产生了最大奖项,该奖项金额为&quot;+max1+&quot;元&quot;); &#125;else if(max1 &lt; max2)&#123; System.out.println(&quot;在此次抽奖过程中,抽奖箱2中产生了最大奖项,该奖项金额为&quot;+max2+&quot;元&quot;); &#125;else&#123; System.out.println(&quot;两者的最大奖项是一样的&quot;); &#125; &#125;&#125; 2. 原子性2.1 volatile-问题代码分析 : 12345678910111213package com.itheima.myvolatile;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); t1.setName(&quot;小路同学&quot;); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(&quot;小皮同学&quot;); t2.start(); &#125;&#125; 12345package com.itheima.myvolatile;public class Money &#123; public static int money = 100000;&#125; 12345678910111213package com.itheima.myvolatile;public class MyThread1 extends Thread &#123; @Override public void run() &#123; while(Money.money == 100000)&#123; &#125; System.out.println(&quot;结婚基金已经不是十万了&quot;); &#125;&#125; 123456789101112131415package com.itheima.myvolatile;public class MyThread2 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Money.money = 90000; &#125;&#125; 程序问题 : 女孩虽然知道结婚基金是十万，但是当基金的余额发生变化的时候，女孩无法知道最新的余额。 2.2 volatile解决以上案例出现的问题 : ​ 当A线程修改了共享数据时，B线程没有及时获取到最新的值，如果还在使用原先的值，就会出现问题 ​ 1，堆内存是唯一的，每一个线程都有自己的线程栈。 ​ 2 ，每一个线程在使用堆里面变量的时候，都会先拷贝一份到变量的副本中。 ​ 3 ，在线程中，每一次使用是从变量的副本中获取的。 Volatile关键字 : 强制线程每次在使用的时候，都会看一下共享区域最新的值 代码实现 : 使用volatile关键字解决 12345678910111213package com.itheima.myvolatile;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); t1.setName(&quot;小路同学&quot;); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(&quot;小皮同学&quot;); t2.start(); &#125;&#125; 12345package com.itheima.myvolatile;public class Money &#123; public static volatile int money = 100000;&#125; 12345678910111213package com.itheima.myvolatile;public class MyThread1 extends Thread &#123; @Override public void run() &#123; while(Money.money == 100000)&#123; &#125; System.out.println(&quot;结婚基金已经不是十万了&quot;); &#125;&#125; 123456789101112131415package com.itheima.myvolatile;public class MyThread2 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Money.money = 90000; &#125;&#125; 2.3 synchronized解决synchronized解决 : ​ 1 ，线程获得锁 ​ 2 ，清空变量副本 ​ 3 ，拷贝共享变量最新的值到变量副本中 ​ 4 ，执行代码 ​ 5 ，将修改后变量副本中的值赋值给共享数据 ​ 6 ，释放锁 代码实现 : 12345678910111213package com.itheima.myvolatile2;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); t1.setName(&quot;小路同学&quot;); t1.start(); MyThread2 t2 = new MyThread2(); t2.setName(&quot;小皮同学&quot;); t2.start(); &#125;&#125; 123456package com.itheima.myvolatile2;public class Money &#123; public static Object lock = new Object(); public static volatile int money = 100000;&#125; 123456789101112131415package com.itheima.myvolatile2;public class MyThread1 extends Thread &#123; @Override public void run() &#123; while(true)&#123; synchronized (Money.lock)&#123; if(Money.money != 100000)&#123; System.out.println(&quot;结婚基金已经不是十万了&quot;); break; &#125; &#125; &#125; &#125;&#125; 12345678910111213141516package com.itheima.myvolatile2;public class MyThread2 extends Thread &#123; @Override public void run() &#123; synchronized (Money.lock) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Money.money = 90000; &#125; &#125;&#125; 2.4 原子性概述 : 所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行，多个操作是一个不可以分割的整体。 代码实现 : 12345678910111213141516171819202122232425package com.itheima.threadatom;public class AtomDemo &#123; public static void main(String[] args) &#123; MyAtomThread atom = new MyAtomThread(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(atom).start(); &#125; &#125;&#125;class MyAtomThread implements Runnable &#123; private volatile int count = 0; //送冰淇淋的数量 @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; //1,从共享数据中读取数据到本线程栈中. //2,修改本线程栈中变量副本的值 //3,会把本线程栈中变量副本的值赋值给共享数据. count++; System.out.println(&quot;已经送了&quot; + count + &quot;个冰淇淋&quot;); &#125; &#125;&#125; 代码总结 : count++ 不是一个原子性操作, 他在执行的过程中,有可能被其他线程打断 2.5 volatile关键字不能保证原子性解决方案 : 我们可以给count++操作添加锁，那么count++操作就是临界区中的代码，临界区中的代码一次只能被一个线程去执行，所以count++就变成了原子操作。 12345678910111213141516171819202122232425262728package com.itheima.threadatom2;public class AtomDemo &#123; public static void main(String[] args) &#123; MyAtomThread atom = new MyAtomThread(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(atom).start(); &#125; &#125;&#125;class MyAtomThread implements Runnable &#123; private volatile int count = 0; //送冰淇淋的数量 private Object lock = new Object(); @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; //1,从共享数据中读取数据到本线程栈中. //2,修改本线程栈中变量副本的值 //3,会把本线程栈中变量副本的值赋值给共享数据. synchronized (lock) &#123; count++; System.out.println(&quot;已经送了&quot; + count + &quot;个冰淇淋&quot;); &#125; &#125; &#125;&#125; 2.6 原子性_AtomicInteger概述：java从JDK1.5开始提供了java.util.concurrent.atomic包(简称Atomic包)，这个包中的原子操作类提供了一种用法简单，性能高效，线程安全地更新一个变量的方式。因为变 量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性(字段)。本次我们只讲解 使用原子的方式更新基本类型，使用原子的方式更新基本类型Atomic包提供了以下3个类： AtomicBoolean： 原子更新布尔类型 AtomicInteger： 原子更新整型 AtomicLong： 原子更新长整型 以上3个类提供的方法几乎一模一样，所以本节仅以AtomicInteger为例进行讲解，AtomicInteger的常用方法如下： 12345678public AtomicInteger()： 初始化一个默认值为0的原子型Integerpublic AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integerint get(): 获取值int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。int addAndGet(int data): 以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 代码实现 : 12345678910111213141516package com.itheima.threadatom3;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomIntergerDemo1 &#123;// public AtomicInteger()： 初始化一个默认值为0的原子型Integer// public AtomicInteger(int initialValue)： 初始化一个指定值的原子型Integer public static void main(String[] args) &#123; AtomicInteger ac = new AtomicInteger(); System.out.println(ac); AtomicInteger ac2 = new AtomicInteger(10); System.out.println(ac2); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536package com.itheima.threadatom3;import java.lang.reflect.Field;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomIntergerDemo2 &#123;// int get(): 获取值// int getAndIncrement(): 以原子方式将当前值加1，注意，这里返回的是自增前的值。// int incrementAndGet(): 以原子方式将当前值加1，注意，这里返回的是自增后的值。// int addAndGet(int data): 以原子方式将参数与对象中的值相加，并返回结果。// int getAndSet(int value): 以原子方式设置为newValue的值，并返回旧值。 public static void main(String[] args) &#123;// AtomicInteger ac1 = new AtomicInteger(10);// System.out.println(ac1.get());// AtomicInteger ac2 = new AtomicInteger(10);// int andIncrement = ac2.getAndIncrement();// System.out.println(andIncrement);// System.out.println(ac2.get());// AtomicInteger ac3 = new AtomicInteger(10);// int i = ac3.incrementAndGet();// System.out.println(i);//自增后的值// System.out.println(ac3.get());// AtomicInteger ac4 = new AtomicInteger(10);// int i = ac4.addAndGet(20);// System.out.println(i);// System.out.println(ac4.get()); AtomicInteger ac5 = new AtomicInteger(100); int andSet = ac5.getAndSet(20); System.out.println(andSet); System.out.println(ac5.get()); &#125;&#125; 2.7 AtomicInteger-内存解析AtomicInteger原理 : 自旋锁 + CAS 算法 CAS算法： ​ 有3个操作数（内存值V， 旧的预期值A，要修改的值B） ​ 当旧的预期值A &#x3D;&#x3D; 内存值 此时修改成功，将V改为B ​ 当旧的预期值A！&#x3D;内存值 此时修改失败，不做任何操作 ​ 并重新获取现在的最新值（这个重新获取的动作就是自旋） 2.8 AtomicInteger-源码解析代码实现 : 1234567891011package com.itheima.threadatom4;public class AtomDemo &#123; public static void main(String[] args) &#123; MyAtomThread atom = new MyAtomThread(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(atom).start(); &#125; &#125;&#125; 12345678910111213141516171819202122232425package com.itheima.threadatom4;import java.util.concurrent.atomic.AtomicInteger;public class MyAtomThread implements Runnable &#123; //private volatile int count = 0; //送冰淇淋的数量 //private Object lock = new Object(); AtomicInteger ac = new AtomicInteger(0); @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; //1,从共享数据中读取数据到本线程栈中. //2,修改本线程栈中变量副本的值 //3,会把本线程栈中变量副本的值赋值给共享数据. //synchronized (lock) &#123;// count++;// ac++; int count = ac.incrementAndGet(); System.out.println(&quot;已经送了&quot; + count + &quot;个冰淇淋&quot;); // &#125; &#125; &#125;&#125; 源码解析 : 123456789101112131415161718192021222324252627//先自增，然后获取自增后的结果public final int incrementAndGet() &#123; //+ 1 自增后的结果 //this 就表示当前的atomicInteger（值） //1 自增一次 return U.getAndAddInt(this, VALUE, 1) + 1;&#125;public final int getAndAddInt(Object o, long offset, int delta) &#123; //v 旧值 int v; //自旋的过程 do &#123; //不断的获取旧值 v = getIntVolatile(o, offset); //如果这个方法的返回值为false，那么继续自旋 //如果这个方法的返回值为true，那么自旋结束 //o 表示的就是内存值 //v 旧值 //v + delta 修改后的值 &#125; while (!weakCompareAndSetInt(o, offset, v, v + delta)); //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true。表示修改成功。 // 如果不相等，无法把修改后的值写到内存中，返回false。表示修改失败。 //如果修改失败，那么继续自旋。 return v;&#125; 2.9 悲观锁和乐观锁synchronized和CAS的区别 : 相同点：在多线程情况下，都可以保证共享数据的安全性。 不同点：synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改。所以在每 次操作共享数据之前，都会上锁。（悲观锁） ​ cas是从乐观的角度出发，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。 ​ 如果别人修改过，那么我再次获取现在最新的值。 ​ 如果别人没有修改过，那么我现在直接修改共享数据的值.(乐观锁） 3. 并发工具类3.1 并发工具类-Hashtable​ Hashtable出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。 代码实现 : 1234567891011121314151617181920212223242526272829303132333435363738package com.itheima.mymap;import java.util.HashMap;import java.util.Hashtable;public class MyHashtableDemo &#123; public static void main(String[] args) throws InterruptedException &#123; Hashtable&lt;String, String&gt; hm = new Hashtable&lt;&gt;(); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 25; i++) &#123; hm.put(i + &quot;&quot;, i + &quot;&quot;); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 25; i &lt; 51; i++) &#123; hm.put(i + &quot;&quot;, i + &quot;&quot;); &#125; &#125;); t1.start(); t2.start(); System.out.println(&quot;----------------------------&quot;); //为了t1和t2能把数据全部添加完毕 Thread.sleep(1000); //0-0 1-1 ..... 50- 50 for (int i = 0; i &lt; 51; i++) &#123; System.out.println(hm.get(i + &quot;&quot;)); &#125;//0 1 2 3 .... 50 &#125;&#125; 3.2 并发工具类-ConcurrentHashMap基本使用​ ConcurrentHashMap出现的原因 : 在集合类中HashMap是比较常用的集合对象，但是HashMap是线程不安全的(多线程环境下可能会存在问题)。为了保证数据的安全性我们可以使用Hashtable，但是Hashtable的效率低下。 基于以上两个原因我们可以使用JDK1.5以后所提供的ConcurrentHashMap。 体系结构 : 总结 : ​ 1 ，HashMap是线程不安全的。多线程环境下会有数据安全问题 ​ 2 ，Hashtable是线程安全的，但是会将整张表锁起来，效率低下 ​ 3，ConcurrentHashMap也是线程安全的，效率较高。 在JDK7和JDK8中，底层原理不一样。 代码实现 : 123456789101112131415161718192021222324252627282930313233343536package com.itheima.mymap;import java.util.Hashtable;import java.util.concurrent.ConcurrentHashMap;public class MyConcurrentHashMapDemo &#123; public static void main(String[] args) throws InterruptedException &#123; ConcurrentHashMap&lt;String, String&gt; hm = new ConcurrentHashMap&lt;&gt;(100); Thread t1 = new Thread(() -&gt; &#123; for (int i = 0; i &lt; 25; i++) &#123; hm.put(i + &quot;&quot;, i + &quot;&quot;); &#125; &#125;); Thread t2 = new Thread(() -&gt; &#123; for (int i = 25; i &lt; 51; i++) &#123; hm.put(i + &quot;&quot;, i + &quot;&quot;); &#125; &#125;); t1.start(); t2.start(); System.out.println(&quot;----------------------------&quot;); //为了t1和t2能把数据全部添加完毕 Thread.sleep(1000); //0-0 1-1 ..... 50- 50 for (int i = 0; i &lt; 51; i++) &#123; System.out.println(hm.get(i + &quot;&quot;)); &#125;//0 1 2 3 .... 50 &#125;&#125; 3.3 并发工具类-ConcurrentHashMap1.7原理 3.4 并发工具类-ConcurrentHashMap1.8原理 总结 : ​ 1，如果使用空参构造创建ConcurrentHashMap对象，则什么事情都不做。 在第一次添加元素的时候创建哈希表 ​ 2，计算当前元素应存入的索引。 ​ 3，如果该索引位置为null，则利用cas算法，将本结点添加到数组中。 ​ 4，如果该索引位置不为null，则利用volatile关键字获得当前位置最新的结点地址，挂在他下面，变成链表。 ​ 5，当链表的长度大于等于8时，自动转换成红黑树6，以链表或者红黑树头结点为锁对象，配合悲观锁保证多线程操作集合时数据的安全性 3.5 并发工具类-CountDownLatchCountDownLatch类 : 方法 解释 public CountDownLatch(int count) 参数传递线程数，表示等待线程数量 public void await() 让线程等待 public void countDown() 当前线程执行完毕 使用场景： 让某一条线程等待其他线程执行完毕之后再执行 代码实现 : 1234567891011121314151617181920212223package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread1 extends Thread &#123; private CountDownLatch countDownLatch; public ChileThread1(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.吃饺子 for (int i = 1; i &lt;= 10; i++) &#123; System.out.println(getName() + &quot;在吃第&quot; + i + &quot;个饺子&quot;); &#125; //2.吃完说一声 //每一次countDown方法的时候，就让计数器-1 countDownLatch.countDown(); &#125;&#125; 12345678910111213141516171819202122package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread2 extends Thread &#123; private CountDownLatch countDownLatch; public ChileThread2(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.吃饺子 for (int i = 1; i &lt;= 15; i++) &#123; System.out.println(getName() + &quot;在吃第&quot; + i + &quot;个饺子&quot;); &#125; //2.吃完说一声 //每一次countDown方法的时候，就让计数器-1 countDownLatch.countDown(); &#125;&#125; 12345678910111213141516171819202122package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class ChileThread3 extends Thread &#123; private CountDownLatch countDownLatch; public ChileThread3(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.吃饺子 for (int i = 1; i &lt;= 20; i++) &#123; System.out.println(getName() + &quot;在吃第&quot; + i + &quot;个饺子&quot;); &#125; //2.吃完说一声 //每一次countDown方法的时候，就让计数器-1 countDownLatch.countDown(); &#125;&#125; 123456789101112131415161718192021222324package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class MotherThread extends Thread &#123; private CountDownLatch countDownLatch; public MotherThread(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; //1.等待 try &#123; //当计数器变成0的时候，会自动唤醒这里等待的线程。 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //2.收拾碗筷 System.out.println(&quot;妈妈在收拾碗筷&quot;); &#125;&#125; 123456789101112131415161718192021222324252627package com.itheima.mycountdownlatch;import java.util.concurrent.CountDownLatch;public class MyCountDownLatchDemo &#123; public static void main(String[] args) &#123; //1.创建CountDownLatch的对象，需要传递给四个线程。 //在底层就定义了一个计数器，此时计数器的值就是3 CountDownLatch countDownLatch = new CountDownLatch(3); //2.创建四个线程对象并开启他们。 MotherThread motherThread = new MotherThread(countDownLatch); motherThread.start(); ChileThread1 t1 = new ChileThread1(countDownLatch); t1.setName(&quot;小明&quot;); ChileThread2 t2 = new ChileThread2(countDownLatch); t2.setName(&quot;小红&quot;); ChileThread3 t3 = new ChileThread3(countDownLatch); t3.setName(&quot;小刚&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 总结 : ​ 1. CountDownLatch(int count)：参数写等待线程的数量。并定义了一个计数器。 ​ 2. await()：让线程等待，当计数器为0时，会唤醒等待的线程 ​ 3. countDown()： 线程执行完毕时调用，会将计数器-1。 3.6 并发工具类-Semaphore使用场景 : ​ 可以控制访问特定资源的线程数量。 实现步骤 : ​ 1，需要有人管理这个通道 ​ 2，当有车进来了，发通行许可证 ​ 3，当车出去了，收回通行许可证 ​ 4，如果通行许可证发完了，那么其他车辆只能等着 代码实现 : 123456789101112131415161718192021222324package com.itheima.mysemaphore;import java.util.concurrent.Semaphore;public class MyRunnable implements Runnable &#123; //1.获得管理员对象， private Semaphore semaphore = new Semaphore(2); @Override public void run() &#123; //2.获得通行证 try &#123; semaphore.acquire(); //3.开始行驶 System.out.println(&quot;获得了通行证开始行驶&quot;); Thread.sleep(2000); System.out.println(&quot;归还通行证&quot;); //4.归还通行证 semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011package com.itheima.mysemaphore;public class MySemaphoreDemo &#123; public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); for (int i = 0; i &lt; 100; i++) &#123; new Thread(mr).start(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"多线程01","slug":"31、多线程01","date":"2022-06-16T01:00:00.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"31、多线程01.html","link":"","permalink":"https://iexlee.github.io/31%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B01.html","excerpt":"","text":"1.实现多线程1.1简单了解多线程【理解】是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多个线程，提升性能。 1.2并发和并行【理解】 并行：在同一时刻，有多个指令在多个CPU上同时执行。 并发：在同一时刻，有多个指令在单个CPU上交替执行。 1.3进程和线程【理解】 进程：是正在运行的程序 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的并发性：任何进程都可以同其他进程一起并发执行 线程：是进程中的单个顺序控制流，是一条执行路径 ​ 单线程：一个进程如果只有一条执行路径，则称为单线程程序 ​ 多线程：一个进程如果有多条执行路径，则称为多线程程序 ​ 1.4实现多线程方式一：继承Thread类【应用】 方法介绍 方法名 说明 void run() 在线程开启后，此方法将被调用执行 void start() 使此线程开始执行，Java虚拟机会调用run方法() 实现步骤 定义一个类MyThread继承Thread类 在MyThread类中重写run()方法 创建MyThread类的对象 启动线程 代码演示 123456789101112131415161718192021public class MyThread extends Thread &#123; @Override public void run() &#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(i); &#125; &#125;&#125;public class MyThreadDemo &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); MyThread my2 = new MyThread();// my1.run();// my2.run(); //void start() 导致此线程开始执行; Java虚拟机调用此线程的run方法 my1.start(); my2.start(); &#125;&#125; 两个小问题 为什么要重写run()方法？ 因为run()是用来封装被线程执行的代码 run()方法和start()方法的区别？ run()：封装线程执行的代码，直接调用，相当于普通方法的调用 start()：启动线程；然后由JVM调用此线程的run()方法 1.5实现多线程方式二：实现Runnable接口【应用】 Thread构造方法 方法名 说明 Thread(Runnable target) 分配一个新的Thread对象 Thread(Runnable target, String name) 分配一个新的Thread对象 实现步骤 定义一个类MyRunnable实现Runnable接口 在MyRunnable类中重写run()方法 创建MyRunnable类的对象 创建Thread类的对象，把MyRunnable对象作为构造方法的参数 启动线程 代码演示 1234567891011121314151617181920212223242526public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for(int i=0; i&lt;100; i++) &#123; System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i); &#125; &#125;&#125;public class MyRunnableDemo &#123; public static void main(String[] args) &#123; //创建MyRunnable类的对象 MyRunnable my = new MyRunnable(); //创建Thread类的对象，把MyRunnable对象作为构造方法的参数 //Thread(Runnable target)// Thread t1 = new Thread(my);// Thread t2 = new Thread(my); //Thread(Runnable target, String name) Thread t1 = new Thread(my,&quot;坦克&quot;); Thread t2 = new Thread(my,&quot;飞机&quot;); //启动线程 t1.start(); t2.start(); &#125;&#125; 1.6实现多线程方式三: 实现Callable接口【应用】 方法介绍 方法名 说明 V call() 计算结果，如果无法计算结果，则抛出一个异常 FutureTask(Callable callable) 创建一个 FutureTask，一旦运行就执行给定的 Callable V get() 如有必要，等待计算完成，然后获取其结果 实现步骤 定义一个类MyCallable实现Callable接口 在MyCallable类中重写call()方法 创建MyCallable类的对象 创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数 创建Thread类的对象，把FutureTask对象作为构造方法的参数 启动线程 再调用get方法，就可以获取线程结束之后的结果。 代码演示 12345678910111213141516171819202122232425262728293031public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(&quot;跟女孩表白&quot; + i); &#125; //返回值就表示线程运行完毕之后的结果 return &quot;答应&quot;; &#125;&#125;public class Demo &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //线程开启之后需要执行里面的call方法 MyCallable mc = new MyCallable(); //Thread t1 = new Thread(mc); //可以获取线程执行完毕之后的结果.也可以作为参数传递给Thread对象 FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc); //创建线程对象 Thread t1 = new Thread(ft); String s = ft.get(); //开启线程 t1.start(); //String s = ft.get(); System.out.println(s); &#125;&#125; 三种实现方式的对比 实现Runnable、Callable接口 好处: 扩展性强，实现该接口的同时还可以继承其他的类 缺点: 编程相对复杂，不能直接使用Thread类中的方法 继承Thread类 好处: 编程比较简单，可以直接使用Thread类中的方法 缺点: 可以扩展性较差，不能再继承其他的类 1.7设置和获取线程名称【应用】 方法介绍 方法名 说明 void setName(String name) 将此线程的名称更改为等于参数name String getName() 返回此线程的名称 Thread currentThread() 返回对当前正在执行的线程对象的引用 代码演示 123456789101112131415161718192021222324252627282930313233public class MyThread extends Thread &#123; public MyThread() &#123;&#125; public MyThread(String name) &#123; super(name); &#125; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(getName()+&quot;:&quot;+i); &#125; &#125;&#125;public class MyThreadDemo &#123; public static void main(String[] args) &#123; MyThread my1 = new MyThread(); MyThread my2 = new MyThread(); //void setName(String name)：将此线程的名称更改为等于参数 name my1.setName(&quot;高铁&quot;); my2.setName(&quot;飞机&quot;); //Thread(String name) MyThread my1 = new MyThread(&quot;高铁&quot;); MyThread my2 = new MyThread(&quot;飞机&quot;); my1.start(); my2.start(); //static Thread currentThread() 返回对当前正在执行的线程对象的引用 System.out.println(Thread.currentThread().getName()); &#125;&#125; 1.8线程休眠【应用】 相关方法 方法名 说明 static void sleep(long millis) 使当前正在执行的线程停留（暂停执行）指定的毫秒数 代码演示 1234567891011121314151617181920212223242526272829public class MyRunnable implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;---&quot; + i); &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) throws InterruptedException &#123; /*System.out.println(&quot;睡觉前&quot;); Thread.sleep(3000); System.out.println(&quot;睡醒了&quot;);*/ MyRunnable mr = new MyRunnable(); Thread t1 = new Thread(mr); Thread t2 = new Thread(mr); t1.start(); t2.start(); &#125;&#125; 1.9线程优先级【应用】 线程调度 两种调度方式 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些 Java使用的是抢占式调度模型 随机性 假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到CPU时间片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到CPU的使用权是不一定的 优先级相关方法 方法名 说明 final int getPriority() 返回此线程的优先级 final void setPriority(int newPriority) 更改此线程的优先级线程默认优先级是5；线程优先级的范围是：1-10 代码演示 123456789101112131415161718192021222324252627282930313233public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot;---&quot; + i); &#125; return &quot;线程执行完毕了&quot;; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; //优先级: 1 - 10 默认值:5 MyCallable mc = new MyCallable(); FutureTask&lt;String&gt; ft = new FutureTask&lt;&gt;(mc); Thread t1 = new Thread(ft); t1.setName(&quot;飞机&quot;); t1.setPriority(10); //System.out.println(t1.getPriority());//5 t1.start(); MyCallable mc2 = new MyCallable(); FutureTask&lt;String&gt; ft2 = new FutureTask&lt;&gt;(mc2); Thread t2 = new Thread(ft2); t2.setName(&quot;坦克&quot;); t2.setPriority(1); //System.out.println(t2.getPriority());//5 t2.start(); &#125;&#125; 1.10守护线程【应用】 相关方法 方法名 说明 void setDaemon(boolean on) 将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出 代码演示 1234567891011121314151617181920212223242526272829303132public class MyThread1 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + &quot;---&quot; + i); &#125; &#125;&#125;public class MyThread2 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(getName() + &quot;---&quot; + i); &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; MyThread1 t1 = new MyThread1(); MyThread2 t2 = new MyThread2(); t1.setName(&quot;女神&quot;); t2.setName(&quot;备胎&quot;); //把第二个线程设置为守护线程 //当普通线程执行完之后,那么守护线程也没有继续运行下去的必要了. t2.setDaemon(true); t1.start(); t2.start(); &#125;&#125; 2.线程同步2.1卖票【应用】 案例需求 某电影院目前正在上映国产大片，共有100张票，而它有3个窗口卖票，请设计一个程序模拟该电影院卖票 实现步骤 定义一个类SellTicket实现Runnable接口，里面定义一个成员变量：private int tickets &#x3D; 100; 在SellTicket类中重写run()方法实现卖票，代码步骤如下 判断票数大于0，就卖票，并告知是哪个窗口卖的 卖了票之后，总票数要减1 票卖没了，线程停止 定义一个测试类SellTicketDemo，里面有main方法，代码步骤如下 创建SellTicket类的对象 创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 启动线程 代码实现 12345678910111213141516171819202122232425262728293031323334353637public class SellTicket implements Runnable &#123; private int tickets = 100; //在SellTicket类中重写run()方法实现卖票，代码步骤如下 @Override public void run() &#123; while (true) &#123; if(ticket &lt;= 0)&#123; //卖完了 break; &#125;else&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ticket--; System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticket + &quot;张票&quot;); &#125; &#125; &#125;&#125;public class SellTicketDemo &#123; public static void main(String[] args) &#123; //创建SellTicket类的对象 SellTicket st = new SellTicket(); //创建三个Thread类的对象，把SellTicket对象作为构造方法的参数，并给出对应的窗口名称 Thread t1 = new Thread(st,&quot;窗口1&quot;); Thread t2 = new Thread(st,&quot;窗口2&quot;); Thread t3 = new Thread(st,&quot;窗口3&quot;); //启动线程 t1.start(); t2.start(); t3.start(); &#125;&#125; 2.2卖票案例的问题【理解】 卖票出现了问题 相同的票出现了多次 出现了负数的票 问题产生原因 线程执行的随机性导致的,可能在卖票过程中丢失cpu的执行权,导致出现问题 2.3同步代码块解决数据安全问题【应用】 安全问题出现的条件 是多线程环境 有共享数据 有多条语句操作共享数据 如何解决多线程安全问题呢? 基本思想：让程序没有安全问题的环境 怎么实现呢? 把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可 Java提供了同步代码块的方式来解决 同步代码块格式： 123synchronized(任意对象) &#123; 多条语句操作共享数据的代码 &#125; synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁 同步的好处和弊端 好处：解决了多线程的数据安全问题 弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率 代码演示 123456789101112131415161718192021222324252627282930313233343536373839public class SellTicket implements Runnable &#123; private int tickets = 100; private Object obj = new Object(); @Override public void run() &#123; while (true) &#123; synchronized (obj) &#123; // 对可能有安全问题的代码加锁,多个线程必须使用同一把锁 //t1进来后，就会把这段代码给锁起来 if (tickets &gt; 0) &#123; try &#123; Thread.sleep(100); //t1休息100毫秒 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //窗口1正在出售第100张票 System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + tickets + &quot;张票&quot;); tickets--; //tickets = 99; &#125; &#125; //t1出来了，这段代码的锁就被释放了 &#125; &#125;&#125;public class SellTicketDemo &#123; public static void main(String[] args) &#123; SellTicket st = new SellTicket(); Thread t1 = new Thread(st, &quot;窗口1&quot;); Thread t2 = new Thread(st, &quot;窗口2&quot;); Thread t3 = new Thread(st, &quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125;&#125; 2.4同步方法解决数据安全问题【应用】 同步方法的格式 同步方法：就是把synchronized关键字加到方法上 123修饰符 synchronized 返回值类型 方法名(方法参数) &#123; 方法体；&#125; 同步方法的锁对象是什么呢? ​ this 静态同步方法 同步静态方法：就是把synchronized关键字加到静态方法上 123修饰符 static synchronized 返回值类型 方法名(方法参数) &#123; 方法体；&#125; 同步静态方法的锁对象是什么呢? ​ 类名.class 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyRunnable implements Runnable &#123; private static int ticketCount = 100; @Override public void run() &#123; while(true)&#123; if(&quot;窗口一&quot;.equals(Thread.currentThread().getName()))&#123; //同步方法 boolean result = synchronizedMthod(); if(result)&#123; break; &#125; &#125; if(&quot;窗口二&quot;.equals(Thread.currentThread().getName()))&#123; //同步代码块 synchronized (MyRunnable.class)&#123; if(ticketCount == 0)&#123; break; &#125;else&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ticketCount--; System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticketCount + &quot;张票&quot;); &#125; &#125; &#125; &#125; &#125; private static synchronized boolean synchronizedMthod() &#123; if(ticketCount == 0)&#123; return true; &#125;else&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; ticketCount--; System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticketCount + &quot;张票&quot;); return false; &#125; &#125;&#125; public class Demo {public static void main(String[] args) { MyRunnable mr &#x3D; new MyRunnable(); Thread t1 &#x3D; new Thread(mr); Thread t2 &#x3D; new Thread(mr); t1.setName(“窗口一”); t2.setName(“窗口二”); t1.start(); t2.start();}} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071### 2.5Lock锁【应用】虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象LockLock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化- ReentrantLock构造方法 | 方法名 | 说明 | | --------------- | -------------------- | | ReentrantLock() | 创建一个ReentrantLock的实例 |- 加锁解锁方法 | 方法名 | 说明 | | ------------- | ---- | | void lock() | 获得锁 | | void unlock() | 释放锁 |- 代码演示 ```java public class Ticket implements Runnable &#123; //票的数量 private int ticket = 100; private Object obj = new Object(); private ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; //synchronized (obj)&#123;//多个线程必须使用同一把锁. try &#123; lock.lock(); if (ticket &lt;= 0) &#123; //卖完了 break; &#125; else &#123; Thread.sleep(100); ticket--; System.out.println(Thread.currentThread().getName() + &quot;在卖票,还剩下&quot; + ticket + &quot;张票&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; // &#125; &#125; &#125; &#125; public class Demo &#123; public static void main(String[] args) &#123; Ticket ticket = new Ticket(); Thread t1 = new Thread(ticket); Thread t2 = new Thread(ticket); Thread t3 = new Thread(ticket); t1.setName(&quot;窗口一&quot;); t2.setName(&quot;窗口二&quot;); t3.setName(&quot;窗口三&quot;); t1.start(); t2.start(); t3.start(); &#125; &#125; 2.6死锁【理解】 概述 线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行 什么情况下会产生死锁 资源有限 同步嵌套 代码演示 12345678910111213141516171819202122232425262728public class Demo &#123; public static void main(String[] args) &#123; Object objA = new Object(); Object objB = new Object(); new Thread(()-&gt;&#123; while(true)&#123; synchronized (objA)&#123; //线程一 synchronized (objB)&#123; System.out.println(&quot;小康同学正在走路&quot;); &#125; &#125; &#125; &#125;).start(); new Thread(()-&gt;&#123; while(true)&#123; synchronized (objB)&#123; //线程二 synchronized (objA)&#123; System.out.println(&quot;小薇同学正在走路&quot;); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 3.生产者消费者3.1生产者和消费者模式概述【应用】 概述 生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程编程的理解更加深刻。 所谓生产者消费者问题，实际上主要是包含了两类线程： ​ 一类是生产者线程用于生产数据 ​ 一类是消费者线程用于消费数据 为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库 生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为 消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为 Object类的等待和唤醒方法 方法名 说明 void wait() 导致当前线程等待，直到另一个线程调用该对象的 notify()方法或 notifyAll()方法 void notify() 唤醒正在等待对象监视器的单个线程 void notifyAll() 唤醒正在等待对象监视器的所有线程 3.2生产者和消费者案例【应用】 案例需求 桌子类(Desk)：定义表示包子数量的变量,定义锁对象变量,定义标记桌子上有无包子的变量 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务 1.判断是否有包子,决定当前线程是否执行 2.如果有包子,就进入等待状态,如果没有包子,继续执行,生产包子 3.生产包子之后,更新桌子上包子状态,唤醒消费者消费包子 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务 1.判断是否有包子,决定当前线程是否执行 2.如果没有包子,就进入等待状态,如果有包子,就消费包子 3.消费包子后,更新桌子上包子状态,唤醒生产者生产包子 测试类(Demo)：里面有main方法，main方法中的代码步骤如下 创建生产者线程和消费者线程对象 分别开启两个线程 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class Desk &#123; //定义一个标记 //true 就表示桌子上有汉堡包的,此时允许吃货执行 //false 就表示桌子上没有汉堡包的,此时允许厨师执行 public static boolean flag = false; //汉堡包的总数量 public static int count = 10; //锁对象 public static final Object lock = new Object();&#125;public class Cooker extends Thread &#123;// 生产者步骤：// 1，判断桌子上是否有汉堡包// 如果有就等待，如果没有才生产。// 2，把汉堡包放在桌子上。// 3，叫醒等待的消费者开吃。 @Override public void run() &#123; while(true)&#123; synchronized (Desk.lock)&#123; if(Desk.count == 0)&#123; break; &#125;else&#123; if(!Desk.flag)&#123; //生产 System.out.println(&quot;厨师正在生产汉堡包&quot;); Desk.flag = true; Desk.lock.notifyAll(); &#125;else&#123; try &#123; Desk.lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Foodie extends Thread &#123; @Override public void run() &#123;// 1，判断桌子上是否有汉堡包。// 2，如果没有就等待。// 3，如果有就开吃// 4，吃完之后，桌子上的汉堡包就没有了// 叫醒等待的生产者继续生产// 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while(true)&#123; synchronized (Desk.lock)&#123; if(Desk.count == 0)&#123; break; &#125;else&#123; if(Desk.flag)&#123; //有 System.out.println(&quot;吃货在吃汉堡包&quot;); Desk.flag = false; Desk.lock.notifyAll(); Desk.count--; &#125;else&#123; //没有就等待 //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法. try &#123; Desk.lock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; /*消费者步骤： 1，判断桌子上是否有汉堡包。 2，如果没有就等待。 3，如果有就开吃 4，吃完之后，桌子上的汉堡包就没有了 叫醒等待的生产者继续生产 汉堡包的总数量减一*/ /*生产者步骤： 1，判断桌子上是否有汉堡包 如果有就等待，如果没有才生产。 2，把汉堡包放在桌子上。 3，叫醒等待的消费者开吃。*/ Foodie f = new Foodie(); Cooker c = new Cooker(); f.start(); c.start(); &#125;&#125; 3.3生产者和消费者案例优化【应用】 需求 将Desk类中的变量,采用面向对象的方式封装起来 生产者和消费者类中构造方法接收Desk类对象,之后在run方法中进行使用 创建生产者和消费者线程对象,构造方法中传入Desk类对象 开启两个线程 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171public class Desk &#123; //定义一个标记 //true 就表示桌子上有汉堡包的,此时允许吃货执行 //false 就表示桌子上没有汉堡包的,此时允许厨师执行 //public static boolean flag = false; private boolean flag; //汉堡包的总数量 //public static int count = 10; //以后我们在使用这种必须有默认值的变量 // private int count = 10; private int count; //锁对象 //public static final Object lock = new Object(); private final Object lock = new Object(); public Desk() &#123; this(false,10); // 在空参内部调用带参,对成员变量进行赋值,之后就可以直接使用成员变量了 &#125; public Desk(boolean flag, int count) &#123; this.flag = flag; this.count = count; &#125; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; public int getCount() &#123; return count; &#125; public void setCount(int count) &#123; this.count = count; &#125; public Object getLock() &#123; return lock; &#125; @Override public String toString() &#123; return &quot;Desk&#123;&quot; + &quot;flag=&quot; + flag + &quot;, count=&quot; + count + &quot;, lock=&quot; + lock + &#x27;&#125;&#x27;; &#125;&#125;public class Cooker extends Thread &#123; private Desk desk; public Cooker(Desk desk) &#123; this.desk = desk; &#125;// 生产者步骤：// 1，判断桌子上是否有汉堡包// 如果有就等待，如果没有才生产。// 2，把汉堡包放在桌子上。// 3，叫醒等待的消费者开吃。 @Override public void run() &#123; while(true)&#123; synchronized (desk.getLock())&#123; if(desk.getCount() == 0)&#123; break; &#125;else&#123; //System.out.println(&quot;验证一下是否执行了&quot;); if(!desk.isFlag())&#123; //生产 System.out.println(&quot;厨师正在生产汉堡包&quot;); desk.setFlag(true); desk.getLock().notifyAll(); &#125;else&#123; try &#123; desk.getLock().wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Foodie extends Thread &#123; private Desk desk; public Foodie(Desk desk) &#123; this.desk = desk; &#125; @Override public void run() &#123;// 1，判断桌子上是否有汉堡包。// 2，如果没有就等待。// 3，如果有就开吃// 4，吃完之后，桌子上的汉堡包就没有了// 叫醒等待的生产者继续生产// 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while(true)&#123; synchronized (desk.getLock())&#123; if(desk.getCount() == 0)&#123; break; &#125;else&#123; //System.out.println(&quot;验证一下是否执行了&quot;); if(desk.isFlag())&#123; //有 System.out.println(&quot;吃货在吃汉堡包&quot;); desk.setFlag(false); desk.getLock().notifyAll(); desk.setCount(desk.getCount() - 1); &#125;else&#123; //没有就等待 //使用什么对象当做锁,那么就必须用这个对象去调用等待和唤醒的方法. try &#123; desk.getLock().wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; /*消费者步骤： 1，判断桌子上是否有汉堡包。 2，如果没有就等待。 3，如果有就开吃 4，吃完之后，桌子上的汉堡包就没有了 叫醒等待的生产者继续生产 汉堡包的总数量减一*/ /*生产者步骤： 1，判断桌子上是否有汉堡包 如果有就等待，如果没有才生产。 2，把汉堡包放在桌子上。 3，叫醒等待的消费者开吃。*/ Desk desk = new Desk(); Foodie f = new Foodie(desk); Cooker c = new Cooker(desk); f.start(); c.start(); &#125;&#125; 3.4阻塞队列基本使用【理解】 阻塞队列继承结构 常见BlockingQueue: ArrayBlockingQueue: 底层是数组,有界 LinkedBlockingQueue: 底层是链表,无界.但不是真正的无界,最大为int的最大值 BlockingQueue的核心方法: put(anObject): 将参数放入队列,如果放不进去会阻塞 take(): 取出第一个数据,取不到会阻塞 代码示例 123456789101112131415public class Demo02 &#123; public static void main(String[] args) throws Exception &#123; // 创建阻塞队列的对象,容量为 1 ArrayBlockingQueue&lt;String&gt; arrayBlockingQueue = new ArrayBlockingQueue&lt;&gt;(1); // 存储元素 arrayBlockingQueue.put(&quot;汉堡包&quot;); // 取元素 System.out.println(arrayBlockingQueue.take()); System.out.println(arrayBlockingQueue.take()); // 取不到会阻塞 System.out.println(&quot;程序结束了&quot;); &#125;&#125; 3.5阻塞队列实现等待唤醒机制【理解】 案例需求 生产者类(Cooker)：实现Runnable接口，重写run()方法，设置线程任务 1.构造方法中接收一个阻塞队列对象 2.在run方法中循环向阻塞队列中添加包子 3.打印添加结果 消费者类(Foodie)：实现Runnable接口，重写run()方法，设置线程任务 1.构造方法中接收一个阻塞队列对象 2.在run方法中循环获取阻塞队列中的包子 3.打印获取结果 测试类(Demo)：里面有main方法，main方法中的代码步骤如下 创建阻塞队列对象 创建生产者线程和消费者线程对象,构造方法中传入阻塞队列对象 分别开启两个线程 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Cooker extends Thread &#123; private ArrayBlockingQueue&lt;String&gt; bd; public Cooker(ArrayBlockingQueue&lt;String&gt; bd) &#123; this.bd = bd; &#125;// 生产者步骤：// 1，判断桌子上是否有汉堡包// 如果有就等待，如果没有才生产。// 2，把汉堡包放在桌子上。// 3，叫醒等待的消费者开吃。 @Override public void run() &#123; while (true) &#123; try &#123; bd.put(&quot;汉堡包&quot;); System.out.println(&quot;厨师放入一个汉堡包&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Foodie extends Thread &#123; private ArrayBlockingQueue&lt;String&gt; bd; public Foodie(ArrayBlockingQueue&lt;String&gt; bd) &#123; this.bd = bd; &#125; @Override public void run() &#123;// 1，判断桌子上是否有汉堡包。// 2，如果没有就等待。// 3，如果有就开吃// 4，吃完之后，桌子上的汉堡包就没有了// 叫醒等待的生产者继续生产// 汉堡包的总数量减一 //套路: //1. while(true)死循环 //2. synchronized 锁,锁对象要唯一 //3. 判断,共享数据是否结束. 结束 //4. 判断,共享数据是否结束. 没有结束 while (true) &#123; try &#123; String take = bd.take(); System.out.println(&quot;吃货将&quot; + take + &quot;拿出来吃了&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class Demo &#123; public static void main(String[] args) &#123; ArrayBlockingQueue&lt;String&gt; bd = new ArrayBlockingQueue&lt;&gt;(1); Foodie f = new Foodie(bd); Cooker c = new Cooker(bd); f.start(); c.start(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"IO(异常&File&综合案例）","slug":"27、IO-异常-File-综合案例）","date":"2022-06-09T01:00:00.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"27、IO-异常-File-综合案例）.html","link":"","permalink":"https://iexlee.github.io/27%E3%80%81IO-%E5%BC%82%E5%B8%B8-File-%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B%EF%BC%89.html","excerpt":"","text":"1. 异常1.1 异常概念异常，就是不正常的意思。在生活中:医生说,你的身体某个部位有异常,该部位和正常相比有点不同,该部位的功能将受影响.在程序中的意思就是： 异常 ：指的是程序在执行过程中，出现的非正常的情况，最终会导致JVM的非正常停止。 在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行. 1.2 异常体系异常机制其实是帮助我们找到程序中的问题，异常的根类是java.lang.Throwable，其下有两个子类：java.lang.Error与java.lang.Exception，平常所说的异常指java.lang.Exception。 Throwable体系： Error:严重错误Error，无法通过处理的错误，只能事先避免，好比绝症。 Exception:表示异常，异常产生后程序员可以通过代码的方式纠正，使程序继续运行，是必须要处理的。好比感冒、阑尾炎。 Throwable中的常用方法： public void printStackTrace():打印异常的详细信息。 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 public String getMessage():获取发生异常的原因。 提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 出现异常,不要紧张,把异常的简单类名,拷贝到API中去查。 1.3 异常分类我们平常说的异常就是指Exception，因为这类异常一旦出现，我们就要对代码进行更正，修复程序。 异常(Exception)的分类:根据在编译时期还是运行时期去检查异常? 编译时期异常:checked异常。在编译时期,就会检查,如果没有处理异常,则编译失败。(如日期格式化异常) 运行时期异常:runtime异常。在运行时期,检查异常.在编译时期,运行异常不会编译器检测(不报错)。(如数学异常) ​ 1.4 异常的产生过程解析先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。 工具类 1234567public class ArrayTools &#123; // 对给定的数组通过给定的角标获取元素。 public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element; &#125;&#125; 测试类 12345678public class ExceptionDemo &#123; public static void main(String[] args) &#123; int[] arr = &#123; 34, 12, 67 &#125;; intnum = ArrayTools.getElement(arr, 4) System.out.println(&quot;num=&quot; + num); System.out.println(&quot;over&quot;); &#125;&#125; 上述程序执行过程图解： 1.5 抛出异常throw在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。 在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？ 创建一个异常对象。封装一些提示信息(信息可以自己编写)。 需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象。 throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。 使用格式： 1throw new 异常类名(参数); 例如： 123throw new NullPointerException(&quot;要访问的arr数组不存在&quot;);throw new ArrayIndexOutOfBoundsException(&quot;该索引在数组中不存在，已超出范围&quot;); 学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。 123456789101112131415161718192021222324252627public class ThrowDemo &#123; public static void main(String[] args) &#123; //创建一个数组 int[] arr = &#123;2,4,52,2&#125;; //根据索引找对应的元素 int index = 4; int element = getElement(arr, index); System.out.println(element); System.out.println(&quot;over&quot;); &#125; /* * 根据 索引找到数组中对应的元素 */ public static int getElement(int[] arr,int index)&#123; //判断 索引是否越界 if(index&lt;0 || index&gt;arr.length-1)&#123; /* 判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。 这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。 */ throw new ArrayIndexOutOfBoundsException(&quot;哥们，角标越界了```&quot;); &#125; int element = arr[index]; return element; &#125;&#125; 注意：如果产生了问题，我们就会throw将问题描述类即异常进行抛出，也就是将问题返回给该方法的调用者。 那么对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续讲问题声明出去，使用throws声明处理。 1.6 声明异常throws声明异常：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。 关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常(抛出异常). 声明异常格式： 1修饰符 返回值类型 方法名(参数) throws 异常类名1,异常类名2…&#123; &#125; 声明异常的代码演示： 12345678910111213public class ThrowsDemo &#123; public static void main(String[] args) throws FileNotFoundException &#123; read(&quot;a.txt&quot;); &#125; // 如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明 public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。 123456789101112131415public class ThrowsDemo2 &#123; public static void main(String[] args) throws IOException &#123; read(&quot;a.txt&quot;); &#125; public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; if (!path.equals(&quot;b.txt&quot;)) &#123; throw new IOException(); &#125; &#125;&#125; 1.7 捕获异常try…catch如果异常出现的话,会立刻终止程序,所以我们得处理异常: 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。 在方法中使用try-catch的语句块来处理异常。 try-catch的方式就是捕获异常。 捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。 捕获异常语法如下： 123456try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; try：该代码块中编写可能产生异常的代码。 catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。 注意:try和catch都不能单独使用,必须连用。 演示如下： 123456789101112131415161718192021public class TryCatchDemo &#123; public static void main(String[] args) &#123; try &#123;// 当产生异常时，必须有处理方式。要么捕获，要么声明。 read(&quot;b.txt&quot;); &#125; catch (FileNotFoundException e) &#123;// 括号中需要定义什么呢？ //try中抛出的是什么异常，在括号中就定义什么异常类型 System.out.println(e); &#125; System.out.println(&quot;over&quot;); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; 如何获取异常信息： Throwable类中定义了一些查看方法: public String getMessage():获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。 public String toString():获取异常的类型和异常描述信息(不用)。 public void printStackTrace():打印异常的跟踪栈信息并输出到控制台。 ​ 包含了异常的类型,异常的原因,还包括异常出现的位置,在开发和调试阶段,都得使用printStackTrace。 在开发中呢也可以在catch将编译期异常转换成运行期异常处理。 多个异常使用捕获又该如何处理呢？ 多个异常分别处理。 多个异常一次捕获，多次处理。 多个异常一次捕获一次处理。 一般我们是使用一次捕获多次处理方式，格式如下： 123456789try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 1.8 finally 代码块finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。 什么时候的代码必须最终执行？ 当我们在try语句块中打开了一些物理资源(磁盘文件&#x2F;网络连接&#x2F;数据库连接等),我们都得在使用完之后,最终关闭打开的资源。 finally的语法: try…catch….finally:自身需要处理异常,最终还得关闭资源。 注意:finally不能单独使用。 比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭掉。 finally代码参考如下： 1234567891011121314151617181920212223public class TryCatchDemo4 &#123; public static void main(String[] args) &#123; try &#123; read(&quot;a.txt&quot;); &#125; catch (FileNotFoundException e) &#123; //抓取到的是编译期异常 抛出去的是运行期 throw new RuntimeException(e); &#125; finally &#123; System.out.println(&quot;不管程序怎样，这里都将会被执行。&quot;); &#125; System.out.println(&quot;over&quot;); &#125; /* * * 我们 当前的这个方法中 有异常 有编译期异常 */ public static void read(String path) throws FileNotFoundException &#123; if (!path.equals(&quot;a.txt&quot;)) &#123;//如果不是 a.txt这个文件 // 我假设 如果不是 a.txt 认为 该文件不存在 是一个错误 也就是异常 throw throw new FileNotFoundException(&quot;文件不存在&quot;); &#125; &#125;&#125; 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 1.9 异常注意事项 运行时异常被抛出可以不处理。即不捕获也不声明抛出。 如果父类抛出了多个异常,子类覆盖父类方法时,只能抛出相同的异常或者是他的子集。 父类方法没有抛出异常，子类覆盖父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出 当多异常处理时，捕获处理，前边的类不能是后边类的父类 在try&#x2F;catch后可以追加finally代码块，其中的代码一定会被执行，通常用于资源回收。 1.10 概述为什么需要自定义异常类: 我们说了Java中不同的异常类,分别表示着某一种具体的异常情况,那么在开发中总是有些异常情况是SUN没有定义好的,此时我们根据自己业务的异常情况来定义异常类。,例如年龄负数问题,考试成绩负数问题。 在上述代码中，发现这些异常都是JDK内部定义好的，但是实际开发中也会出现很多异常,这些异常很可能在JDK中没有定义过,例如年龄负数问题,考试成绩负数问题.那么能不能自己定义异常呢？ 什么是自定义异常类: 在开发中根据自己业务的异常情况来定义异常类. 自定义一个业务逻辑异常: LoginException。一个登陆异常类。 异常类如何定义: 自定义一个编译期异常: 自定义类 并继承于java.lang.Exception。 自定义一个运行时期的异常类:自定义类 并继承于java.lang.RuntimeException。 1.11 自定义异常的练习要求：我们模拟登陆操作，如果用户名已存在，则抛出异常并提示：亲，该用户名已经被注册。 首先定义一个登陆异常类LoginException： 12345678910111213141516// 业务逻辑异常public class LoginException extends Exception &#123; /** * 空参构造 */ public LoginException() &#123; &#125; /** * * @param message 表示异常提示 */ public LoginException(String message) &#123; super(message); &#125;&#125; 模拟登陆操作，使用数组模拟数据库中存储的数据，并提供当前注册账号是否存在方法用于判断。 123456789101112131415161718192021222324252627public class Demo &#123; // 模拟数据库中已存在账号 private static String[] names = &#123;&quot;bill&quot;,&quot;hill&quot;,&quot;jill&quot;&#125;; public static void main(String[] args) &#123; //调用方法 try&#123; // 可能出现异常的代码 checkUsername(&quot;nill&quot;); System.out.println(&quot;注册成功&quot;);//如果没有异常就是注册成功 &#125; catch(LoginException e) &#123; //处理异常 e.printStackTrace(); &#125; &#125; //判断当前注册账号是否存在 //因为是编译期异常，又想调用者去处理 所以声明该异常 public static boolean checkUsername(String uname) throws LoginException &#123; for (String name : names) &#123; if(name.equals(uname))&#123;//如果名字在这里面 就抛出登陆异常 throw new LoginException(&quot;亲&quot;+name+&quot;已经被注册了！&quot;); &#125; &#125; return true; &#125;&#125; 2. File类2.1 概述java.io.File 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。 2.2 构造方法 public File(String pathname) ：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 public File(String parent, String child) ：从父路径名字符串和子路径名字符串创建新的 File实例。 public File(File parent, String child) ：从父抽象路径名和子路径名字符串创建新的 File实例。 构造举例，代码如下： 1234567891011121314151617// 文件路径名String pathname = &quot;D:\\\\aaa.txt&quot;;File file1 = new File(pathname); // 文件路径名String pathname2 = &quot;D:\\\\aaa\\\\bbb.txt&quot;;File file2 = new File(pathname2); // 通过父路径和子路径字符串 String parent = &quot;d:\\\\aaa&quot;; String child = &quot;bbb.txt&quot;; File file3 = new File(parent, child);// 通过父级File对象和子路径字符串File parentDir = new File(&quot;d:\\\\aaa&quot;);String child = &quot;bbb.txt&quot;;File file4 = new File(parentDir, child); 小贴士： 一个File对象代表硬盘中实际存在的一个文件或者目录。 无论该路径下是否存在文件或者目录，都不影响File对象的创建。 2.3 常用方法获取功能的方法 public String getAbsolutePath() ：返回此File的绝对路径名字符串。 public String getPath() ：将此File转换为路径名字符串。 public String getName() ：返回由此File表示的文件或目录的名称。 public long length() ：返回由此File表示的文件的长度。 方法演示，代码如下： 12345678910111213141516171819202122232425public class FileGet &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:/aaa/bbb.java&quot;); System.out.println(&quot;文件绝对路径:&quot;+f.getAbsolutePath()); System.out.println(&quot;文件构造路径:&quot;+f.getPath()); System.out.println(&quot;文件名称:&quot;+f.getName()); System.out.println(&quot;文件长度:&quot;+f.length()+&quot;字节&quot;); File f2 = new File(&quot;d:/aaa&quot;); System.out.println(&quot;目录绝对路径:&quot;+f2.getAbsolutePath()); System.out.println(&quot;目录构造路径:&quot;+f2.getPath()); System.out.println(&quot;目录名称:&quot;+f2.getName()); System.out.println(&quot;目录长度:&quot;+f2.length()); &#125;&#125;输出结果：文件绝对路径:d:\\aaa\\bbb.java文件构造路径:d:\\aaa\\bbb.java文件名称:bbb.java文件长度:636字节目录绝对路径:d:\\aaa目录构造路径:d:\\aaa目录名称:aaa目录长度:4096 API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。 绝对路径和相对路径 绝对路径：从盘符开始的路径，这是一个完整的路径。 相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 1234567891011121314public class FilePath &#123; public static void main(String[] args) &#123; // D盘下的bbb.java文件 File f = new File(&quot;D:\\\\bbb.java&quot;); System.out.println(f.getAbsolutePath()); // 项目下的bbb.java文件 File f2 = new File(&quot;bbb.java&quot;); System.out.println(f2.getAbsolutePath()); &#125;&#125;输出结果：D:\\bbb.javaD:\\idea_project_test4\\bbb.java 判断功能的方法 public boolean exists() ：此File表示的文件或目录是否实际存在。 public boolean isDirectory() ：此File表示的是否为目录。 public boolean isFile() ：此File表示的是否为文件。 方法演示，代码如下： 1234567891011121314151617public class FileIs &#123; public static void main(String[] args) &#123; File f = new File(&quot;d:\\\\aaa\\\\bbb.java&quot;); File f2 = new File(&quot;d:\\\\aaa&quot;); // 判断是否存在 System.out.println(&quot;d:\\\\aaa\\\\bbb.java 是否存在:&quot;+f.exists()); System.out.println(&quot;d:\\\\aaa 是否存在:&quot;+f2.exists()); // 判断是文件还是目录 System.out.println(&quot;d:\\\\aaa 文件?:&quot;+f2.isFile()); System.out.println(&quot;d:\\\\aaa 目录?:&quot;+f2.isDirectory()); &#125;&#125;输出结果：d:\\aaa\\bbb.java 是否存在:trued:\\aaa 是否存在:trued:\\aaa 文件?:falsed:\\aaa 目录?:true 创建删除功能的方法 public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 public boolean delete() ：删除由此File表示的文件或目录。 public boolean mkdir() ：创建由此File表示的目录。 public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 方法演示，代码如下： 12345678910111213141516171819202122232425262728public class FileCreateDelete &#123; public static void main(String[] args) throws IOException &#123; // 文件的创建 File f = new File(&quot;aaa.txt&quot;); System.out.println(&quot;是否存在:&quot;+f.exists()); // false System.out.println(&quot;是否创建:&quot;+f.createNewFile()); // true System.out.println(&quot;是否存在:&quot;+f.exists()); // true // 目录的创建 File f2= new File(&quot;newDir&quot;); System.out.println(&quot;是否存在:&quot;+f2.exists());// false System.out.println(&quot;是否创建:&quot;+f2.mkdir()); // true System.out.println(&quot;是否存在:&quot;+f2.exists());// true // 创建多级目录 File f3= new File(&quot;newDira\\\\newDirb&quot;); System.out.println(f3.mkdir());// false File f4= new File(&quot;newDira\\\\newDirb&quot;); System.out.println(f4.mkdirs());// true // 文件的删除 System.out.println(f.delete());// true // 目录的删除 System.out.println(f2.delete());// true System.out.println(f4.delete());// false &#125;&#125; API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。 2.4 目录的遍历 public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。 public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 12345678910111213141516public class FileFor &#123; public static void main(String[] args) &#123; File dir = new File(&quot;d:\\\\java_code&quot;); //获取当前目录下的文件以及文件夹的名称。 String[] names = dir.list(); for(String name : names)&#123; System.out.println(name); &#125; //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息 File[] files = dir.listFiles(); for (File file : files) &#123; System.out.println(file); &#125; &#125;&#125; 小贴士： 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 2.5 综合练习练习1：创建文件夹​ 在当前模块下的aaa文件夹中创建一个a.txt文件 代码实现： 1234567891011121314151617181920public class Test1 &#123; public static void main(String[] args) throws IOException &#123; //需求：在当前模块下的aaa文件夹中创建一个a.txt文件 //1.创建a.txt的父级路径 File file = new File(&quot;myfile\\\\aaa&quot;); //2.创建父级路径 //如果aaa是存在的，那么此时创建失败的。 //如果aaa是不存在的，那么此时创建成功的。 file.mkdirs(); //3.拼接父级路径和子级路径 File src = new File(file,&quot;a.txt&quot;); boolean b = src.createNewFile(); if(b)&#123; System.out.println(&quot;创建成功&quot;); &#125;else&#123; System.out.println(&quot;创建失败&quot;); &#125; &#125;&#125; 练习2：查找文件（不考虑子文件夹）​ 定义一个方法找某一个文件夹中，是否有以avi结尾的电影（暂时不需要考虑子文件夹） 代码示例： 123456789101112131415161718192021222324252627282930public class Test2 &#123; public static void main(String[] args) &#123; /*需求： 定义一个方法找某一个文件夹中，是否有以avi结尾的电影。 （暂时不需要考虑子文件夹） */ File file = new File(&quot;D:\\\\aaa\\\\bbb&quot;); boolean b = haveAVI(file); System.out.println(b); &#125; /* * 作用：用来找某一个文件夹中，是否有以avi结尾的电影 * 形参：要查找的文件夹 * 返回值：查找的结果 存在true 不存在false * */ public static boolean haveAVI(File file)&#123;// D:\\\\aaa //1.进入aaa文件夹，而且要获取里面所有的内容 File[] files = file.listFiles(); //2.遍历数组获取里面的每一个元素 for (File f : files) &#123; //f：依次表示aaa文件夹里面每一个文件或者文件夹的路径 if(f.isFile() &amp;&amp; f.getName().endsWith(&quot;.avi&quot;))&#123; return true; &#125; &#125; //3.如果循环结束之后还没有找到，直接返回false return false; &#125;&#125; 练习3：（考虑子文件夹）​ 找到电脑中所有以avi结尾的电影。（需要考虑子文件夹） 代码示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Test3 &#123; public static void main(String[] args) &#123; /* 需求： 找到电脑中所有以avi结尾的电影。（需要考虑子文件夹） 套路： 1，进入文件夹 2，遍历数组 3，判断 4，判断 */ findAVI(); &#125; public static void findAVI()&#123; //获取本地所有的盘符 File[] arr = File.listRoots(); for (File f : arr) &#123; findAVI(f); &#125; &#125; public static void findAVI(File src)&#123;//&quot;C:\\\\ //1.进入文件夹src File[] files = src.listFiles(); //2.遍历数组,依次得到src里面每一个文件或者文件夹 if(files != null)&#123; for (File file : files) &#123; if(file.isFile())&#123; //3，判断，如果是文件，就可以执行题目的业务逻辑 String name = file.getName(); if(name.endsWith(&quot;.avi&quot;))&#123; System.out.println(file); &#125; &#125;else&#123; //4，判断，如果是文件夹，就可以递归 //细节：再次调用本方法的时候，参数一定要是src的次一级路径 findAVI(file); &#125; &#125; &#125; &#125;&#125; 练习4：删除多级文件夹需求： 如果我们要删除一个有内容的文件夹 1.先删除文件夹里面所有的内容 2.再删除自己 代码示例： 123456789101112131415161718192021222324252627282930313233343536public class Test4 &#123; public static void main(String[] args) &#123; /* 删除一个多级文件夹 如果我们要删除一个有内容的文件夹 1.先删除文件夹里面所有的内容 2.再删除自己 */ File file = new File(&quot;D:\\\\aaa\\\\src&quot;); delete(file); &#125; /* * 作用：删除src文件夹 * 参数：要删除的文件夹 * */ public static void delete(File src)&#123; //1.先删除文件夹里面所有的内容 //进入src File[] files = src.listFiles(); //遍历 for (File file : files) &#123; //判断,如果是文件，删除 if(file.isFile())&#123; file.delete(); &#125;else &#123; //判断,如果是文件夹，就递归 delete(file); &#125; &#125; //2.再删除自己 src.delete(); &#125;&#125; 练习5：统计大小​ 需求：统计一个文件夹的总大小 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Test5 &#123; public static void main(String[] args) &#123; /*需求： 统计一个文件夹的总大小 */ File file = new File(&quot;D:\\\\aaa\\\\src&quot;); long len = getLen(file); System.out.println(len);//4919189 &#125; /* * 作用： * 统计一个文件夹的总大小 * 参数： * 表示要统计的那个文件夹 * 返回值： * 统计之后的结果 * * 文件夹的总大小： * 说白了，文件夹里面所有文件的大小 * */ public static long getLen(File src)&#123; //1.定义变量进行累加 long len = 0; //2.进入src文件夹 File[] files = src.listFiles(); //3.遍历数组 for (File file : files) &#123; //4.判断 if(file.isFile())&#123; //我们就把当前文件的大小累加到len当中 len = len + file.length(); &#125;else&#123; //判断，如果是文件夹就递归 len = len + getLen(file); &#125; &#125; return len; &#125;&#125; 练习6：统计文件个数 需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹） 打印格式如下： txt:3个 doc:4个 jpg:6个 代码示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class Test6 &#123; public static void main(String[] args) throws IOException &#123; /* 需求：统计一个文件夹中每种文件的个数并打印。（考虑子文件夹） 打印格式如下： txt:3个 doc:4个 jpg:6个 */ File file = new File(&quot;D:\\\\aaa\\\\src&quot;); HashMap&lt;String, Integer&gt; hm = getCount(file); System.out.println(hm); &#125; /* * 作用： * 统计一个文件夹中每种文件的个数 * 参数： * 要统计的那个文件夹 * 返回值： * 用来统计map集合 * 键：后缀名 值：次数 * * a.txt * a.a.txt * aaa（不需要统计的） * * * */ public static HashMap&lt;String,Integer&gt; getCount(File src)&#123; //1.定义集合用来统计 HashMap&lt;String,Integer&gt; hm = new HashMap&lt;&gt;(); //2.进入src文件夹 File[] files = src.listFiles(); //3.遍历数组 for (File file : files) &#123; //4.判断，如果是文件，统计 if(file.isFile())&#123; //a.txt String name = file.getName(); String[] arr = name.split(&quot;\\\\.&quot;); if(arr.length &gt;= 2)&#123; String endName = arr[arr.length - 1]; if(hm.containsKey(endName))&#123; //存在 int count = hm.get(endName); count++; hm.put(endName,count); &#125;else&#123; //不存在 hm.put(endName,1); &#125; &#125; &#125;else&#123; //5.判断，如果是文件夹，递归 //sonMap里面是子文件中每一种文件的个数 HashMap&lt;String, Integer&gt; sonMap = getCount(file); //hm: txt=1 jpg=2 doc=3 //sonMap: txt=3 jpg=1 //遍历sonMap把里面的值累加到hm当中 Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = sonMap.entrySet(); for (Map.Entry&lt;String, Integer&gt; entry : entries) &#123; String key = entry.getKey(); int value = entry.getValue(); if(hm.containsKey(key))&#123; //存在 int count = hm.get(key); count = count + value; hm.put(key,count); &#125;else&#123; //不存在 hm.put(key,value); &#125; &#125; &#125; &#125; return hm; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"Stream流和方法引用","slug":"26、stream流和方法引用","date":"2022-06-05T01:00:00.000Z","updated":"2023-08-19T15:53:01.900Z","comments":true,"path":"26、stream流和方法引用.html","link":"","permalink":"https://iexlee.github.io/26%E3%80%81stream%E6%B5%81%E5%92%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8.html","excerpt":"","text":"1.不可变集合1.1 什么是不可变集合​ 是一个长度不可变，内容也无法修改的集合 1.2 使用场景​ 如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。 ​ 当集合对象被不可信的库调用时，不可变形式是安全的。 简单理解： ​ 不想让别人修改集合中的内容 比如说： 1，斗地主的54张牌，是不能添加，不能删除，不能修改的 2，斗地主的打牌规则：单张，对子，三张，顺子等，也是不能修改的 3，用代码获取的操作系统硬件信息，也是不能被修改的 1.3 不可变集合分类 不可变的list集合 不可变的set集合 不可变的map集合 1.4 不可变的list集合123456789101112131415161718192021222324252627282930313233343536373839404142public class ImmutableDemo1 &#123; public static void main(String[] args) &#123; /* 创建不可变的List集合 &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot; */ //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作 List&lt;String&gt; list = List.of(&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;); System.out.println(list.get(0)); System.out.println(list.get(1)); System.out.println(list.get(2)); System.out.println(list.get(3)); System.out.println(&quot;---------------------------&quot;); for (String s : list) &#123; System.out.println(s); &#125; System.out.println(&quot;---------------------------&quot;); Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(&quot;---------------------------&quot;); for (int i = 0; i &lt; list.size(); i++) &#123; String s = list.get(i); System.out.println(s); &#125; System.out.println(&quot;---------------------------&quot;); //list.remove(&quot;李四&quot;); //list.add(&quot;aaa&quot;); list.set(0,&quot;aaa&quot;); &#125;&#125; 1.5 不可变的Set集合123456789101112131415161718192021222324252627282930public class ImmutableDemo2 &#123; public static void main(String[] args) &#123; /* 创建不可变的Set集合 &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot; 细节： 当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性 */ //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作 Set&lt;String&gt; set = Set.of(&quot;张三&quot;, &quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;); for (String s : set) &#123; System.out.println(s); &#125; System.out.println(&quot;-----------------------&quot;); Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(&quot;-----------------------&quot;); //set.remove(&quot;王五&quot;); &#125;&#125; 1.6 不可变的Map集合1.6.1：键值对个数小于等于101234567891011121314151617181920212223242526272829303132333435public class ImmutableDemo3 &#123; public static void main(String[] args) &#123; /* 创建Map的不可变集合 细节1： 键是不能重复的 细节2： Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对 细节3： 如果我们要传递多个键值对对象，数量大于10个，在Map接口中还有一个方法 */ //一旦创建完毕之后，是无法进行修改的，在下面的代码中，只能进行查询操作 Map&lt;String, String&gt; map = Map.of(&quot;张三&quot;, &quot;南京&quot;, &quot;张三&quot;, &quot;北京&quot;, &quot;王五&quot;, &quot;上海&quot;, &quot;赵六&quot;, &quot;广州&quot;, &quot;孙七&quot;, &quot;深圳&quot;, &quot;周八&quot;, &quot;杭州&quot;, &quot;吴九&quot;, &quot;宁波&quot;, &quot;郑十&quot;, &quot;苏州&quot;, &quot;刘一&quot;, &quot;无锡&quot;, &quot;陈二&quot;, &quot;嘉兴&quot;); Set&lt;String&gt; keys = map.keySet(); for (String key : keys) &#123; String value = map.get(key); System.out.println(key + &quot;=&quot; + value); &#125; System.out.println(&quot;--------------------------&quot;); Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;String, String&gt; entry : entries) &#123; String key = entry.getKey(); String value = entry.getValue(); System.out.println(key + &quot;=&quot; + value); &#125; System.out.println(&quot;--------------------------&quot;); &#125;&#125; 1.6.2：键值对个数大于10123456789101112131415161718192021222324252627282930313233343536373839404142public class ImmutableDemo4 &#123; public static void main(String[] args) &#123; /* 创建Map的不可变集合,键值对的数量超过10个 */ //1.创建一个普通的Map集合 HashMap&lt;String, String&gt; hm = new HashMap&lt;&gt;(); hm.put(&quot;张三&quot;, &quot;南京&quot;); hm.put(&quot;李四&quot;, &quot;北京&quot;); hm.put(&quot;王五&quot;, &quot;上海&quot;); hm.put(&quot;赵六&quot;, &quot;北京&quot;); hm.put(&quot;孙七&quot;, &quot;深圳&quot;); hm.put(&quot;周八&quot;, &quot;杭州&quot;); hm.put(&quot;吴九&quot;, &quot;宁波&quot;); hm.put(&quot;郑十&quot;, &quot;苏州&quot;); hm.put(&quot;刘一&quot;, &quot;无锡&quot;); hm.put(&quot;陈二&quot;, &quot;嘉兴&quot;); hm.put(&quot;aaa&quot;, &quot;111&quot;); //2.利用上面的数据来获取一个不可变的集合/* //获取到所有的键值对对象（Entry对象） Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = hm.entrySet(); //把entries变成一个数组 Map.Entry[] arr1 = new Map.Entry[0]; //toArray方法在底层会比较集合的长度跟数组的长度两者的大小 //如果集合的长度 &gt; 数组的长度 ：数据在数组中放不下，此时会根据实际数据的个数，重新创建数组 //如果集合的长度 &lt;= 数组的长度：数据在数组中放的下，此时不会创建新的数组，而是直接用 Map.Entry[] arr2 = entries.toArray(arr1); //不可变的map集合 Map map = Map.ofEntries(arr2); map.put(&quot;bbb&quot;,&quot;222&quot;);*/ //Map&lt;Object, Object&gt; map = Map.ofEntries(hm.entrySet().toArray(new Map.Entry[0])); Map&lt;String, String&gt; map = Map.copyOf(hm); map.put(&quot;bbb&quot;,&quot;222&quot;); &#125;&#125; 2.Stream流2.1体验Stream流【理解】 案例需求 按照下面的要求完成集合的创建和遍历 创建一个集合，存储多个字符串元素 把集合中所有以”张”开头的元素存储到一个新的集合 把”张”开头的集合中的长度为3的元素存储到一个新的集合 遍历上一步得到的集合 原始方式示例代码 12345678910111213141516171819202122232425public class MyStream1 &#123; public static void main(String[] args) &#123; //集合的批量添加 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of(&quot;张三丰&quot;,&quot;张无忌&quot;,&quot;张翠山&quot;,&quot;王二麻子&quot;,&quot;张良&quot;,&quot;谢广坤&quot;)); //list.add() //遍历list1把以张开头的元素添加到list2中。 ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;(); for (String s : list1) &#123; if(s.startsWith(&quot;张&quot;))&#123; list2.add(s); &#125; &#125; //遍历list2集合，把其中长度为3的元素，再添加到list3中。 ArrayList&lt;String&gt; list3 = new ArrayList&lt;&gt;(); for (String s : list2) &#123; if(s.length() == 3)&#123; list3.add(s); &#125; &#125; for (String s : list3) &#123; System.out.println(s); &#125; &#125;&#125; 使用Stream流示例代码 1234567891011public class StreamDemo &#123; public static void main(String[] args) &#123; //集合的批量添加 ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(List.of(&quot;张三丰&quot;,&quot;张无忌&quot;,&quot;张翠山&quot;,&quot;王二麻子&quot;,&quot;张良&quot;,&quot;谢广坤&quot;)); //Stream流 list1.stream().filter(s-&gt;s.startsWith(&quot;张&quot;)) .filter(s-&gt;s.length() == 3) .forEach(s-&gt; System.out.println(s)); &#125;&#125; Stream流的好处 直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印 Stream流把真正的函数式编程风格引入到Java中 代码简洁 2.2Stream流的常见生成方式【应用】 Stream流的思想 Stream流的三类方法 获取Stream流 创建一条流水线,并把数据放到流水线上准备进行操作 中间方法 流水线上的操作 一次操作完毕之后,还可以继续进行其他操作 终结方法 一个Stream流只能有一个终结方法 是流水线上的最后一个操作 生成Stream流的方式 Collection体系集合 使用默认方法stream()生成流， default Stream stream() Map体系集合 把Map转成Set集合，间接的生成流 数组 通过Arrays中的静态方法stream生成流 同种数据类型的多个数据 通过Stream接口的静态方法of(T… values)生成流 代码演示 123456789101112131415161718192021222324public class StreamDemo &#123; public static void main(String[] args) &#123; //Collection体系的集合可以使用默认方法stream()生成流 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Stream&lt;String&gt; listStream = list.stream(); Set&lt;String&gt; set = new HashSet&lt;String&gt;(); Stream&lt;String&gt; setStream = set.stream(); //Map体系的集合间接的生成流 Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;(); Stream&lt;String&gt; keyStream = map.keySet().stream(); Stream&lt;Integer&gt; valueStream = map.values().stream(); Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream(); //数组可以通过Arrays中的静态方法stream生成流 String[] strArray = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;; Stream&lt;String&gt; strArrayStream = Arrays.stream(strArray); //同种数据类型的多个数据可以通过Stream接口的静态方法of(T... values)生成流 Stream&lt;String&gt; strArrayStream2 = Stream.of(&quot;hello&quot;, &quot;world&quot;, &quot;java&quot;); Stream&lt;Integer&gt; intStream = Stream.of(10, 20, 30); &#125;&#125; 2.3Stream流中间操作方法【应用】 概念 中间操作的意思是,执行完此方法之后,Stream流依然可以继续执行其他操作 常见方法 方法名 说明 Stream filter(Predicate predicate) 用于对流中的数据进行过滤 Stream limit(long maxSize) 返回此流中的元素组成的流，截取前指定参数个数的数据 Stream skip(long n) 跳过指定参数个数的数据，返回由该流的剩余元素组成的流 static Stream concat(Stream a, Stream b) 合并a和b两个流为一个流 Stream distinct() 返回由该流的不同元素（根据Object.equals(Object) ）组成的流 filter代码演示 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyStream3 &#123; public static void main(String[] args) &#123;// Stream&lt;T&gt; filter(Predicate predicate)：过滤// Predicate接口中的方法 boolean test(T t)：对给定的参数进行判断，返回一个布尔值 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张三丰&quot;); list.add(&quot;张无忌&quot;); list.add(&quot;张翠山&quot;); list.add(&quot;王二麻子&quot;); list.add(&quot;张良&quot;); list.add(&quot;谢广坤&quot;); //filter方法获取流中的 每一个数据. //而test方法中的s,就依次表示流中的每一个数据. //我们只要在test方法中对s进行判断就可以了. //如果判断的结果为true,则当前的数据留下 //如果判断的结果为false,则当前数据就不要.// list.stream().filter(// new Predicate&lt;String&gt;() &#123;// @Override// public boolean test(String s) &#123;// boolean result = s.startsWith(&quot;张&quot;);// return result;// &#125;// &#125;// ).forEach(s-&gt; System.out.println(s)); //因为Predicate接口中只有一个抽象方法test //所以我们可以使用lambda表达式来简化// list.stream().filter(// (String s)-&gt;&#123;// boolean result = s.startsWith(&quot;张&quot;);// return result;// &#125;// ).forEach(s-&gt; System.out.println(s)); list.stream().filter(s -&gt;s.startsWith(&quot;张&quot;)).forEach(s-&gt; System.out.println(s)); &#125;&#125; limit&amp;skip代码演示 123456789101112131415161718192021222324public class StreamDemo02 &#123; public static void main(String[] args) &#123; //创建一个集合，存储多个字符串元素 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;林青霞&quot;); list.add(&quot;张曼玉&quot;); list.add(&quot;王祖贤&quot;); list.add(&quot;柳岩&quot;); list.add(&quot;张敏&quot;); list.add(&quot;张无忌&quot;); //需求1：取前3个数据在控制台输出 list.stream().limit(3).forEach(s-&gt; System.out.println(s)); System.out.println(&quot;--------&quot;); //需求2：跳过3个元素，把剩下的元素在控制台输出 list.stream().skip(3).forEach(s-&gt; System.out.println(s)); System.out.println(&quot;--------&quot;); //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出 list.stream().skip(2).limit(2).forEach(s-&gt; System.out.println(s)); &#125;&#125; concat&amp;distinct代码演示 12345678910111213141516171819202122232425public class StreamDemo03 &#123; public static void main(String[] args) &#123; //创建一个集合，存储多个字符串元素 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;林青霞&quot;); list.add(&quot;张曼玉&quot;); list.add(&quot;王祖贤&quot;); list.add(&quot;柳岩&quot;); list.add(&quot;张敏&quot;); list.add(&quot;张无忌&quot;); //需求1：取前4个数据组成一个流 Stream&lt;String&gt; s1 = list.stream().limit(4); //需求2：跳过2个数据组成一个流 Stream&lt;String&gt; s2 = list.stream().skip(2); //需求3：合并需求1和需求2得到的流，并把结果在控制台输出// Stream.concat(s1,s2).forEach(s-&gt; System.out.println(s)); //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复 Stream.concat(s1,s2).distinct().forEach(s-&gt; System.out.println(s)); &#125;&#125; 2.4Stream流终结操作方法【应用】 概念 终结操作的意思是,执行完此方法之后,Stream流将不能再执行其他操作 常见方法 方法名 说明 void forEach(Consumer action) 对此流的每个元素执行操作 long count() 返回此流中的元素数 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyStream5 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;张三丰&quot;); list.add(&quot;张无忌&quot;); list.add(&quot;张翠山&quot;); list.add(&quot;王二麻子&quot;); list.add(&quot;张良&quot;); list.add(&quot;谢广坤&quot;); //method1(list); // long count()：返回此流中的元素数 long count = list.stream().count(); System.out.println(count); &#125; private static void method1(ArrayList&lt;String&gt; list) &#123; // void forEach(Consumer action)：对此流的每个元素执行操作 // Consumer接口中的方法void accept(T t)：对给定的参数执行此操作 //在forEach方法的底层,会循环获取到流中的每一个数据. //并循环调用accept方法,并把每一个数据传递给accept方法 //s就依次表示了流中的每一个数据. //所以,我们只要在accept方法中,写上处理的业务逻辑就可以了. list.stream().forEach( new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125; ); System.out.println(&quot;====================&quot;); //lambda表达式的简化格式 //是因为Consumer接口中,只有一个accept方法 list.stream().forEach( (String s)-&gt;&#123; System.out.println(s); &#125; ); System.out.println(&quot;====================&quot;); //lambda表达式还是可以进一步简化的. list.stream().forEach(s-&gt;System.out.println(s)); &#125;&#125; 2.5Stream流的收集操作【应用】 概念 对数据使用Stream流的方式操作完毕后,可以把流中的数据收集到集合中 常用方法 方法名 说明 R collect(Collector collector) 把结果收集到集合中 工具类Collectors提供了具体的收集方式 方法名 说明 public static Collector toList() 把元素收集到List集合中 public static Collector toSet() 把元素收集到Set集合中 public static Collector toMap(Function keyMapper,Function valueMapper) 把元素收集到Map集合中 代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// toList和toSet方法演示 public class MyStream7 &#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 10; i++) &#123; list1.add(i); &#125; list1.add(10); list1.add(10); list1.add(10); list1.add(10); list1.add(10); //filter负责过滤数据的. //collect负责收集数据. //获取流中剩余的数据,但是他不负责创建容器,也不负责把数据添加到容器中. //Collectors.toList() : 在底层会创建一个List集合.并把所有的数据添加到List集合中. List&lt;Integer&gt; list = list1.stream().filter(number -&gt; number % 2 == 0) .collect(Collectors.toList()); System.out.println(list); Set&lt;Integer&gt; set = list1.stream().filter(number -&gt; number % 2 == 0) .collect(Collectors.toSet()); System.out.println(set);&#125;&#125;/**Stream流的收集方法 toMap方法演示创建一个ArrayList集合，并添加以下字符串。字符串中前面是姓名，后面是年龄&quot;zhangsan,23&quot;&quot;lisi,24&quot;&quot;wangwu,25&quot;保留年龄大于等于24岁的人，并将结果收集到Map集合中，姓名为键，年龄为值*/public class MyStream8 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;zhangsan,23&quot;); list.add(&quot;lisi,24&quot;); list.add(&quot;wangwu,25&quot;); Map&lt;String, Integer&gt; map = list.stream().filter( s -&gt; &#123; String[] split = s.split(&quot;,&quot;); int age = Integer.parseInt(split[1]); return age &gt;= 24; &#125; // collect方法只能获取到流中剩余的每一个数据. //在底层不能创建容器,也不能把数据添加到容器当中 //Collectors.toMap 创建一个map集合并将数据添加到集合当中 // s 依次表示流中的每一个数据 //第一个lambda表达式就是如何获取到Map中的键 //第二个lambda表达式就是如何获取Map中的值 ).collect(Collectors.toMap( s -&gt; s.split(&quot;,&quot;)[0], s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1]) )); System.out.println(map); &#125;&#125; 2.6Stream流综合练习【应用】 案例需求 现在有两个ArrayList集合，分别存储6名男演员名称和6名女演员名称，要求完成如下的操作 男演员只要名字为3个字的前三人 女演员只要姓林的，并且不要第一个 把过滤后的男演员姓名和女演员姓名合并到一起 把上一步操作后的元素作为构造方法的参数创建演员对象,遍历数据 演员类Actor已经提供，里面有一个成员变量，一个带参构造方法，以及成员变量对应的get&#x2F;set方法 代码实现 演员类 123456789101112131415public class Actor &#123; private String name; public Actor(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132333435public class StreamTest &#123; public static void main(String[] args) &#123; //创建集合 ArrayList&lt;String&gt; manList = new ArrayList&lt;String&gt;(); manList.add(&quot;周润发&quot;); manList.add(&quot;成龙&quot;); manList.add(&quot;刘德华&quot;); manList.add(&quot;吴京&quot;); manList.add(&quot;周星驰&quot;); manList.add(&quot;李连杰&quot;); ArrayList&lt;String&gt; womanList = new ArrayList&lt;String&gt;(); womanList.add(&quot;林心如&quot;); womanList.add(&quot;张曼玉&quot;); womanList.add(&quot;林青霞&quot;); womanList.add(&quot;柳岩&quot;); womanList.add(&quot;林志玲&quot;); womanList.add(&quot;王祖贤&quot;); //男演员只要名字为3个字的前三人 Stream&lt;String&gt; manStream = manList.stream().filter(s -&gt; s.length() == 3).limit(3); //女演员只要姓林的，并且不要第一个 Stream&lt;String&gt; womanStream = womanList.stream().filter(s -&gt; s.startsWith(&quot;林&quot;)).skip(1); //把过滤后的男演员姓名和女演员姓名合并到一起 Stream&lt;String&gt; stream = Stream.concat(manStream, womanStream); // 将流中的数据封装成Actor对象之后打印 stream.forEach(name -&gt; &#123; Actor actor = new Actor(name); System.out.println(actor); &#125;); &#125;&#125; 3.方法引用3.1体验方法引用【理解】 方法引用的出现原因 在使用Lambda表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作 那么考虑一种情况：如果我们在Lambda中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑呢？答案肯定是没有必要 那我们又是如何使用已经存在的方案的呢？ 这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案 代码演示 1234567891011121314151617181920212223public interface Printable &#123; void printString(String s);&#125;public class PrintableDemo &#123; public static void main(String[] args) &#123; //在主方法中调用usePrintable方法// usePrintable((String s) -&gt; &#123;// System.out.println(s);// &#125;); //Lambda简化写法 usePrintable(s -&gt; System.out.println(s)); //方法引用 usePrintable(System.out::println); &#125; private static void usePrintable(Printable p) &#123; p.printString(&quot;爱生活爱Java&quot;); &#125;&#125; 3.2方法引用符【理解】 方法引用符 :: 该符号为引用运算符，而它所在的表达式被称为方法引用 推导与省略 如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载形式，它们都将被自动推导 如果使用方法引用，也是同样可以根据上下文进行推导 方法引用是Lambda的孪生兄弟 3.3引用类方法【应用】​ 引用类方法，其实就是引用类的静态方法 格式 类名::静态方法 范例 Integer::parseInt Integer类的方法：public static int parseInt(String s) 将此String转换为int类型数据 练习描述 定义一个接口(Converter)，里面定义一个抽象方法 int convert(String s); 定义一个测试类(ConverterDemo)，在测试类中提供两个方法 一个方法是：useConverter(Converter c) 一个方法是主方法，在主方法中调用useConverter方法 代码演示 1234567891011121314151617181920public interface Converter &#123; int convert(String s);&#125;public class ConverterDemo &#123; public static void main(String[] args) &#123; //Lambda写法 useConverter(s -&gt; Integer.parseInt(s)); //引用类方法 useConverter(Integer::parseInt); &#125; private static void useConverter(Converter c) &#123; int number = c.convert(&quot;666&quot;); System.out.println(number); &#125;&#125; 使用说明 Lambda表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数 3.4引用对象的实例方法【应用】​ 引用对象的实例方法，其实就引用类中的成员方法 格式 对象::成员方法 范例 “HelloWorld”::toUpperCase String类中的方法：public String toUpperCase() 将此String所有字符转换为大写 练习描述 定义一个类(PrintString)，里面定义一个方法 public void printUpper(String s)：把字符串参数变成大写的数据，然后在控制台输出 定义一个接口(Printer)，里面定义一个抽象方法 void printUpperCase(String s) 定义一个测试类(PrinterDemo)，在测试类中提供两个方法 一个方法是：usePrinter(Printer p) 一个方法是主方法，在主方法中调用usePrinter方法 代码演示 1234567891011121314151617181920212223242526272829public class PrintString &#123; //把字符串参数变成大写的数据，然后在控制台输出 public void printUpper(String s) &#123; String result = s.toUpperCase(); System.out.println(result); &#125;&#125;public interface Printer &#123; void printUpperCase(String s);&#125;public class PrinterDemo &#123; public static void main(String[] args) &#123; //Lambda简化写法 usePrinter(s -&gt; System.out.println(s.toUpperCase())); //引用对象的实例方法 PrintString ps = new PrintString(); usePrinter(ps::printUpper); &#125; private static void usePrinter(Printer p) &#123; p.printUpperCase(&quot;HelloWorld&quot;); &#125;&#125; 使用说明 Lambda表达式被对象的实例方法替代的时候，它的形式参数全部传递给该方法作为参数 3.5引用类的实例方法【应用】​ 引用类的实例方法，其实就是引用类中的成员方法 格式 类名::成员方法 范例 String::substring public String substring(int beginIndex,int endIndex) 从beginIndex开始到endIndex结束，截取字符串。返回一个子串，子串的长度为endIndex-beginIndex 练习描述 定义一个接口(MyString)，里面定义一个抽象方法： String mySubString(String s,int x,int y); 定义一个测试类(MyStringDemo)，在测试类中提供两个方法 一个方法是：useMyString(MyString my) 一个方法是主方法，在主方法中调用useMyString方法 代码演示 12345678910111213141516171819public interface MyString &#123; String mySubString(String s,int x,int y);&#125;public class MyStringDemo &#123; public static void main(String[] args) &#123; //Lambda简化写法 useMyString((s,x,y) -&gt; s.substring(x,y)); //引用类的实例方法 useMyString(String::substring); &#125; private static void useMyString(MyString my) &#123; String s = my.mySubString(&quot;HelloWorld&quot;, 2, 5); System.out.println(s); &#125;&#125; 使用说明 ​ Lambda表达式被类的实例方法替代的时候​ 第一个参数作为调用者​ 后面的参数全部传递给该方法作为参数 3.6引用构造器【应用】​ 引用构造器，其实就是引用构造方法 l格式 类名::new 范例 Student::new 练习描述 定义一个类(Student)，里面有两个成员变量(name,age) 并提供无参构造方法和带参构造方法，以及成员变量对应的get和set方法 定义一个接口(StudentBuilder)，里面定义一个抽象方法 Student build(String name,int age); 定义一个测试类(StudentDemo)，在测试类中提供两个方法 一个方法是：useStudentBuilder(StudentBuilder s) 一个方法是主方法，在主方法中调用useStudentBuilder方法 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125;public interface StudentBuilder &#123; Student build(String name,int age);&#125;public class StudentDemo &#123; public static void main(String[] args) &#123; //Lambda简化写法 useStudentBuilder((name,age) -&gt; new Student(name,age)); //引用构造器 useStudentBuilder(Student::new); &#125; private static void useStudentBuilder(StudentBuilder sb) &#123; Student s = sb.build(&quot;林青霞&quot;, 30); System.out.println(s.getName() + &quot;,&quot; + s.getAge()); &#125;&#125; 使用说明 Lambda表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"集合03","slug":"24、集合03","date":"2022-06-01T01:00:00.000Z","updated":"2023-08-19T15:53:01.900Z","comments":true,"path":"24、集合03.html","link":"","permalink":"https://iexlee.github.io/24%E3%80%81%E9%9B%86%E5%90%8803.html","excerpt":"","text":"1.Map集合1.1Map集合概述和特点【理解】 Map集合概述 1interface Map&lt;K,V&gt; K：键的类型；V：值的类型 Map集合的特点 双列集合,一个键对应一个值 键不可以重复,值可以重复 Map集合的基本使用 123456789101112131415public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //V put(K key, V value) 将指定的值与该映射中的指定键相关联 map.put(&quot;itheima001&quot;,&quot;林青霞&quot;); map.put(&quot;itheima002&quot;,&quot;张曼玉&quot;); map.put(&quot;itheima003&quot;,&quot;王祖贤&quot;); map.put(&quot;itheima003&quot;,&quot;柳岩&quot;); //输出集合对象 System.out.println(map); &#125;&#125; 1.2Map集合的基本功能【应用】 方法介绍 方法名 说明 V put(K key,V value) 添加元素 V remove(Object key) 根据键删除键值对元素 void clear() 移除所有的键值对元素 boolean containsKey(Object key) 判断集合是否包含指定的键 boolean containsValue(Object value) 判断集合是否包含指定的值 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中键值对的个数 示例代码 12345678910111213141516171819202122232425262728293031public class MapDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); //V put(K key,V value)：添加元素 map.put(&quot;张无忌&quot;,&quot;赵敏&quot;); map.put(&quot;郭靖&quot;,&quot;黄蓉&quot;); map.put(&quot;杨过&quot;,&quot;小龙女&quot;); //V remove(Object key)：根据键删除键值对元素// System.out.println(map.remove(&quot;郭靖&quot;));// System.out.println(map.remove(&quot;郭襄&quot;)); //void clear()：移除所有的键值对元素// map.clear(); //boolean containsKey(Object key)：判断集合是否包含指定的键// System.out.println(map.containsKey(&quot;郭靖&quot;));// System.out.println(map.containsKey(&quot;郭襄&quot;)); //boolean isEmpty()：判断集合是否为空// System.out.println(map.isEmpty()); //int size()：集合的长度，也就是集合中键值对的个数 System.out.println(map.size()); //输出集合对象 System.out.println(map); &#125;&#125; 1.3Map集合的获取功能【应用】 方法介绍 方法名 说明 V get(Object key) 根据键获取值 Set keySet() 获取所有键的集合 Collection values() 获取所有值的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 获取所有键值对对象的集合 示例代码 123456789101112131415161718192021222324252627public class MapDemo03 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(&quot;张无忌&quot;, &quot;赵敏&quot;); map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); map.put(&quot;杨过&quot;, &quot;小龙女&quot;); //V get(Object key):根据键获取值// System.out.println(map.get(&quot;张无忌&quot;));// System.out.println(map.get(&quot;张三丰&quot;)); //Set&lt;K&gt; keySet():获取所有键的集合// Set&lt;String&gt; keySet = map.keySet();// for(String key : keySet) &#123;// System.out.println(key);// &#125; //Collection&lt;V&gt; values():获取所有值的集合 Collection&lt;String&gt; values = map.values(); for(String value : values) &#123; System.out.println(value); &#125; &#125;&#125; 1.4Map集合的遍历(方式1)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 把所有的丈夫给集中起来 遍历丈夫的集合，获取到每一个丈夫 根据丈夫去找对应的妻子 步骤分析 获取所有键的集合。用keySet()方法实现 遍历键的集合，获取到每一个键。用增强for实现 根据键去找值。用get(Object key)方法实现 代码实现 1234567891011121314151617181920public class MapDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(&quot;张无忌&quot;, &quot;赵敏&quot;); map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); map.put(&quot;杨过&quot;, &quot;小龙女&quot;); //获取所有键的集合。用keySet()方法实现 Set&lt;String&gt; keySet = map.keySet(); //遍历键的集合，获取到每一个键。用增强for实现 for (String key : keySet) &#123; //根据键去找值。用get(Object key)方法实现 String value = map.get(key); System.out.println(key + &quot;,&quot; + value); &#125; &#125;&#125; 1.5Map集合的遍历(方式2)【应用】 遍历思路 我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合 获取所有结婚证的集合 遍历结婚证的集合，得到每一个结婚证 根据结婚证获取丈夫和妻子 步骤分析 获取所有键值对对象的集合 Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取所有键值对对象的集合 遍历键值对对象的集合，得到每一个键值对对象 用增强for实现，得到每一个Map.Entry 根据键值对对象获取键和值 用getKey()得到键 用getValue()得到值 代码实现 123456789101112131415161718192021public class MapDemo02 &#123; public static void main(String[] args) &#123; //创建集合对象 Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //添加元素 map.put(&quot;张无忌&quot;, &quot;赵敏&quot;); map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;); map.put(&quot;杨过&quot;, &quot;小龙女&quot;); //获取所有键值对对象的集合 Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet(); //遍历键值对对象的集合，得到每一个键值对对象 for (Map.Entry&lt;String, String&gt; me : entrySet) &#123; //根据键值对对象获取键和值 String key = me.getKey(); String value = me.getValue(); System.out.println(key + &quot;,&quot; + value); &#125; &#125;&#125; 2.HashMap集合2.1HashMap集合概述和特点【理解】 HashMap底层是哈希表结构的 依赖hashCode方法和equals方法保证键的唯一 如果键要存储的是自定义对象，需要重写hashCode和equals方法 2.2HashMap集合应用案例【应用】 案例需求 创建一个HashMap集合，键是学生对象(Student)，值是居住地 (String)。存储多个元素，并遍历。 要求保证键的唯一性：如果学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125;&#125; 测试类 12345678910111213141516171819202122232425public class HashMapDemo &#123; public static void main(String[] args) &#123; //创建HashMap集合对象 HashMap&lt;Student, String&gt; hm = new HashMap&lt;Student, String&gt;(); //创建学生对象 Student s1 = new Student(&quot;林青霞&quot;, 30); Student s2 = new Student(&quot;张曼玉&quot;, 35); Student s3 = new Student(&quot;王祖贤&quot;, 33); Student s4 = new Student(&quot;王祖贤&quot;, 33); //把学生添加到集合 hm.put(s1, &quot;西安&quot;); hm.put(s2, &quot;武汉&quot;); hm.put(s3, &quot;郑州&quot;); hm.put(s4, &quot;北京&quot;); //遍历集合 Set&lt;Student&gt; keySet = hm.keySet(); for (Student key : keySet) &#123; String value = hm.get(key); System.out.println(key.getName() + &quot;,&quot; + key.getAge() + &quot;,&quot; + value); &#125; &#125;&#125; 3.TreeMap集合3.1TreeMap集合概述和特点【理解】 TreeMap底层是红黑树结构 依赖自然排序或者比较器排序,对键进行排序 如果键存储的是自定义对象,需要实现Comparable接口或者在创建TreeMap对象时候给出比较器排序规则 3.2TreeMap集合应用案例【应用】 案例需求 创建一个TreeMap集合,键是学生对象(Student),值是籍贯(String),学生属性姓名和年龄,按照年龄进行排序并遍历 要求按照学生的年龄进行排序,如果年龄相同则按照姓名进行排序 代码实现 学生类 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Student o) &#123; //按照年龄进行排序 int result = o.getAge() - this.getAge(); //次要条件，按照姓名排序。 result = result == 0 ? o.getName().compareTo(this.getName()) : result; return result; &#125;&#125; 测试类 1234567891011121314151617181920212223public class Test1 &#123; public static void main(String[] args) &#123; // 创建TreeMap集合对象 TreeMap&lt;Student,String&gt; tm = new TreeMap&lt;&gt;(); // 创建学生对象 Student s1 = new Student(&quot;xiaohei&quot;,23); Student s2 = new Student(&quot;dapang&quot;,22); Student s3 = new Student(&quot;xiaomei&quot;,22); // 将学生对象添加到TreeMap集合中 tm.put(s1,&quot;江苏&quot;); tm.put(s2,&quot;北京&quot;); tm.put(s3,&quot;天津&quot;); // 遍历TreeMap集合,打印每个学生的信息 tm.forEach( (Student key, String value)-&gt;&#123; System.out.println(key + &quot;---&quot; + value); &#125; ); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"集合02","slug":"23、集合02","date":"2022-05-29T01:00:00.000Z","updated":"2023-08-19T15:53:01.896Z","comments":true,"path":"23、集合02.html","link":"","permalink":"https://iexlee.github.io/23%E3%80%81%E9%9B%86%E5%90%8802.html","excerpt":"","text":"1.泛型1.1泛型概述 泛型的介绍 ​ 泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制 泛型的好处 把运行时期的问题提前到了编译期间 避免了强制类型转换 泛型的定义格式 &lt;类型&gt;: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: &lt;类型1,类型2…&gt;: 指定多种类型的格式,多种类型之间用逗号隔开.例如: &lt;E,T&gt; &lt;K,V&gt; 2.Set集合2.1Set集合概述和特点【应用】 不可以存储重复元素 没有索引,不能使用普通for循环遍历 2.2Set集合的使用【应用】存储字符串并遍历 1234567891011121314151617181920212223242526public class MySet1 &#123; public static void main(String[] args) &#123; //创建集合对象 Set&lt;String&gt; set = new TreeSet&lt;&gt;(); //添加元素 set.add(&quot;ccc&quot;); set.add(&quot;aaa&quot;); set.add(&quot;aaa&quot;); set.add(&quot;bbb&quot;);// for (int i = 0; i &lt; set.size(); i++) &#123;// //Set集合是没有索引的，所以不能使用通过索引获取元素的方法// &#125; //遍历集合 Iterator&lt;String&gt; it = set.iterator(); while (it.hasNext())&#123; String s = it.next(); System.out.println(s); &#125; System.out.println(&quot;-----------------------------------&quot;); for (String s : set) &#123; System.out.println(s); &#125; &#125;&#125; 3.TreeSet集合3.1TreeSet集合概述和特点【应用】 不可以存储重复元素 没有索引 可以将元素按照规则进行排序 TreeSet()：根据其元素的自然排序进行排序 TreeSet(Comparator comparator) ：根据指定的比较器进行排序 3.2TreeSet集合基本使用【应用】存储Integer类型的整数并遍历 1234567891011121314151617181920public class TreeSetDemo01 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Integer&gt; ts = new TreeSet&lt;Integer&gt;(); //添加元素 ts.add(10); ts.add(40); ts.add(30); ts.add(50); ts.add(20); ts.add(30); //遍历集合 for(Integer i : ts) &#123; System.out.println(i); &#125; &#125;&#125; 3.3自然排序Comparable的使用【应用】 案例需求 存储学生对象并遍历，创建TreeSet集合使用无参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 使用空参构造创建TreeSet集合 用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的 自定义的Student类实现Comparable接口 自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(T o)方法 重写接口中的compareTo方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student implements Comparable&lt;Student&gt;&#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; @Override public int compareTo(Student o) &#123; //按照对象的年龄进行排序 //主要判断条件: 按照年龄从小到大排序 int result = this.age - o.age; //次要判断条件: 年龄相同时，按照姓名的字母顺序排序 result = result == 0 ? this.name.compareTo(o.getName()) : result; return result; &#125;&#125; 测试类 12345678910111213141516171819202122public class MyTreeSet2 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;(); //创建学生对象 Student s1 = new Student(&quot;zhangsan&quot;,28); Student s2 = new Student(&quot;lisi&quot;,27); Student s3 = new Student(&quot;wangwu&quot;,29); Student s4 = new Student(&quot;zhaoliu&quot;,28); Student s5 = new Student(&quot;qianqi&quot;,30); //把学生添加到集合 ts.add(s1); ts.add(s2); ts.add(s3); ts.add(s4); ts.add(s5); //遍历集合 for (Student student : ts) &#123; System.out.println(student); &#125; &#125;&#125; 3.4比较器排序Comparator的使用【应用】 案例需求 存储老师对象并遍历，创建TreeSet集合使用带参构造方法 要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序 实现步骤 用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的 比较器排序，就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法 重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写 代码实现 老师类 123456789101112131415161718192021222324252627282930313233343536public class Teacher &#123; private String name; private int age; public Teacher() &#123; &#125; public Teacher(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Teacher&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125;&#125; 测试类 1234567891011121314151617181920212223242526272829303132public class MyTreeSet4 &#123; public static void main(String[] args) &#123; //创建集合对象 TreeSet&lt;Teacher&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;Teacher&gt;() &#123; @Override public int compare(Teacher o1, Teacher o2) &#123; //o1表示现在要存入的那个元素 //o2表示已经存入到集合中的元素 //主要条件 int result = o1.getAge() - o2.getAge(); //次要条件 result = result == 0 ? o1.getName().compareTo(o2.getName()) : result; return result; &#125; &#125;); //创建老师对象 Teacher t1 = new Teacher(&quot;zhangsan&quot;,23); Teacher t2 = new Teacher(&quot;lisi&quot;,22); Teacher t3 = new Teacher(&quot;wangwu&quot;,24); Teacher t4 = new Teacher(&quot;zhaoliu&quot;,24); //把老师添加到集合 ts.add(t1); ts.add(t2); ts.add(t3); ts.add(t4); //遍历集合 for (Teacher teacher : ts) &#123; System.out.println(teacher); &#125; &#125;&#125; 3.5两种比较方式总结【理解】 两种比较方式小结 自然排序: 自定义类实现Comparable接口,重写compareTo方法,根据返回值进行排序 比较器排序: 创建TreeSet对象的时候传递Comparator的实现类对象,重写compare方法,根据返回值进行排序 在使用的时候,默认使用自然排序,当自然排序不满足现在的需求时,必须使用比较器排序 两种方式中关于返回值的规则 如果返回值为负数，表示当前存入的元素是较小值，存左边 如果返回值为0，表示当前存入的元素跟集合中元素重复了，不存 如果返回值为正数，表示当前存入的元素是较大值，存右边 4.数据结构4.1二叉树【理解】 二叉树的特点 二叉树中,任意一个节点的度要小于等于2 节点: 在树结构中,每一个元素称之为节点 度: 每一个节点的子节点数量称之为度 二叉树结构图 4.2二叉查找树【理解】 二叉查找树的特点 二叉查找树,又称二叉排序树或者二叉搜索树 每一个节点上最多有两个子节点 左子树上所有节点的值都小于根节点的值 右子树上所有节点的值都大于根节点的值 二叉查找树结构图 二叉查找树和二叉树对比结构图 二叉查找树添加节点规则 小的存左边 大的存右边 一样的不存 4.3平衡二叉树【理解】 平衡二叉树的特点 二叉树左右两个子树的高度差不超过1 任意节点的左右两个子树都是一颗平衡二叉树 平衡二叉树旋转 旋转触发时机 当添加一个节点之后,该树不再是一颗平衡二叉树 左旋 就是将根节点的右侧往左拉,原先的右子节点变成新的父节点,并把多余的左子节点出让,给已经降级的根节点当右子节点 右旋 就是将根节点的左侧往右拉,左子节点变成了新的父节点,并把多余的右子节点出让,给已经降级根节点当左子节点 平衡二叉树和二叉查找树对比结构图 平衡二叉树旋转的四种情况 左左 左左: 当根节点左子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行右旋即可 左右 左右: 当根节点左子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 先在左子树对应的节点位置进行左旋,在对整体进行右旋 右右 右右: 当根节点右子树的右子树有节点插入,导致二叉树不平衡 如何旋转: 直接对整体进行左旋即可 右左 右左:当根节点右子树的左子树有节点插入,导致二叉树不平衡 如何旋转: 先在右子树对应的节点位置进行右旋,在对整体进行左旋 4.3红黑树【理解】 红黑树的特点 平衡二叉B树 每一个节点可以是红或者黑 红黑树不是高度平衡的,它的平衡是通过”自己的红黑规则”进行实现的 红黑树的红黑规则有哪些 每一个节点或是红色的,或者是黑色的 根节点必须是黑色 如果一个节点没有子节点或者父节点,则该节点相应的指针属性值为Nil,这些Nil视为叶节点,每个叶节点(Nil)是黑色的 如果某一个节点是红色,那么它的子节点必须是黑色(不能出现两个红色节点相连 的情况) 对每一个节点,从该节点到其所有后代叶节点的简单路径上,均包含相同数目的黑色节点 红黑树添加节点的默认颜色 添加节点时,默认为红色,效率高 红黑树添加节点后如何保持红黑规则 根节点位置 直接变为黑色 非根节点位置 父节点为黑色 不需要任何操作,默认红色即可 父节点为红色 叔叔节点为红色 将”父节点”设为黑色,将”叔叔节点”设为黑色 将”祖父节点”设为红色 如果”祖父节点”为根节点,则将根节点再次变成黑色 叔叔节点为黑色 将”父节点”设为黑色 将”祖父节点”设为红色 以”祖父节点”为支点进行旋转 ##5.HashSet集合 5.1HashSet集合概述和特点【应用】 底层数据结构是哈希表 存取无序 不可以存储重复元素 没有索引,不能使用普通for循环遍历 5.2HashSet集合的基本应用【应用】存储字符串并遍历 123456789101112131415161718public class HashSetDemo &#123; public static void main(String[] args) &#123; //创建集合对象 HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); //添加元素 set.add(&quot;hello&quot;); set.add(&quot;world&quot;); set.add(&quot;java&quot;); //不包含重复元素的集合 set.add(&quot;world&quot;); //遍历 for(String s : set) &#123; System.out.println(s); &#125; &#125;&#125; 5.3哈希值【理解】 哈希值简介 ​ 是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值 如何获取哈希值 ​ Object类中的public int hashCode()：返回对象的哈希码值 哈希值的特点 同一个对象多次调用hashCode()方法返回的哈希值是相同的 默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同 5.4哈希表结构【理解】 JDK1.8以前 ​ 数组 + 链表 JDK1.8以后 节点个数少于等于8个 ​ 数组 + 链表 节点个数多于8个 ​ 数组 + 红黑树 5.5HashSet集合存储学生对象并遍历【应用】 案例需求 创建一个存储学生对象的集合，存储多个学生对象，使用程序实现在控制台遍历该集合 要求：学生对象的成员变量值相同，我们就认为是同一个对象 代码实现 学生类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Student &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; &#125; @Override public int hashCode() &#123; int result = name != null ? name.hashCode() : 0; result = 31 * result + age; return result; &#125;&#125; 测试类 123456789101112131415161718192021222324public class HashSetDemo02 &#123; public static void main(String[] args) &#123; //创建HashSet集合对象 HashSet&lt;Student&gt; hs = new HashSet&lt;Student&gt;(); //创建学生对象 Student s1 = new Student(&quot;林青霞&quot;, 30); Student s2 = new Student(&quot;张曼玉&quot;, 35); Student s3 = new Student(&quot;王祖贤&quot;, 33); Student s4 = new Student(&quot;王祖贤&quot;, 33); //把学生添加到集合 hs.add(s1); hs.add(s2); hs.add(s3); hs.add(s4); //遍历集合(增强for) for (Student s : hs) &#123; System.out.println(s.getName() + &quot;,&quot; + s.getAge()); &#125; &#125;&#125; 总结 ​ HashSet集合存储自定义类型元素,要想实现元素的唯一,要求必须重写hashCode方法和equals方法","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"集合01","slug":"22、集合01","date":"2022-05-22T01:00:00.000Z","updated":"2023-08-19T15:53:01.896Z","comments":true,"path":"22、集合01.html","link":"","permalink":"https://iexlee.github.io/22%E3%80%81%E9%9B%86%E5%90%8801.html","excerpt":"","text":"1.Collection集合1.1数组和集合的区别【理解】 相同点 都是容器,可以存储多个数据 不同点 数组的长度是不可变的,集合的长度是可变的 数组可以存基本数据类型和引用数据类型 集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类 1.2集合类体系结构【理解】 1.3Collection 集合概述和使用【应用】 Collection集合概述 是单例集合的顶层接口,它表示一组对象,这些对象也称为Collection的元素 JDK 不提供此接口的任何直接实现.它提供更具体的子接口(如Set和List)实现 创建Collection集合的对象 多态的方式 具体的实现类ArrayList Collection集合常用方法 方法名 说明 boolean add(E e) 添加元素 boolean remove(Object o) 从集合中移除指定的元素 boolean removeIf(Object o) 根据条件进行移除 void clear() 清空集合中的元素 boolean contains(Object o) 判断集合中是否存在指定的元素 boolean isEmpty() 判断集合是否为空 int size() 集合的长度，也就是集合中元素的个数 1.4Collection集合的遍历【应用】 迭代器介绍 迭代器,集合的专用遍历方式 Iterator iterator(): 返回此集合中元素的迭代器,通过集合对象的iterator()方法得到 Iterator中的常用方法 ​ boolean hasNext(): 判断当前位置是否有元素可以被取出​ E next(): 获取当前位置的元素,将迭代器对象移向下一个索引位置 Collection集合的遍历 123456789101112131415161718192021public class IteratorDemo1 &#123; public static void main(String[] args) &#123; //创建集合对象 Collection&lt;String&gt; c = new ArrayList&lt;&gt;(); //添加元素 c.add(&quot;hello&quot;); c.add(&quot;world&quot;); c.add(&quot;java&quot;); c.add(&quot;javaee&quot;); //Iterator&lt;E&gt; iterator()：返回此集合中元素的迭代器，通过集合的iterator()方法得到 Iterator&lt;String&gt; it = c.iterator(); //用while循环改进元素的判断和获取 while (it.hasNext()) &#123; String s = it.next(); System.out.println(s); &#125; &#125;&#125; 迭代器中删除的方法 ​ void remove(): 删除迭代器对象当前指向的元素 1234567891011121314151617181920public class IteratorDemo2 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); Iterator&lt;String&gt; it = list.iterator(); while(it.hasNext())&#123; String s = it.next(); if(&quot;b&quot;.equals(s))&#123; //指向谁,那么此时就删除谁. it.remove(); &#125; &#125; System.out.println(list); &#125;&#125; 1.5增强for循环【应用】 介绍 它是JDK5之后出现的,其内部原理是一个Iterator迭代器 实现Iterable接口的类才可以使用迭代器和增强for 简化数组和Collection集合的遍历 格式 ​ for(集合&#x2F;数组中元素的数据类型 变量名 : 集合&#x2F;数组名) { ​ &#x2F;&#x2F; 已经将当前遍历到的元素封装到变量中了,直接使用变量即可 ​ } 代码 123456789101112131415161718public class MyCollectonDemo1 &#123; public static void main(String[] args) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); list.add(&quot;e&quot;); list.add(&quot;f&quot;); //1,数据类型一定是集合或者数组中元素的类型 //2,str仅仅是一个变量名而已,在循环的过程中,依次表示集合或者数组中的每一个元素 //3,list就是要遍历的集合或者数组 for(String str : list)&#123; System.out.println(str); &#125; &#125;&#125; 2.List集合2.1List集合的概述和特点【记忆】 List集合的概述 有序集合,这里的有序指的是存取顺序 用户可以精确控制列表中每个元素的插入位置,用户可以通过整数索引访问元素,并搜索列表中的元素 与Set集合不同,列表通常允许重复的元素 List集合的特点 存取有序 可以重复 有索引 2.2List集合的特有方法【应用】 方法介绍 方法名 描述 void add(int index,E element) 在此集合中的指定位置插入指定的元素 E remove(int index) 删除指定索引处的元素，返回被删除的元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 E get(int index) 返回指定索引处的元素 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MyListDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(&quot;aaa&quot;); list.add(&quot;bbb&quot;); list.add(&quot;ccc&quot;); //method1(list); //method2(list); //method3(list); //method4(list); &#125; private static void method4(List&lt;String&gt; list) &#123; // E get(int index) 返回指定索引处的元素 String s = list.get(0); System.out.println(s); &#125; private static void method3(List&lt;String&gt; list) &#123; // E set(int index,E element) 修改指定索引处的元素，返回被修改的元素 //被替换的那个元素,在集合中就不存在了. String result = list.set(0, &quot;qqq&quot;); System.out.println(result); System.out.println(list); &#125; private static void method2(List&lt;String&gt; list) &#123; // E remove(int index) 删除指定索引处的元素，返回被删除的元素 //在List集合中有两个删除的方法 //第一个 删除指定的元素,返回值表示当前元素是否删除成功 //第二个 删除指定索引的元素,返回值表示实际删除的元素 String s = list.remove(0); System.out.println(s); System.out.println(list); &#125; private static void method1(List&lt;String&gt; list) &#123; // void add(int index,E element) 在此集合中的指定位置插入指定的元素 //原来位置上的元素往后挪一个索引. list.add(0,&quot;qqq&quot;); System.out.println(list); &#125;&#125; 3.数据结构3.1数据结构之栈和队列【记忆】 栈结构 ​ 先进后出 队列结构 ​ 先进先出 3.2数据结构之数组和链表【记忆】 数组结构 ​ 查询快、增删慢 队列结构 ​ 查询慢、增删快 4.List集合的实现类4.1List集合子类的特点【记忆】 ArrayList集合 ​ 底层是数组结构实现，查询快、增删慢 LinkedList集合 ​ 底层是链表结构实现，查询慢、增删快 4.2LinkedList集合的特有功能【应用】 特有方法 方法名 说明 public void addFirst(E e) 在该列表开头插入指定的元素 public void addLast(E e) 将指定的元素追加到此列表的末尾 public E getFirst() 返回此列表中的第一个元素 public E getLast() 返回此列表中的最后一个元素 public E removeFirst() 从此列表中删除并返回第一个元素 public E removeLast() 从此列表中删除并返回最后一个元素 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MyLinkedListDemo4 &#123; public static void main(String[] args) &#123; LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); list.add(&quot;aaa&quot;); list.add(&quot;bbb&quot;); list.add(&quot;ccc&quot;);// public void addFirst(E e) 在该列表开头插入指定的元素 //method1(list);// public void addLast(E e) 将指定的元素追加到此列表的末尾 //method2(list);// public E getFirst() 返回此列表中的第一个元素// public E getLast() 返回此列表中的最后一个元素 //method3(list);// public E removeFirst() 从此列表中删除并返回第一个元素// public E removeLast() 从此列表中删除并返回最后一个元素 //method4(list); &#125; private static void method4(LinkedList&lt;String&gt; list) &#123; String first = list.removeFirst(); System.out.println(first); String last = list.removeLast(); System.out.println(last); System.out.println(list); &#125; private static void method3(LinkedList&lt;String&gt; list) &#123; String first = list.getFirst(); String last = list.getLast(); System.out.println(first); System.out.println(last); &#125; private static void method2(LinkedList&lt;String&gt; list) &#123; list.addLast(&quot;www&quot;); System.out.println(list); &#125; private static void method1(LinkedList&lt;String&gt; list) &#123; list.addFirst(&quot;qqq&quot;); System.out.println(list); &#125;&#125; ​","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"算法","slug":"21、算法","date":"2022-05-16T01:00:00.000Z","updated":"2023-08-19T15:53:01.896Z","comments":true,"path":"21、算法.html","link":"","permalink":"https://iexlee.github.io/21%E3%80%81%E7%AE%97%E6%B3%95.html","excerpt":"","text":"常见的七种查找算法：​ 数据结构是数据存储的方式，算法是数据计算的方式。所以在开发中，算法和数据结构息息相关。今天的讲义中会涉及部分数据结构的专业名词，如果各位铁粉有疑惑，可以先看一下哥们后面录制的数据结构，再回头看算法。 1. 基本查找​ 也叫做顺序查找 ​ 说明：顺序查找适合于存储结构为数组或者链表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线的一端开始，顺序扫描，依次将遍历到的结点与要查找的值相比较，若相等则表示查找成功；若遍历结束仍没有找到相同的，表示查找失败。 示例代码： 1234567891011121314151617181920212223242526272829303132public class A01_BasicSearchDemo1 &#123; public static void main(String[] args) &#123; //基本查找/顺序查找 //核心： //从0索引开始挨个往后查找 //需求：定义一个方法利用基本查找，查询某个元素是否存在 //数据如下：&#123;131, 127, 147, 81, 103, 23, 7, 79&#125; int[] arr = &#123;131, 127, 147, 81, 103, 23, 7, 79&#125;; int number = 82; System.out.println(basicSearch(arr, number)); &#125; //参数： //一：数组 //二：要查找的元素 //返回值： //元素是否存在 public static boolean basicSearch(int[] arr, int number)&#123; //利用基本查找来查找number在数组中是否存在 for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i] == number)&#123; return true; &#125; &#125; return false; &#125;&#125; 2. 二分查找​ 也叫做折半查找 说明：元素必须是有序的，从小到大，或者从大到小都是可以的。 如果是无序的，也可以先进行排序。但是排序之后，会改变原有数据的顺序，查找出来元素位置跟原来的元素可能是不一样的，所以排序之后再查找只能判断当前数据是否在容器当中，返回的索引无实际的意义。 基本思想：也称为是折半查找，属于有序查找算法。用给定值先与中间结点比较。比较完之后有三种情况： 相等 说明找到了 要查找的数据比中间节点小 说明要查找的数字在中间节点左边 要查找的数据比中间节点大 说明要查找的数字在中间节点右边 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.itheima.search;public class A02_BinarySearchDemo1 &#123; public static void main(String[] args) &#123; //二分查找/折半查找 //核心： //每次排除一半的查找范围 //需求：定义一个方法利用二分查找，查询某个元素在数组中的索引 //数据如下：&#123;7, 23, 79, 81, 103, 127, 131, 147&#125; int[] arr = &#123;7, 23, 79, 81, 103, 127, 131, 147&#125;; System.out.println(binarySearch(arr, 150)); &#125; public static int binarySearch(int[] arr, int number)&#123; //1.定义两个变量记录要查找的范围 int min = 0; int max = arr.length - 1; //2.利用循环不断的去找要查找的数据 while(true)&#123; if(min &gt; max)&#123; return -1; &#125; //3.找到min和max的中间位置 int mid = (min + max) / 2; //4.拿着mid指向的元素跟要查找的元素进行比较 if(arr[mid] &gt; number)&#123; //4.1 number在mid的左边 //min不变，max = mid - 1； max = mid - 1; &#125;else if(arr[mid] &lt; number)&#123; //4.2 number在mid的右边 //max不变，min = mid + 1; min = mid + 1; &#125;else&#123; //4.3 number跟mid指向的元素一样 //找到了 return mid; &#125; &#125; &#125;&#125; 3. 插值查找在介绍插值查找之前，先考虑一个问题： ​ 为什么二分查找算法一定要是折半，而不是折四分之一或者折更多呢？ 其实就是因为方便，简单，但是如果我能在二分查找的基础上，让中间的mid点，尽可能靠近想要查找的元素，那不就能提高查找的效率了吗？ 二分查找中查找点计算如下： mid&#x3D;(low+high)&#x2F;2, 即mid&#x3D;low+1&#x2F;2*(high-low); 我们可以将查找的点改进为如下： mid&#x3D;low+(key-a[low])&#x2F;(a[high]-a[low])*(high-low)， 这样，让mid值的变化更靠近关键字key，这样也就间接地减少了比较次数。 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。 细节：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 代码跟二分查找类似，只要修改一下mid的计算方式即可。 4. 斐波那契查找在介绍斐波那契查找算法之前，我们先介绍一下很它紧密相连并且大家都熟知的一个概念——黄金分割。 黄金比例又称黄金分割，是指事物各部分间一定的数学比例关系，即将整体一分为二，较大部分与较小部分之比等于整体与较大部分之比，其比值约为1:0.618或1.618:1。 0.618被公认为最具有审美意义的比例数字，这个数值的作用不仅仅体现在诸如绘画、雕塑、音乐、建筑等艺术领域，而且在管理、工程设计等方面也有着不可忽视的作用。因此被称为黄金分割。 在数学中有一个非常有名的数学规律：斐波那契数列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89……. （从第三个数开始，后边每一个数都是前两个数的和）。 然后我们会发现，随着斐波那契数列的递增，前后两个数的比值会越来越接近0.618，利用这个特性，我们就可以将黄金比例运用到查找技术中。 基本思想：也是二分查找的一种提升算法，通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。 斐波那契查找也是在二分查找的基础上进行了优化，优化中间点mid的计算方式即可 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class FeiBoSearchDemo &#123; public static int maxSize = 20; public static void main(String[] args) &#123; int[] arr = &#123;1, 8, 10, 89, 1000, 1234&#125;; System.out.println(search(arr, 1234)); &#125; public static int[] getFeiBo() &#123; int[] arr = new int[maxSize]; arr[0] = 1; arr[1] = 1; for (int i = 2; i &lt; maxSize; i++) &#123; arr[i] = arr[i - 1] + arr[i - 2]; &#125; return arr; &#125; public static int search(int[] arr, int key) &#123; int low = 0; int high = arr.length - 1; //表示斐波那契数分割数的下标值 int index = 0; int mid = 0; //调用斐波那契数列 int[] f = getFeiBo(); //获取斐波那契分割数值的下标 while (high &gt; (f[index] - 1)) &#123; index++; &#125; //因为f[k]值可能大于a的长度，因此需要使用Arrays工具类，构造一个新法数组，并指向temp[],不足的部分会使用0补齐 int[] temp = Arrays.copyOf(arr, f[index]); //实际需要使用arr数组的最后一个数来填充不足的部分 for (int i = high + 1; i &lt; temp.length; i++) &#123; temp[i] = arr[high]; &#125; //使用while循环处理，找到key值 while (low &lt;= high) &#123; mid = low + f[index - 1] - 1; if (key &lt; temp[mid]) &#123;//向数组的前面部分进行查找 high = mid - 1; /* 对k--进行理解 1.全部元素=前面的元素+后面的元素 2.f[k]=k[k-1]+f[k-2] 因为前面有k-1个元素没所以可以继续分为f[k-1]=f[k-2]+f[k-3] 即在f[k-1]的前面继续查找k-- 即下次循环,mid=f[k-1-1]-1 */ index--; &#125; else if (key &gt; temp[mid]) &#123;//向数组的后面的部分进行查找 low = mid + 1; index -= 2; &#125; else &#123;//找到了 //需要确定返回的是哪个下标 if (mid &lt;= high) &#123; return mid; &#125; else &#123; return high; &#125; &#125; &#125; return -1; &#125;&#125; 5. 分块查找当数据表中的数据元素很多时，可以采用分块查找。 汲取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找 分块查找适用于数据较多，但是数据不会发生变化的情况，如果需要一边添加一边查找，建议使用哈希查找 分块查找的过程： 需要把数据分成N多小块，块与块之间不能有数据重复的交集。 给每一块创建对象单独存储到数组当中 查找数据的时候，先在数组查，当前数据属于哪一块 再到这一块中顺序查找 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package com.itheima.search;public class A03_BlockSearchDemo &#123; public static void main(String[] args) &#123; /* 分块查找 核心思想： 块内无序，块间有序 实现步骤： 1.创建数组blockArr存放每一个块对象的信息 2.先查找blockArr确定要查找的数据属于哪一块 3.再单独遍历这一块数据即可 */ int[] arr = &#123;16, 5, 9, 12,21, 18, 32, 23, 37, 26, 45, 34, 50, 48, 61, 52, 73, 66&#125;; //创建三个块的对象 Block b1 = new Block(21,0,5); Block b2 = new Block(45,6,11); Block b3 = new Block(73,12,17); //定义数组用来管理三个块的对象（索引表） Block[] blockArr = &#123;b1,b2,b3&#125;; //定义一个变量用来记录要查找的元素 int number = 37; //调用方法，传递索引表，数组，要查找的元素 int index = getIndex(blockArr,arr,number); //打印一下 System.out.println(index); &#125; //利用分块查找的原理，查询number的索引 private static int getIndex(Block[] blockArr, int[] arr, int number) &#123; //1.确定number是在那一块当中 int indexBlock = findIndexBlock(blockArr, number); if(indexBlock == -1)&#123; //表示number不在数组当中 return -1; &#125; //2.获取这一块的起始索引和结束索引 --- 30 // Block b1 = new Block(21,0,5); ---- 0 // Block b2 = new Block(45,6,11); ---- 1 // Block b3 = new Block(73,12,17); ---- 2 int startIndex = blockArr[indexBlock].getStartIndex(); int endIndex = blockArr[indexBlock].getEndIndex(); //3.遍历 for (int i = startIndex; i &lt;= endIndex; i++) &#123; if(arr[i] == number)&#123; return i; &#125; &#125; return -1; &#125; //定义一个方法，用来确定number在哪一块当中 public static int findIndexBlock(Block[] blockArr,int number)&#123; //100 //从0索引开始遍历blockArr，如果number小于max，那么就表示number是在这一块当中的 for (int i = 0; i &lt; blockArr.length; i++) &#123; if(number &lt;= blockArr[i].getMax())&#123; return i; &#125; &#125; return -1; &#125;&#125;class Block&#123; private int max;//最大值 private int startIndex;//起始索引 private int endIndex;//结束索引 public Block() &#123; &#125; public Block(int max, int startIndex, int endIndex) &#123; this.max = max; this.startIndex = startIndex; this.endIndex = endIndex; &#125; /** * 获取 * @return max */ public int getMax() &#123; return max; &#125; /** * 设置 * @param max */ public void setMax(int max) &#123; this.max = max; &#125; /** * 获取 * @return startIndex */ public int getStartIndex() &#123; return startIndex; &#125; /** * 设置 * @param startIndex */ public void setStartIndex(int startIndex) &#123; this.startIndex = startIndex; &#125; /** * 获取 * @return endIndex */ public int getEndIndex() &#123; return endIndex; &#125; /** * 设置 * @param endIndex */ public void setEndIndex(int endIndex) &#123; this.endIndex = endIndex; &#125; public String toString() &#123; return &quot;Block&#123;max = &quot; + max + &quot;, startIndex = &quot; + startIndex + &quot;, endIndex = &quot; + endIndex + &quot;&#125;&quot;; &#125;&#125; 6. 哈希查找哈希查找是分块查找的进阶版，适用于数据一边添加一边查找的情况。 一般是数组 + 链表的结合体或者是数组+链表 + 红黑树的结合体 在课程中，为了让大家方便理解，所以规定： 数组的0索引处存储1~100 数组的1索引处存储101~200 数组的2索引处存储201~300 以此类推 但是实际上，我们一般不会采取这种方式，因为这种方式容易导致一块区域添加的元素过多，导致效率偏低。 更多的是先计算出当前数据的哈希值，用哈希值跟数组的长度进行计算，计算出应存入的位置，再挂在数组的后面形成链表，如果挂的元素太多而且数组长度过长，我们也会把链表转化为红黑树，进一步提高效率。 具体的过程，大家可以参见B站阿玮讲解课程：从入门到起飞。在集合章节详细讲解了哈希表的数据结构。全程采取动画形式讲解，让大家一目了然。 在此不多做阐述。 7. 树表查找本知识点涉及到数据结构：树。 建议先看一下后面阿玮讲解的数据结构，再回头理解。 基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 二叉查找树（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree），具有下列性质的二叉树： 1）若任意节点左子树上所有的数据，均小于本身； 2）若任意节点右子树上所有的数据，均大于本身； 二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。 ​ 不同形态的二叉查找树如下图所示： 基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。 具体细节大家可以参见B站阿玮讲解课程：从入门到起飞。在集合章节详细讲解了树数据结构。全程采取动画形式讲解，让大家一目了然。 在此不多做阐述。 ​ 不管是二叉查找树，还是平衡二叉树，还是红黑树，查找的性能都比较高 十大排序算法：1. 冒泡排序冒泡排序（Bubble Sort）也是一种简单直观的排序算法。 它重复的遍历过要排序的数列，一次比较相邻的两个元素，如果他们的顺序错误就把他们交换过来。 这个算法的名字由来是因为越大的元素会经由交换慢慢”浮”到最后面。 当然，大家可以按照从大到小的方式进行排列。 1.1 算法步骤 相邻的元素两两比较，大的放右边，小的放左边 第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推 如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以 1.2 动图演示 1.3 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class A01_BubbleDemo &#123; public static void main(String[] args) &#123; /* 冒泡排序： 核心思想： 1，相邻的元素两两比较，大的放右边，小的放左边。 2，第一轮比较完毕之后，最大值就已经确定，第二轮可以少循环一次，后面以此类推。 3，如果数组中有n个数据，总共我们只要执行n-1轮的代码就可以。 */ //1.定义数组 int[] arr = &#123;2, 4, 5, 3, 1&#125;; //2.利用冒泡排序将数组中的数据变成 1 2 3 4 5 //外循环：表示我要执行多少轮。 如果有n个数据，那么执行n - 1 轮 for (int i = 0; i &lt; arr.length - 1; i++) &#123; //内循环：每一轮中我如何比较数据并找到当前的最大值 //-1：为了防止索引越界 //-i：提高效率，每一轮执行的次数应该比上一轮少一次。 for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; //i 依次表示数组中的每一个索引：0 1 2 3 4 if(arr[j] &gt; arr[j + 1])&#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; printArr(arr); &#125; private static void printArr(int[] arr) &#123; //3.遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println(); &#125;&#125; 2. 选择排序2.1 算法步骤 从0索引开始，跟后面的元素一一比较 小的放前面，大的放后面 第一次循环结束后，最小的数据已经确定 第二次循环从1索引开始以此类推 第三轮循环从2索引开始以此类推 第四轮循环从3索引开始以此类推。 2.2 动图演示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class A02_SelectionDemo &#123; public static void main(String[] args) &#123; /* 选择排序： 1，从0索引开始，跟后面的元素一一比较。 2，小的放前面，大的放后面。 3，第一次循环结束后，最小的数据已经确定。 4，第二次循环从1索引开始以此类推。 */ //1.定义数组 int[] arr = &#123;2, 4, 5, 3, 1&#125;; //2.利用选择排序让数组变成 1 2 3 4 5 /* //第一轮： //从0索引开始，跟后面的元素一一比较。 for (int i = 0 + 1; i &lt; arr.length; i++) &#123; //拿着0索引跟后面的数据进行比较 if(arr[0] &gt; arr[i])&#123; int temp = arr[0]; arr[0] = arr[i]; arr[i] = temp; &#125; &#125;*/ //最终代码： //外循环：几轮 //i:表示这一轮中，我拿着哪个索引上的数据跟后面的数据进行比较并交换 for (int i = 0; i &lt; arr.length -1; i++) &#123; //内循环：每一轮我要干什么事情？ //拿着i跟i后面的数据进行比较交换 for (int j = i + 1; j &lt; arr.length; j++) &#123; if(arr[i] &gt; arr[j])&#123; int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; printArr(arr); &#125; private static void printArr(int[] arr) &#123; //3.遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println(); &#125;&#125; 3. 插入排序插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过创建有序序列和无序序列，然后再遍历无序序列得到里面每一个数字，把每一个数字插入到有序序列中正确的位置。 插入排序在插入的时候，有优化算法，在遍历有序序列找正确位置时，可以采取二分查找 3.1 算法步骤将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。 遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。 N的范围：0~最大索引 3.2 动图演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.itheima.mysort;public class A03_InsertDemo &#123; public static void main(String[] args) &#123; /* 插入排序： 将0索引的元素到N索引的元素看做是有序的，把N+1索引的元素到最后一个当成是无序的。 遍历无序的数据，将遍历到的元素插入有序序列中适当的位置，如遇到相同数据，插在后面。 N的范围：0~最大索引 */ int[] arr = &#123;3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48&#125;; //1.找到无序的哪一组数组是从哪个索引开始的。 2 int startIndex = -1; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &gt; arr[i + 1])&#123; startIndex = i + 1; break; &#125; &#125; //2.遍历从startIndex开始到最后一个元素，依次得到无序的哪一组数据中的每一个元素 for (int i = startIndex; i &lt; arr.length; i++) &#123; //问题：如何把遍历到的数据，插入到前面有序的这一组当中 //记录当前要插入数据的索引 int j = i; while(j &gt; 0 &amp;&amp; arr[j] &lt; arr[j - 1])&#123; //交换位置 int temp = arr[j]; arr[j] = arr[j - 1]; arr[j - 1] = temp; j--; &#125; &#125; printArr(arr); &#125; private static void printArr(int[] arr) &#123; //3.遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125; System.out.println(); &#125;&#125; 4. 快速排序快速排序是由东尼·霍尔所发展的一种排序算法。 快速排序又是一种分而治之思想在排序算法上的典型应用。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！ 它是处理大数据最快的排序算法之一了。 4.1 算法步骤 从数列中挑出一个元素，一般都是左边第一个数字，称为 “基准数”; 创建两个指针，一个从前往后走，一个从后往前走。 先执行后面的指针，找出第一个比基准数小的数字 再执行前面的指针，找出第一个比基准数大的数字 交换两个指针指向的数字 直到两个指针相遇 将基准数跟指针指向位置的数字交换位置，称之为：基准数归位。 第一轮结束之后，基准数左边的数字都是比基准数小的，基准数右边的数字都是比基准数大的。 把基准数左边看做一个序列，把基准数右边看做一个序列，按照刚刚的规则递归排序 4.2 动图演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package com.itheima.mysort;import java.util.Arrays;public class A05_QuickSortDemo &#123; public static void main(String[] args) &#123; System.out.println(Integer.MAX_VALUE); System.out.println(Integer.MIN_VALUE); /* 快速排序： 第一轮：以0索引的数字为基准数，确定基准数在数组中正确的位置。 比基准数小的全部在左边，比基准数大的全部在右边。 后面以此类推。 */ int[] arr = &#123;1,1, 6, 2, 7, 9, 3, 4, 5, 1,10, 8&#125;; //int[] arr = new int[1000000]; /* Random r = new Random(); for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = r.nextInt(); &#125;*/ long start = System.currentTimeMillis(); quickSort(arr, 0, arr.length - 1); long end = System.currentTimeMillis(); System.out.println(end - start);//149 System.out.println(Arrays.toString(arr)); //课堂练习： //我们可以利用相同的办法去测试一下，选择排序，冒泡排序以及插入排序运行的效率 //得到一个结论：快速排序真的非常快。 /* for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + &quot; &quot;); &#125;*/ &#125; /* * 参数一：我们要排序的数组 * 参数二：要排序数组的起始索引 * 参数三：要排序数组的结束索引 * */ public static void quickSort(int[] arr, int i, int j) &#123; //定义两个变量记录要查找的范围 int start = i; int end = j; if(start &gt; end)&#123; //递归的出口 return; &#125; //记录基准数 int baseNumber = arr[i]; //利用循环找到要交换的数字 while(start != end)&#123; //利用end，从后往前开始找，找比基准数小的数字 //int[] arr = &#123;1, 6, 2, 7, 9, 3, 4, 5, 10, 8&#125;; while(true)&#123; if(end &lt;= start || arr[end] &lt; baseNumber)&#123; break; &#125; end--; &#125; System.out.println(end); //利用start，从前往后找，找比基准数大的数字 while(true)&#123; if(end &lt;= start || arr[start] &gt; baseNumber)&#123; break; &#125; start++; &#125; //把end和start指向的元素进行交换 int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; &#125; //当start和end指向了同一个元素的时候，那么上面的循环就会结束 //表示已经找到了基准数在数组中应存入的位置 //基准数归位 //就是拿着这个范围中的第一个数字，跟start指向的元素进行交换 int temp = arr[i]; arr[i] = arr[start]; arr[start] = temp; //确定6左边的范围，重复刚刚所做的事情 quickSort(arr,i,start - 1); //确定6右边的范围，重复刚刚所做的事情 quickSort(arr,start + 1,j); &#125;&#125; 其他排序方式待更新~","categories":[{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-09-01T01:09:09.000Z","updated":"2023-08-19T15:53:01.904Z","comments":true,"path":"hello-world.html","link":"","permalink":"https://iexlee.github.io/hello-world.html","excerpt":"","text":"这是xlee博客的第一篇文章","categories":[],"tags":[{"name":"Example","slug":"Example","permalink":"https://iexlee.github.io/tags/Example/"}]}],"categories":[{"name":"git","slug":"git","permalink":"https://iexlee.github.io/categories/git/"},{"name":"数据库","slug":"数据库","permalink":"https://iexlee.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java","slug":"Java","permalink":"https://iexlee.github.io/categories/Java/"}],"tags":[{"name":"Example","slug":"Example","permalink":"https://iexlee.github.io/tags/Example/"}]}